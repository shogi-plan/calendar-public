<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>遠タメ将棋 Online</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
  <style>
    :root { 
      --board-color: #edc9af; 
      --primary-btn: #2196f3; 
      --danger-btn: #d32f2f; 
      --select-color: #ff9800;
      --call-btn: #4caf50;
    }
    body { 
  font-family: sans-serif; 
  display: flex; 
  flex-direction: column; 
  align-items: center; 
  background: #eee; 
  margin: 0; 
  padding: 2px; 
  /* overflow-x: hidden; を削除し、必要に応じてスクロール可能にする */
  touch-action: manipulation; 
}

#game-main { 
  display: flex; 
  flex-direction: row; 
  justify-content: center;     /* 中央寄せ */
  align-items: flex-start; 
  width: 100%;
  max-width: 100vw;            /* 画面幅を絶対超えない */
  gap: 2px;                    /* 隙間を最小限に */
  margin: 0 auto;
  overflow: hidden;            /* スクロールを禁止 */
  padding: 5px 2px;
  box-sizing: border-box;
}

    #board-container { position: relative; width: 58vw; max-width: 380px; aspect-ratio: 1 / 1; flex-shrink: 1; }
    #board { display: grid; grid-template-columns: repeat(9, 11.1111%); grid-template-rows: repeat(9, 11.1111%); border: 1px solid #222; width: 100%; height: 100%; background: var(--board-color); box-sizing: border-box; }
    
    /* --- 左右に配置する駒台（2列×10行） --- */
    .hand { 
      width: 38px;               /* 幅を縮小 */
      height: 58vw;              /* 盤面の新しい幅(58vw)に合わせる */
      max-height: 380px; 
      border: 1px solid #999; 
      background: #fff; 
      display: flex; 
      flex-direction: column; 
      flex-wrap: wrap; 
      align-content: flex-start; 
      padding: 14px 2px 2px 2px; /* パディングも微調整 */
      gap: 2px; 
      border-radius: 3px; 
      position: relative; 
      box-sizing: border-box;
      flex-shrink: 0;
    }
    .hand::before { content: attr(data-label); position: absolute; top: 1px; left: 0; width: 100%; text-align: center; font-size: 9px; font-weight: bold; color: #333; }

    /* 駒：10行に収まるサイズに自動調整 */
    .hand span { 
      width: 16px;               /* 19pxから3px縮小 */
      height: calc((100% - 18px) / 10); 
      border: 1px solid #777; 
      background: #f0f0f0; 
      display: inline-flex; 
      align-items: center; 
      justify-content: center; 
      font-size: 10px;           /* 文字も少し小さく */
      box-sizing: border-box;
      flex-shrink: 0;
      cursor: pointer;
      transform-origin: center;
    }

    .hand span.selected-piece { background: var(--select-color) !important; color: white; border-color: #e68a00; }

    /* 棋譜パネル：先手駒台のさらに右側に配置 */
    #review-panel { display: none; width: 75px; height: 58vw; max-height: 380px; background: #fff; border: 1px solid #999; border-radius: 2px; flex-direction: column; box-sizing: border-box; flex-shrink: 0; }

    /* その他パーツのスタイル（以前のものを維持） */
    .cell { display: flex; align-items: center; justify-content: center; border: 0.5px solid rgba(0,0,0,0.2); box-sizing: border-box; width: 100%; height: 100%; }
    .selected { background: var(--select-color) !important; box-shadow: inset 0 0 5px rgba(0,0,0,0.3); }
    .piece-font { font-weight: bold; font-size: 4.5vw; line-height: 1; }
    @media (min-width: 500px) { .piece-font { font-size: 22px; } }
    .piece { 
  z-index: 10; 
  pointer-events: none; 
  display: flex;             /* 中央揃えを確実にする */
  align-items: center; 
  justify-content: center; 
}
    .piece.opposite { transform: rotate(180deg); }
    .piece.promoted { color: var(--danger-btn); }
    .kifu-list { flex-grow: 1; overflow-y: scroll; background: #fafafa; font-size: 9px; padding: 0; margin: 0; }
    .kifu-item { padding: 5px 1px; cursor: pointer; border-bottom: 1px solid #eee; text-align: center; white-space: nowrap; }
    .kifu-item.active { background: var(--primary-btn); color: white; }
    .nav-controls { display: grid; grid-template-columns: 1fr 1fr; background: #ddd; gap: 1px; padding: 1px; }
    .nav-btn { font-size: 9px; padding: 7px 0; border: 1px solid #bbb; background: #fff; cursor: pointer; font-weight: bold; }
    #nav-pos { grid-column: span 2; font-size: 9px; text-align: center; background: #eee; padding: 2px 0; border-bottom: solid 1px #ccc; }
    .controls { display: flex; gap: 2px; margin-bottom: 4px; flex-wrap: wrap; justify-content: center; background: #ddd; padding: 4px; border-radius: 4px; width: 98%; box-sizing: border-box; }
    button { cursor: pointer; border: none; border-radius: 3px; font-weight: bold; padding: 5px 6px; font-size: 11px; }
    button:disabled { background: #bbb !important; opacity: 0.6; cursor: not-allowed; }
    #btnReset { background: var(--danger-btn); color: white; }
    #btnToggleReview { background: var(--primary-btn); color: white; }
    .status-area { display: flex; gap: 4px; margin-bottom: 4px; width: 100%; justify-content: center; }
    .timer { font-family: monospace; font-size: 14px; font-weight: bold; background: #fff; padding: 2px 4px; border: 1px solid #555; border-radius: 3px; min-width: 70px; text-align: center; }
    .your-turn { border-color: var(--danger-btn); background: #ffebee; }
    .timer-alert { color: var(--danger-btn) !important; }
    #promote-dialog { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border: 4px solid #5d4037; z-index: 2000; text-align: center; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); min-width: 160px; }
    .call-area { display: flex; flex-wrap: wrap; gap: 4px; margin: 4px 0; background: #fff; padding: 5px; border-radius: 5px; border: 1px solid #ccc; align-items: center; justify-content: center; width: 98%; box-sizing: border-box; }
    #btnCallStart { background: var(--call-btn); color: white; }
    #btnMute { background: #757575; color: white; }
    #btnCallEnd { background: var(--danger-btn); color: white; }
    #callStatusDisplay { font-size: 10px; color: #333; font-weight: bold; }
    .vol-ctrl { font-size: 10px; display: flex; align-items: center; gap: 2px; }
    .chat-message { margin-bottom: 4px; line-height: 1.4; border-bottom: 1px dotted #eee; padding-bottom: 2px; font-size: 12px;}
    .chat-name { font-weight: bold; margin-right: 5px; }
    .chat-name.S { color: #1976d2; }
    .chat-name.G { color: #d32f2f; }
    
    /* 左側の持ち駒エリアを上下反転させる */
.hand.left-rotated {
  transform: rotate(180deg);
}

    /* 追加：設定ボタンとダイアログのスタイル */
    :root { --setting-btn: #607d8b; }
    #btnSetting { background: var(--setting-btn); color: white; }
    #setting-dialog { 
      display: none; 
      position: fixed; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%, -50%); 
      background: white; 
      padding: 20px; 
      border-radius: 8px; 
      box-shadow: 0 0 20px rgba(0,0,0,0.5); 
      z-index: 3000; 
      width: 280px; 
    }
    .setting-row { margin-bottom: 15px; }
    .setting-row label { display: block; font-size: 12px; font-weight: bold; margin-bottom: 5px; }
    .setting-row select { width: 100%; padding: 5px; border: 1px solid #ccc; border-radius: 3px; }
    
        /* カウントダウンモーダル */
    #countdown-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8);
      z-index: 9999;
      justify-content: center;
      align-items: center;
      color: white;
      font-weight: bold;
      pointer-events: none;
    }
        #countdown-text {
      font-size: 15vw; /* 画面幅に合わせる */
      white-space: nowrap; /* 絶対に折り返さない */
      text-shadow: 0 0 20px rgba(255,255,255,0.5);
      transition: all 0.2s;
      text-align: center;
      width: 100%;
    }
    /* 準備完了ランプ */
    .ready-area { display: flex; gap: 8px; align-items: center; justify-content: center; margin: 4px 0; }
    .ready-lamp { width: 12px; height: 12px; border-radius: 50%; background: #ccc; border: 1px solid #999; }
    .ready-lamp.on { background: #4caf50; box-shadow: 0 0 8px #4caf50; border-color: #fff; }
  </style>
</head>
<body>
<div id="countdown-overlay"><div id="countdown-text">5</div></div>
<h1>遠タメ将棋 Online</h1>

<div class="controls">
  <div style="font-size:10px; margin-bottom:2px; width:100%; text-align:center;">
    <button id="btnSetting">設定</button>

<div id="setting-dialog">
  <h3 style="margin-top:0; border-bottom:1px solid #eee; padding-bottom:10px;">対局設定</h3>
  
  <div class="setting-row">
    <label>持ち時間</label>
    <select id="cfgMain">
      <option value="0">0分（即秒読み）</option>
      <option value="10" selected>10分</option>
      <option value="15">15分</option>
      <option value="30">30分</option>
      <option value="999999">無制限</option>
    </select>
  </div>

  <div class="setting-row">
    <label>秒読み</label>
    <select id="cfgByo">
      <option value="30" selected>30秒</option>
      <option value="60">60秒</option>
      <option value="999999">無制限</option>
    </select>
  </div>

  <div class="setting-row">
    <label>手合割（駒落ち）</label>
    <select id="cfgHandicap">
      <option value="平手">平手</option>
      <option value="香落ち">香落ち (上手：左香)</option>
      <option value="角落ち">角落ち</option>
      <option value="飛車落ち">飛車落ち</option>
      <option value="飛香落ち">飛香落ち</option>
      <option value="二枚落ち">二枚落ち (飛角)</option>
      <option value="四枚落ち">四枚落ち (飛角香香)</option>
      <option value="六枚落ち">六枚落ち (＋桂桂)</option>
      <option value="八枚落ち">八枚落ち (＋銀銀)</option>
    </select>
  </div>
  <div class="setting-row">
    <label>上手（駒を落とす側）</label>
    <select id="cfgUwateSide">
      <option value="G">後手△が上手</option>
      <option value="S">先手▲が上手</option>
    </select>
  </div>
  <div style="display:flex; gap:10px;">
    <button id="btnSettingSave" style="flex:1; background:var(--call-btn); color:white; padding:10px;">適用して初期化</button>
    <button id="btnSettingCancel" style="flex:1; background:#ccc; padding:10px;">閉じる</button>
  </div>
</div>

<div id="setting-dialog">
  <h3 style="margin-top:0; border-bottom:1px solid #eee; padding-bottom:10px;">対局設定</h3>
  <div class="setting-row">
    <label>手合割（駒落ち）</label>
    <select id="cfgHandicap">
      <option value="平手">平手</option>
      <option value="香落ち">香落ち (上手：左香)</option>
      <option value="角落ち">角落ち</option>
      <option value="飛車落ち">飛車落ち</option>
      <option value="飛香落ち">飛香落ち</option>
      <option value="二枚落ち">二枚落ち (飛角)</option>
      <option value="四枚落ち">四枚落ち (飛角香香)</option>
      <option value="六枚落ち">六枚落ち (＋桂桂)</option>
      <option value="八枚落ち">八枚落ち (＋銀銀)</option>
    </select>
  </div>
  <div class="setting-row">
    <label>上手（駒を落とす側）</label>
    <select id="cfgUwateSide">
      <option value="G">後手△が上手</option>
      <option value="S">先手▲が上手</option>
    </select>
  </div>
  <div style="display:flex; gap:10px;">
    <button id="btnSettingSave" style="flex:1; background:var(--call-btn); color:white; padding:10px;">適用して初期化</button>
    <button id="btnSettingCancel" style="flex:1; background:#ccc; padding:10px;">閉じる</button>
  </div>
</div>

    <button id="btnFlip">反転</button>
    <button id="btnToggleReview" disabled>感想戦</button>
        <button id="btnResign">投了</button>
  </div>
  <div class="ready-area">
    <select id="mySideSelect" style="font-size:10px;"><option value="S">先手▲</option><option value="G">後手△</option></select>
    <button id="btnReady" style="background: #ff9800; color: white; padding: 4px 8px;">対局準備完了</button>
    <div style="display: flex; gap: 4px; font-size: 10px; align-items: center; margin-left:5px;">
      ▲<div id="lamp-S" class="ready-lamp"></div>
      △<div id="lamp-G" class="ready-lamp"></div>
    </div>
  </div>
  <div id="status-txt" style="font-size:11px; font-weight:bold; margin-left:10px;">接続待ち...</div>
</div>

<div class="call-area">
  <button id="btnCallStart">通話開始</button>
  <button id="btnMute" disabled>ミュート</button>
  <button id="btnCallEnd" disabled>通話終了</button>
  <div class="vol-ctrl">
    音量:<input type="range" id="volume-control" min="0" max="1" step="0.1" value="1" style="width:50px;">
  </div>
  <span id="callStatusDisplay">オフライン</span>
</div>

<div class="status-area">
  <div id="timer-S" class="timer">▲ --:--</div>
  <div id="timer-G" class="timer">△ --:--</div>
</div>

<div id="game-main">
  <div id="game-main-inner" style="display: flex; flex-direction: row; align-items: flex-start; gap: 2px;">
    <div class="hand" id="handG" data-label="△後手"></div>
    <div id="board-container">
      <div id="board"></div>
      <div id="promote-dialog">
        <div style="margin-bottom:15px; font-weight:bold; font-size:16px;">成りますか？</div>
        <div style="display: flex; gap: 15px; justify-content: center;">
          <button id="btn-prom-yes" style="background:var(--danger-btn); color:white; padding: 12px 20px; font-size: 16px;">成る</button>
          <button id="btn-prom-no" style="background:#757575; color:white; padding: 12px 20px; font-size: 16px;">不成</button>
        </div>
      </div>
    </div>
    <div class="hand" id="handS" data-label="▲先手"></div>
  </div>

  <div id="review-panel">
    <div id="nav-pos">0/0</div>
    <div id="kifu-container" class="kifu-list"></div>
    <div class="nav-controls">
      <button id="nav-prev" class="nav-btn">＜ 前</button>
      <button id="nav-next" class="nav-btn">次 ＞</button>
      <button id="nav-first" class="nav-btn">《 最初</button>
      <button id="nav-last" class="nav-btn">最後 》</button>
      <button id="btnKif" class="nav-btn" style="grid-column: span 2; background: #4caf50; color: white;">KIF</button>
    </div>
  </div>
</div>

<div id="chat-container" style="width: 95%; max-width: 500px; margin: 10px auto; background: #fff; border: 1px solid #ccc; border-radius: 5px; box-sizing: border-box;">
  <div id="chatLog" style="height: 120px; overflow-y: auto; padding: 5px; background: #fafafa;"></div>
  <div style="display: flex; padding: 5px; gap: 5px;">
    <input type="text" id="chatInput" placeholder="メッセージを入力..." style="flex: 1; padding: 5px;">
    <button id="btnSend" style="background: var(--primary-btn); color: white;">送信</button>
    <button id="btnClearChat" style="background: var(--danger-btn); color: white;">削除</button>
  </div>
</div>

<audio id="remote-audio" autoplay></audio>
<audio id="localAudio" autoplay muted style="display:none;"></audio>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import { getDatabase, ref, set, onValue, push, remove, update, get } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

  const firebaseConfig = {
      ナイショ
  };
   // --- Firebase 初期化 ---
  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  
  // --- ルーム管理：ファイル名から部屋名を取得 ---
  const params = new URLSearchParams(window.location.search);
  
  // URLからファイル名を取得（例: /Room999.html -> Room999）
  const fileName = window.location.pathname.split("/").pop().split(".")[0];
  
  let roomName = params.get('room') || fileName || "default_room";

   // URLの書き換え処理を無効化
  /* if (!params.get('room')) {
      const newUrl = window.location.protocol + "//" + window.location.host + window.location.pathname + `?room=${roomName}`;
      window.history.pushState({ path: newUrl }, '', newUrl);
  }
  */

  // --- 各データへの参照定義 ---
  const gameRef = ref(db, `${roomName}/shogiData`);
  const reviewRef = ref(db, `${roomName}/reviewData`);
  const callStatusRef = ref(db, `${roomName}/callStatus`);
    const signalingRef = ref(db, `${roomName}/signaling`);
  const readyRef = ref(db, `${roomName}/readyStatus`); // 追加

  let isCountingDown = false; // 追加：カウントダウン中フラグ

  const SYMBOLS = {FU:'歩',KY:'香',KE:'桂',GI:'銀',KI:'金',KA:'角',HI:'飛',OU:'玉',TO:'と',NY:'杏',NK:'圭',NG:'全',UM:'馬',RY:'龍'};

  const PROMOTE_MAP = {FU:'TO',KY:'NY',KE:'NK',GI:'NG',KA:'UM',HI:'RY'};
  const UNPROMOTE_MAP = {TO:'FU',NY:'KY',NK:'KE',NG:'GI',UM:'KA',RY:'HI'};
  const KANJI_NUM = ["","一","二","三","四","五","六","七","八","九"];
  const ZEN_NUM = ["","１","２","３","４","５","６","７","８","９"];

  let state = { board: "[]", handS: [], handG: [], turn: 'S', timers: {S: 600, G: 600}, config: {main: 600, byo: 30}, lastTick: 0, history: [], winner: null, winReason: "" };
  let sel = null, selH = null, possibleMoves = [], pendingProm = null;
  let isReviewMode = sessionStorage.getItem(`isReview_${roomName}`) === "true";
  let viewIdx = -1, rvState = null;
  const boardEl = document.getElementById('board'); 

   let mySide = sessionStorage.getItem(`mySide_${roomName}`) || 'S';
  const mySideSelect = document.getElementById('mySideSelect');
  mySideSelect.value = mySide;

  // --- 盤面と駒台の配置をまるごと入れ替える関数 ---
  function updateDisplayRotation(isFlipped) {
  const container = document.getElementById('game-main-inner');
  const board = document.getElementById('board');
  const handS = document.getElementById('handS');
  const handG = document.getElementById('handG');

  // いったん左右の回転状態をリセット
  handS.classList.remove('left-rotated');
  handG.classList.remove('left-rotated');

  if (isFlipped) {
    // 後手視点
    container.insertBefore(handS, container.firstChild); // 左
    container.appendChild(handG);                         // 右
    board.style.transform = 'rotate(180deg)';

    // ★左側（handS）を上下反転
    handS.classList.add('left-rotated');
  } else {
    // 先手視点
    container.insertBefore(handG, container.firstChild); // 左
    container.appendChild(handS);                         // 右
    board.style.transform = 'rotate(0deg)';

    // ★左側（handG）を上下反転
    handG.classList.add('left-rotated');
  }
}

  // 初回表示の適用
  let currentFlip = (mySide === 'G');
  updateDisplayRotation(currentFlip);

    mySideSelect.onchange = (e) => { 
    mySide = e.target.value; 
    sessionStorage.setItem(`mySide_${roomName}`, mySide);
    // リロードせず、表示状態だけを更新する
    currentFlip = (mySide === 'G');
    updateDisplayRotation(currentFlip);
    render(); 
  };

  // 反転ボタン（一番下のコードも書き換えます）
  document.getElementById('btnFlip').onclick = () => {
    currentFlip = !currentFlip;
    updateDisplayRotation(currentFlip);
  };

  // --- 通話維持用（バックグラウンド対策強化版） ---
  let wakeLock = null;
  let silenceAudio = null;
  let audioCtx = null;
  const silenceData = "data:audio/wav;base64,UklGRigAAABXQVZFRm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==";

  async function startKeepAlive() {
    try {
      if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen');
      
      if (!silenceAudio) { 
        silenceAudio = new Audio(silenceData); 
        silenceAudio.loop = true; 
        silenceAudio.volume = 0.01; 
      }
      await silenceAudio.play();

      if (!audioCtx) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
        const buffer = audioCtx.createBuffer(1, 1, 22050);
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        source.connect(audioCtx.destination);
        source.start();
        audioCtx.onstatechange = () => {
          if (audioCtx.state === 'suspended' && localCallStartPressed) audioCtx.resume();
        };
      }
      if (audioCtx.state === 'suspended') await audioCtx.resume();
    } catch (err) { console.warn("Keep-alive Error:", err); }
  }

  function stopKeepAlive() {
    if (wakeLock) { try { wakeLock.release(); } catch(e){} wakeLock = null; }
    if (silenceAudio) { silenceAudio.pause(); }
    if (audioCtx) { try { audioCtx.close(); } catch(e){} audioCtx = null; }
  }

  document.addEventListener('visibilitychange', async () => {
    if (document.visibilityState === 'visible' && localCallStartPressed) {
      if ('wakeLock' in navigator && !wakeLock) {
        try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e){}
      }
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    }
  });

  // --- WebRTC / 通話機能（ICE Restart統合） ---
  let localStream = null, peerConnection = null, localCallStartPressed = false, isMuted = false;
  const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
  const btnCallStart = document.getElementById('btnCallStart'), btnCallEnd = document.getElementById('btnCallEnd'), btnMute = document.getElementById('btnMute'), callStatusDisplay = document.getElementById('callStatusDisplay'), volumeControl = document.getElementById('volume-control');

  volumeControl.addEventListener('input', () => { const ra = document.getElementById('remote-audio'); if (ra) ra.volume = parseFloat(volumeControl.value); });
  btnMute.onclick = () => { if (!localStream) return; isMuted = !isMuted; localStream.getAudioTracks().forEach(t => t.enabled = !isMuted); btnMute.textContent = isMuted ? '解除' : 'ミュート'; btnMute.style.background = isMuted ? "var(--danger-btn)" : "#757575"; };

  async function startLocalStream() { 
    if (localStream) localStream.getTracks().forEach(t => t.stop()); 
    localStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }, video: false }); 
    return localStream; 
  }

  function createPeerConnection() {
    if (peerConnection && peerConnection.signalingState !== 'closed') return;
    peerConnection = new RTCPeerConnection(configuration);
    
    // ICE接続状態の監視（自動再接続用）
    peerConnection.oniceconnectionstatechange = () => {
      const state = peerConnection.iceConnectionState;
      console.log("ICE Connection:", state);
      if (state === "failed" || state === "disconnected") handleIceRestart();
    };

    peerConnection.ontrack = e => { const ra = document.getElementById('remote-audio'); if (ra) ra.srcObject = e.streams[0]; };
    if (localStream) localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
    peerConnection.onicecandidate = e => { if (e.candidate) push(ref(db, `${roomName}/signaling/candidates/${mySide}`), { candidate: e.candidate.toJSON() }); };
  }

  async function sendOffer() { 
    createPeerConnection(); 
    const offer = await peerConnection.createOffer(); 
    await peerConnection.setLocalDescription(offer); 
    await set(ref(db, `${roomName}/signaling/offer`), { sdp: offer.sdp, type: offer.type, from: mySide }); 
  }

  async function sendAnswer() { 
    const snap = await get(ref(db, `${roomName}/signaling/offer`)); 
    if (!snap.exists()) return; 
    const offer = snap.val(); 
    createPeerConnection(); 
    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer)); 
    const answer = await peerConnection.createAnswer(); 
    await peerConnection.setLocalDescription(answer); 
    await set(ref(db, `${roomName}/signaling/answer`), { sdp: answer.sdp, type: answer.type, from: mySide }); 
  }

  async function handleIceRestart() {
    if (!peerConnection || peerConnection.signalingState === 'closed') return;
    try {
      const offer = await peerConnection.createOffer({ iceRestart: true });
      await peerConnection.setLocalDescription(offer);
      await set(ref(db, `${roomName}/signaling/offer`), { sdp: offer.sdp, type: offer.type, from: mySide, isRestart: true });
    } catch (e) { console.error("Restart ICE failed:", e); }
  }

  // 修正後
btnCallStart.onclick = async () => { 
  if (localCallStartPressed) return; // 二重押し防止
  try { 
    await startKeepAlive(); 
    await startLocalStream(); 
    
    // 1. まず「自分が押した」という状態を確定させる
    localCallStartPressed = true; 
    updateCallUI(); 

    const snap = await get(callStatusRef); 
    let callData = snap.exists() ? snap.val() : { status: 'none', users: { S: false, G: false } }; 
    if (!callData.users) callData.users = { S: false, G: false }; 
    
    // 2. 自分のサイドのフラグだけを立ててFirebaseを更新
    callData.users[mySide] = true; 
    let newStatus = (callData.users.S && callData.users.G) ? 'started' : 'waiting'; 
    if (newStatus === 'started') await sendOffer(); 

    await update(callStatusRef, { status: newStatus, users: callData.users, timestamp: new Date().toISOString() }); 
  } catch (e) { 
    // エラー時はボタンを再度押せるように戻す
    localCallStartPressed = false; 
    updateCallUI(); 
    stopKeepAlive(); 
  } 
};

  btnCallEnd.onclick = async () => { 
    await update(callStatusRef, { status: 'ended', users: { S: false, G: false } }); 
    handleCallEndInternal(); 
  };

  function handleCallEndInternal() { 
    localCallStartPressed = false; 
    stopKeepAlive(); 
    if (peerConnection) { peerConnection.close(); peerConnection = null; } 
    if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; } 
    remove(signalingRef); 
    updateCallUI(); 
    if (!sessionStorage.getItem(`reloaded_${roomName}`)) { 
      sessionStorage.setItem(`reloaded_${roomName}`, '1'); 
      window.location.reload(); 
    } 
  }

  function updateCallUI() { 
  // localCallStartPressed が true（＝自分が開始済み）なら
  // 「通話開始」ボタンを無効にし、「終了」「ミュート」を有効にする
  btnCallStart.disabled = localCallStartPressed; 
  btnCallEnd.disabled = !localCallStartPressed; 
  btnMute.disabled = !localCallStartPressed; 
}

  // 修正後
onValue(callStatusRef, (snap) => { 
  const data = snap.val(); 
  if (!data) return; 
  
  if (data.status === 'ended' && localCallStartPressed) { 
    handleCallEndInternal(); 
    return; 
  } 
  
  // 修正の要：Firebase上で「自分が」登録されているかだけを厳密にチェック
  const iAmRegisteredOnFirebase = !!(data.users && data.users[mySide]);
  
  // 自分がボタンを押した、あるいはFirebase上で既に自分が通話参加中なら
  // ローカルのフラグをtrueに固定する（これでボタンが無効化される）
  if (iAmRegisteredOnFirebase) {
    localCallStartPressed = true;
  }

  updateCallUI(); 
  
  // ステータス表示の切り分け
  if (data.status === 'started') {
    callStatusDisplay.textContent = "通話中"; 
  } else if (data.status === 'waiting') { 
    // 自分が押している場合は「待機中」、押していない場合は「着信中」として表示
    callStatusDisplay.textContent = localCallStartPressed ? "相手の応答待ち..." : "相手が通話を呼んでいます"; 
  } else { 
    callStatusDisplay.textContent = "オフライン"; 
  } 
});

  onValue(ref(db, `${roomName}/signaling/offer`), snap => { const offer = snap.val(); if (offer && offer.from !== mySide) sendAnswer(); });
  onValue(ref(db, `${roomName}/signaling/answer`), async snap => { const answer = snap.val(); if (answer && answer.from !== mySide && peerConnection) await peerConnection.setRemoteDescription(new RTCSessionDescription(answer)); });
  onValue(ref(db, `${roomName}/signaling/candidates/S`), snap => { if (mySide === 'G' && peerConnection && snap.exists()) Object.values(snap.val()).forEach(d => peerConnection.addIceCandidate(new RTCIceCandidate(d.candidate))); });
  onValue(ref(db, `${roomName}/signaling/candidates/G`), snap => { if (mySide === 'S' && peerConnection && snap.exists()) Object.values(snap.val()).forEach(d => peerConnection.addIceCandidate(new RTCIceCandidate(d.candidate))); });

  // --- Firebase 将棋データ監視 ---
  onValue(gameRef, (snap) => {
    const data = snap.val();
    if (!data) return;
    if (!data.winner) {
        isReviewMode = false;
        sessionStorage.setItem(`isReview_${roomName}`, "false");
        document.getElementById('btnToggleReview').textContent = "感想戦";
        document.getElementById('review-panel').style.display = 'none';
        document.getElementById('btnToggleReview').disabled = true;
    } else {
        document.getElementById('btnToggleReview').disabled = false;
    }
    state.board = JSON.parse(data.board);
    state.handS = data.handS || [];
    state.handG = data.handG || [];
    state.turn = data.turn || 'S';
    state.timers = data.timers || {S:600, G:600};
    state.config = data.config || {main:600, byo:30};
    state.lastTick = data.lastTick || 0;
    state.winner = data.winner || null;
    state.winReason = data.winReason || "";
    state.history = data.history || [];
    if (state.winner) showGameOverPopup(state.winner, state.winReason || "");
    if (!isReviewMode) { 
        viewIdx = state.history.length - 1; 
        syncReviewStateLocally(); 
    }
    render(); 
    updateKifuList();
    updateTimerDisplay(); // データを取得した直後に表示を更新
  });
  
    // --- 準備完了ステータスの監視 ---
  const btnReady = document.getElementById('btnReady');
  btnReady.onclick = async () => {
    const snap = await get(readyRef);
    let readyData = snap.exists() ? snap.val() : { S: false, G: false };
    readyData[mySide] = !readyData[mySide];
    await set(readyRef, readyData);
  };

  onValue(readyRef, (snap) => {
    const data = snap.val() || { S: false, G: false };
    document.getElementById('lamp-S').className = `ready-lamp ${data.S ? 'on' : ''}`;
    document.getElementById('lamp-G').className = `ready-lamp ${data.G ? 'on' : ''}`;
        // 対局中（lastTickが0以外）はボタンを無効化
    if (state.lastTick !== 0 && !state.winner) {
      btnReady.disabled = true;
      btnReady.textContent = "対局中";
      btnReady.style.background = "#607d8b";
    } else {
      btnReady.disabled = false;
      btnReady.textContent = data[mySide] ? "準備解除" : "対局準備完了";
      btnReady.style.background = data[mySide] ? "#757575" : "#ff9800";
    }

    // 両者が準備完了し、まだ対局が始まっていない場合にカウントダウン開始
    if (data.S && data.G && state.lastTick === 0 && !state.winner && !isCountingDown) {
      startCountdown();
    }
  });

    async function startCountdown() {
    if (isCountingDown) return; // 二重起動防止
    isCountingDown = true;
    const overlay = document.getElementById('countdown-overlay');
    const text = document.getElementById('countdown-text');
    overlay.style.display = 'flex';
    
    for (let i = 5; i >= 0; i--) {
      text.textContent = i === 0 ? "対局開始！" : i;
      text.style.transform = "scale(1.1)";
      await new Promise(r => setTimeout(r, 1000));
      text.style.transform = "scale(1.0)";
    }
    
    overlay.style.display = 'none';

    // ★修正：どちらの端末でも対局開始を確定できるようにする
    // lastTick が 0 のときだけ開始処理を行う（二重開始防止）
    const snap = await get(gameRef);
    const cur = snap.exists() ? snap.val() : null;
    if (cur && cur.lastTick === 0) {
      const now = Date.now();
      await update(gameRef, { 
        lastTick: now,
        updatedAt: now 
      });
      await set(readyRef, { S: false, G: false });
    }
    
    // フラグのリセットを少し遅らせて連打を防止
    setTimeout(() => { isCountingDown = false; }, 2000);
  }

  onValue(reviewRef, (snap) => {
    if (!isReviewMode) return;
    const data = snap.val();
    if (data) {
        viewIdx = data.viewIdx;
        rvState = { board: JSON.parse(data.board), handS: data.handS || [], handG: data.handG || [] };
        render();
        updateKifuList();
    }
  });
  
  // --- チャット機能の追加 ---
  const chatLog = document.getElementById('chatLog');
  const chatInput = document.getElementById('chatInput');
  const btnSend = document.getElementById('btnSend');
  const btnClearChat = document.getElementById('btnClearChat'); // 消去ボタンを取得

  // 送信処理
  btnSend.onclick = async () => {
    const text = chatInput.value.trim();
    if (!text) return;
    const snap = await get(ref(db, `${roomName}/chatLog`));
    const logs = snap.val() || [];
    const senderName = (mySide === 'S') ? "先手" : "後手";
    logs.push({ 
      user: mySide, 
      name: senderName, 
      text: text, 
      time: new Date().toISOString() 
    });
    await set(ref(db, `${roomName}/chatLog`), logs);
    chatInput.value = '';
  };

  // チャット履歴の全削除（Firebase上のデータを消去）
  btnClearChat.onclick = async () => {
    if (confirm("チャットの履歴をすべて削除してもよろしいですか？")) {
      await remove(ref(db, `${roomName}/chatLog`));
    }
  };

  // エンターキー送信対応
  chatInput.onkeydown = (e) => { if(e.key === 'Enter') btnSend.click(); };

  // ログの監視と表示
  onValue(ref(db, `${roomName}/chatLog`), (snap) => {
    const logs = snap.val() || [];
    chatLog.innerHTML = '';
    logs.slice(-50).forEach(msg => {
      const div = document.createElement('div');
      div.className = 'chat-message';
      div.innerHTML = `<span class="chat-name ${msg.user}">${msg.name}:</span><span>${msg.text}</span>`;
      chatLog.appendChild(div);
    });
    chatLog.scrollTop = chatLog.scrollHeight;
  });

  // --- 将棋 UI / ロジック ---
  function setReviewMode(bool) {
    isReviewMode = bool;
    sessionStorage.setItem(`isReview_${roomName}`, bool.toString());
    document.getElementById('btnToggleReview').textContent = bool ? "戻る" : "感想戦";
    document.getElementById('review-panel').style.display = bool ? 'flex' : 'none';
    if (bool) pushReviewUpdate();
  }

  const cells = [];
  for (let y = 0; y < 9; y++) {
    cells[y] = [];
    for (let x = 0; x < 9; x++) {
      const c = document.createElement('div');
      c.className = 'cell';
      c.onclick = () => handleCellClick(x, y);
      boardEl.appendChild(c);
      cells[y][x] = c;
    }
  }

  function pushReviewUpdate() {
    if (!isReviewMode) return;
    set(reviewRef, { viewIdx: viewIdx, board: JSON.stringify(rvState.board), handS: rvState.handS || [], handG: rvState.handG || [], timestamp: Date.now() });
  }

    function finish(moveData) {
    const now = Date.now();
    if (state.lastTick !== 0 && state.timers[state.turn] < 900000) { // 持ち時間が無制限(999999)でない場合のみ減らす
      const elapsed = Math.floor((now - state.lastTick) / 1000);
      state.timers[state.turn] = Math.max(0, state.timers[state.turn] - elapsed);
    }
    // 指した瞬間に lastTick を現在のサーバー時刻に更新（次の手番の計測開始）
    state.lastTick = now;
    let foulReason = "";
    if (isChecked(state.board, state.turn)) { foulReason = "王手放置"; }
    else if (moveData.isDrop && moveData.type === 'FU') {
      let count = 0;
      for (let y = 0; y < 9; y++) if (state.board[y][moveData.toX]?.type === 'FU' && state.board[y][moveData.toX]?.owner === state.turn) count++;
      if (count > 1) foulReason = "二歩";
    }
    if (foulReason) {
      state.winner = (state.turn === 'S' ? 'G' : 'S');
      state.winReason = foulReason;
      state.history.push({ ...moveData, board: JSON.stringify(state.board), handS: [...(state.handS || [])], handG: [...(state.handG || [])], type: moveData.type + "(反則)" });
    } else {
      const nextTurn = (state.turn === 'S' ? 'G' : 'S');
      if (state.history.length > 2 && isCheckmate(state.board, nextTurn, state.handS, state.handG)) { state.winner = state.turn; state.winReason = "詰み"; }
      state.turn = nextTurn;
      state.history.push({ ...moveData, board: JSON.stringify(state.board), handS: [...(state.handS || [])], handG: [...(state.handG || [])] });
    }
    sel = null; selH = null; possibleMoves = [];
        sel = null; selH = null; possibleMoves = [];
    // updateを使用し、タイムスタンプを付与することで同期の確実性を高めます
    update(gameRef, { 
      board: JSON.stringify(state.board), 
      handS: state.handS || [], 
      handG: state.handG || [], 
      turn: state.turn, 
      timers: state.timers, 
      config: state.config, 
      lastTick: state.lastTick, 
      winner: state.winner || null, 
      winReason: state.winReason || "", 
      history: state.history,
      updatedAt: Date.now() // 更新時間を混ぜることで強制的に同期を走らせる
    });
  }

  const isChecked = (board, owner) => {
    let kx = -1, ky = -1;
    for(let y=0; y<9; y++) for(let x=0; x<9; x++) if(board[y][x]?.type==='OU' && board[y][x]?.owner===owner) { kx=x; ky=y; break; }
    if (kx === -1) return false;
    const enemy = (owner === 'S' ? 'G' : 'S');
    for(let y=0; y<9; y++) for(let x=0; x<9; x++) if(board[y][x]?.owner === enemy) if(getRawMoves(x, y, board, enemy).some(m => m.x===kx && m.y===ky)) return true;
    return false;
  };

  function showGameOverPopup(winner, reason = "") {
    const key = `shown_${roomName}_${state.history.length}`;
    if (sessionStorage.getItem(key)) return;
    sessionStorage.setItem(key, "true");
    setReviewMode(true);
    syncReviewStateLocally(); 
    pushReviewUpdate();
    setTimeout(() => { alert((reason ? `${reason}により、` : "") + (winner === 'S' ? '先手▲' : '後手△') + "の勝ちです！"); }, 200);
  }

    // --- 駒落ち用初期配置生成関数 ---
  function generateInitialBoard(handicapType, uwateSide) {
    const board = Array(9).fill(null).map(() => Array(9).fill(null));
    const setup = (y, o, ps) => ps.forEach((p, x) => { if (p) board[y][x] = { type: p, owner: o } });
    // 平手配置
    setup(0, 'G', ['KY','KE','GI','KI','OU','KI','GI','KE','KY']);
    board[1][1] = { type: 'HI', owner: 'G' }; board[1][7] = { type: 'KA', owner: 'G' };
    setup(2, 'G', Array(9).fill('FU'));
    setup(6, 'S', Array(9).fill('FU'));
    board[7][1] = { type: 'KA', owner: 'S' }; board[7][7] = { type: 'HI', owner: 'S' };
    setup(8, 'S', ['KY','KE','GI','KI','OU','KI','GI','KE','KY']);

    // 駒落ち適用
    const isUwateG = (uwateSide === 'G');
    const uY0 = isUwateG ? 0 : 8; const uY1 = isUwateG ? 1 : 7;
    const del = (y, x) => { board[y][x] = null; };
    
    if(handicapType === "香落ち") del(uY0, isUwateG ? 0 : 8);
    else if(handicapType === "角落ち") del(uY1, isUwateG ? 7 : 1);
    else if(handicapType === "飛車落ち") del(uY1, isUwateG ? 1 : 7);
    else if(handicapType === "飛香落ち") { del(uY1, isUwateG ? 1 : 7); del(uY0, isUwateG ? 0 : 8); }
    else if(handicapType === "二枚落ち") { del(uY1, 1); del(uY1, 7); }
    else if(handicapType === "四枚落ち") { del(uY1, 1); del(uY1, 7); del(uY0, 0); del(uY0, 8); }
    else if(handicapType === "六枚落ち") { del(uY1, 1); del(uY1, 7); del(uY0, 0); del(uY0, 8); del(uY0, 1); del(uY0, 7); }
    else if(handicapType === "八枚落ち") { del(uY1, 1); del(uY1, 7); del(uY0, 0); del(uY0, 8); del(uY0, 1); del(uY0, 7); del(uY0, 2); del(uY0, 6); }
    return board;
  }

  // 設定ダイアログの開閉
  document.getElementById('btnSetting').onclick = () => { document.getElementById('setting-dialog').style.display = 'block'; };
  document.getElementById('btnSettingCancel').onclick = () => { document.getElementById('setting-dialog').style.display = 'none'; };

    // 設定適用ボタン
  document.getElementById('btnSettingSave').onclick = () => {
    if(!confirm("設定を適用して初期化しますか？")) return;
    
    const hType = document.getElementById('cfgHandicap').value;
    const uSide = document.getElementById('cfgUwateSide').value;
    const mainMin = parseInt(document.getElementById('cfgMain').value) || 0;
    const byoSec = parseInt(document.getElementById('cfgByo').value) || 30;
    
    // 内部計算用に秒に変換
    const m = mainMin * 60;
    const b = byoSec;
    const bStr = JSON.stringify(generateInitialBoard(hType, uSide));

    set(gameRef, { 
      board: bStr, 
      handS: [], 
      handG: [], 
      turn: 'S', 
      timers: {S: m, G: m}, 
      config: {main: m, byo: b, handicap: hType}, 
      lastTick: 0, 
      winner: null, 
      winReason: "", 
      // 履歴の1手目にルール内容を明記
      history: [{ board: bStr, handS: [], handG: [], type: `${hType} (${mainMin}分/${byoSec}秒)` }] 
    });
    set(readyRef, { S: false, G: false }); // 準備状態もリセット

    document.getElementById('setting-dialog').style.display = 'none';
    
    // 感想戦モード等のリセット処理
    setReviewMode(false);
    remove(reviewRef);
    Object.keys(sessionStorage).forEach(k => { 
      if(k.startsWith("shown_") || k.startsWith("isReview_")) sessionStorage.removeItem(k); 
    });
  };
  
  function syncReviewStateLocally() { 
    if (viewIdx < 0 || viewIdx >= state.history.length) viewIdx = state.history.length - 1; 
    const hist = state.history[viewIdx]; 
    rvState = { board: JSON.parse(hist.board), handS: [...(hist.handS || [])], handG: [...(hist.handG || [])] }; 
    sel = null; selH = null; possibleMoves = []; 
  }

    function handleCellClick(x, y) {
    if (isReviewMode) {
      const target = rvState.board[y][x];
      if (sel && sel.x === x && sel.y === y) { sel = null; possibleMoves = []; render(); return; }
      if (sel && possibleMoves.some(m => m.x === x && m.y === y)) {
        const fromP = rvState.board[sel.y][sel.x];
        if (target && target.owner !== fromP.owner) (fromP.owner === 'S' ? rvState.handS : rvState.handG).push(UNPROMOTE_MAP[target.type] || target.type);
        rvState.board[y][x] = { type: fromP.type, owner: fromP.owner }; rvState.board[sel.y][sel.x] = null;
                const promLine = (fromP.owner === 'S') ? [0,1,2] : [6,7,8];
        // 移動データを一旦作成
        const moveData = { side: fromP.owner, fromX: sel.x, fromY: sel.y, toX: x, toY: y, type: fromP.type, isDrop: false, isPromoted: false };

        if (PROMOTE_MAP[fromP.type] && (promLine.includes(y) || promLine.includes(sel.y))) {
          // 感想戦でもダイアログを表示し、判定を endProm に委ねる
          pendingProm = { x, y, moveData };
          document.getElementById('promote-dialog').style.display = 'block';
          render();
        } else {
          sel = null; possibleMoves = []; 
          pushReviewUpdate();
          render(); 
        }
        return;
      }
      if (selH) { 
        if (!target) { 
            rvState.board[y][x] = { type: selH.type, owner: selH.owner }; 
            (selH.owner === 'S' ? rvState.handS : rvState.handG).splice(selH.idx, 1); 
            selH = null; pushReviewUpdate(); render(); 
        } else { selH = null; render(); } 
        return; 
      }
      if (target) { sel = { x, y }; possibleMoves = getRawMoves(x, y, rvState.board, target.owner); render(); }
      return;
    }

    // ★追加：対局開始（カウントダウン終了）前は駒を動かせない
    if (state.lastTick === 0) return;

    if (state.winner || state.turn !== mySide || pendingProm) return;
    const target = state.board[y][x];
    if (sel && sel.x === x && sel.y === y) { sel = null; possibleMoves = []; render(); return; }
    if (sel && possibleMoves.some(m => m.x === x && m.y === y)) {
      const fromP = state.board[sel.y][sel.x];
      if (target && target.owner !== mySide) { const h = (mySide === 'S' ? state.handS : state.handG) || []; h.push(UNPROMOTE_MAP[target.type] || target.type); if (mySide === 'S') state.handS = h; else state.handG = h; }
      const moveData = { side: mySide, fromX: sel.x, fromY: sel.y, toX: x, toY: y, type: fromP.type, isDrop: false, isPromoted: false };
      state.board[y][x] = { type: fromP.type, owner: mySide }; state.board[sel.y][sel.x] = null;
      const promLine = (mySide === 'S') ? [0,1,2] : [6,7,8];
      if (PROMOTE_MAP[fromP.type] && (promLine.includes(y) || promLine.includes(sel.y))) {
        const deadLine = (mySide === 'S') ? 0 : 8;
        if (((fromP.type === 'FU' || fromP.type === 'KY') && y === deadLine) || (fromP.type === 'KE' && (mySide==='S' ? y<=1 : y>=7))) { state.board[y][x].type = PROMOTE_MAP[fromP.type]; moveData.type = PROMOTE_MAP[fromP.type]; moveData.isPromoted = true; finish(moveData); } 
        else { pendingProm = { x, y, moveData }; document.getElementById('promote-dialog').style.display = 'block'; render(); }
      } else { finish(moveData); }
      return;
    }
    if (selH) { if (!target) { state.board[y][x] = { type: selH.type, owner: mySide }; (mySide === 'S' ? state.handS : state.handG).splice(selH.idx, 1); finish({ side: mySide, toX: x, toY: y, type: selH.type, isDrop: true }); } else { selH = null; render(); } return; }
    if (target && target.owner === mySide) { sel = { x, y }; possibleMoves = getRawMoves(x, y, state.board, mySide); render(); }
  }

    function render() {
    if (isReviewMode && !rvState) {
      if (state.history && state.history.length > 0) {
        syncReviewStateLocally();
      } else { return; }
    }

    let b, hs, hg;
    if (isReviewMode) { 
      b = rvState.board; hs = rvState.handS; hg = rvState.handG; 
    } else { 
      b = state.board; hs = state.handS; hg = state.handG; 
    }

        // 盤面の描画
    for (let y = 0; y < 9; y++) {
      for (let x = 0; x < 9; x++) {
        const c = cells[y][x]; 
        const p = b[y][x];
        c.className = `cell ${sel?.x===x && sel?.y===y ? 'selected' : ''}`;
        
        if (p) {
          // 盤面の描画（★従来どおり：所有者だけで向きを決める）
const isOpposite = (p.owner === 'G');   // 後手だけ逆さ
const promotedClass = UNPROMOTE_MAP[p.type] ? 'promoted' : '';
const rotClass = isOpposite ? 'opposite' : '';

c.innerHTML = `<div class="piece piece-font ${rotClass} ${promotedClass}">${SYMBOLS[p.type]}</div>`;
        } else {
          c.innerHTML = '';
        }
      }
    }

          const drawH = (id, list, owner) => {
      const el = document.getElementById(id);
      el.innerHTML = '';

      // 駒の並び順の優先度（数字が小さいほど上に表示）
      const HAND_ORDER = { HI: 1, KA: 2, KI: 3, GI: 4, KE: 5, KY: 6, FU: 7 };

      // 持ち駒をソート。originalIdxを保持してクリック時の整合性を保つ
      const sortedList = (list || []).map((type, idx) => ({ type, originalIdx: idx }))
        .sort((a, b) => (HAND_ORDER[a.type] || 99) - (HAND_ORDER[b.type] || 99));

      sortedList.forEach((item) => {
        const s = document.createElement('span');
        s.className = 'piece-font';
        s.textContent = SYMBOLS[item.type];

        // 選択ハイライトの判定（元の配列インデックスで比較）
        if (selH?.idx === item.originalIdx && selH?.owner === owner) {
          s.classList.add('selected-piece');
        }

                s.onclick = (e) => {
          e.stopPropagation();
          // ★修正：感想戦以外では、対局が始まっていない（準備中）の操作も禁止
          if (!isReviewMode) {
            if (state.lastTick === 0 || state.winner || state.turn !== mySide || owner !== mySide) return;
          }

          if (selH?.idx === item.originalIdx && selH?.owner === owner) {
            selH = null;
          } else {
            selH = { type: item.type, owner, idx: item.originalIdx };
            sel = null;
            possibleMoves = [];
          }
          render();
        };
        el.appendChild(s);
      });
    };

    drawH('handS', hs, 'S'); 
    drawH('handG', hg, 'G');

    const st = document.getElementById('status-txt');
    if (state.winner && !isReviewMode) { 
      st.textContent = `${state.winner === 'S' ? '先手' : '後手'}勝`; 
      st.style.color = "red"; 
    } else if (isReviewMode) { 
      st.textContent = "感想戦"; 
      st.style.color = "orange"; 
    } else { 
      st.textContent = state.turn === mySide ? "手番" : "待機"; 
      st.style.color = "black"; 
    }

    document.getElementById('nav-pos').textContent = `${viewIdx}/${state.history.length-1}`;
    document.getElementById('timer-S').className = `timer ${!isReviewMode && state.turn==='S'?'your-turn':''}`;
    document.getElementById('timer-G').className = `timer ${!isReviewMode && state.turn==='G'?'your-turn':''}`;
  }

  // 棋譜リストの更新
  function updateKifuList() {
    const container = document.getElementById('kifu-container'); 
    container.innerHTML = '';
    state.history.forEach((h, i) => {
      const div = document.createElement('div'); 
      div.className = `kifu-item ${isReviewMode && viewIdx === i ? 'active' : ''}`;
      div.textContent = formatKifuText(h, i);
      div.onclick = () => { 
        if (!isReviewMode) setReviewMode(true); 
        viewIdx = i; syncReviewStateLocally(); pushReviewUpdate(); render(); updateKifuList(); 
      };
      container.appendChild(div); 
      if (isReviewMode && viewIdx === i) div.scrollIntoView({ block: 'nearest' });
    });
  }

        // 棋譜リストの表示テキストを生成
    function formatKifuText(move, idx) {
    if (idx === 0) return "開始";
    if (!move) return `${idx}.不明`;
    const side = move.side === 'S' ? "▲" : "△";

    // 短縮表示：特殊な終了理由は最優先
    if (move.type.includes("投了")) return `${idx}.${side}投了`;
    if (move.type.includes("時間切れ")) return `${idx}.${side}切れ負`;
    if (move.type.includes("反則")) return `${idx}.${side}反則`;
    if (typeof move.toX !== 'number' || typeof move.toY !== 'number') return `${idx}.${side}中断`;

    const x = 9 - move.toX, y = KANJI_NUM[move.toY + 1];
    const isSame = (idx > 1 && move.toX === state.history[idx-1].toX && move.toY === state.history[idx-1].toY);
    
    let typeName = move.type.replace("(反則)","").replace("投了","").replace("時間切れ","");
    let type = SYMBOLS[typeName] || "？";
    if (move.isPromoted) type += "成"; 
    else if (move.isDrop) type += "打";
    
    return `${idx}.${side}${isSame ? "同" : x+y}${type}`;
  }

function updateTimerDisplay() {
  const now = Date.now();
  const elapsed = (state.lastTick === 0 || isReviewMode || state.winner) ? 0 : Math.floor((now - state.lastTick) / 1000);

  ['S', 'G'].forEach(s => {
    let remMain = state.timers[s]; 
    let displayStr = ""; 
    let isByoAlert = false; 
    const el = document.getElementById(`timer-${s}`);
    const mark = (s === 'S' ? '▲' : '△');

    // 無制限判定用フラグ
    const isMainInf = (remMain > 900000);
    const isByoInf = (state.config.byo > 900000);

    if (state.turn === s && !state.winner && !isReviewMode && state.lastTick !== 0) {
      // 手番側の表示
      if (isMainInf) {
        displayStr = `${mark} 無制限`;
      } else if (remMain > 0) {
        const currentRem = Math.max(0, remMain - elapsed);
        if (currentRem > 0) {
          displayStr = `${mark} ${Math.floor(currentRem/60)}:${(currentRem%60).toString().padStart(2,'0')}`;
        } else {
          // 持ち時間使い切り後の秒読み
          if (isByoInf) {
            displayStr = `${mark} 秒:無制限`;
          } else {
            const byoRem = Math.max(0, (state.config.byo || 30) - (elapsed - remMain));
            displayStr = `${mark} 秒:${byoRem}`;
            if (byoRem <= 5) isByoAlert = true;
            if (byoRem <= 0 && s === mySide && !state.winner) {
              state.winner = (mySide === 'S' ? 'G' : 'S'); 
              state.winReason = "時間切れ"; 
              finish({ side: s, type: "時間切れ" }); 
            }
          }
        }
      } else {
        // 持ち時間0分設定（即秒読み）
        if (isByoInf) {
          displayStr = `${mark} 秒:無制限`;
        } else {
          const byoRem = Math.max(0, (state.config.byo || 30) - elapsed);
          displayStr = `${mark} 秒:${byoRem}`;
          if (byoRem <= 5) isByoAlert = true;
          if (byoRem <= 0 && s === mySide && !state.winner) {
            state.winner = (mySide === 'S' ? 'G' : 'S'); 
            state.winReason = "時間切れ"; 
            finish({ side: s, type: "時間切れ" });
          }
        }
      }
    } else {
      // 待機側や終了後の表示
      if (isMainInf) {
        displayStr = `${mark} 無制限`;
      } else if (remMain > 0) {
        displayStr = `${mark} ${Math.floor(remMain/60)}:${(remMain%60).toString().padStart(2,'0')}`;
      } else {
        displayStr = `${mark} 秒:${isByoInf ? '無制限' : (state.config.byo || 30)}`;
      }
    }
    
    el.textContent = displayStr; 
    if (isByoAlert) el.classList.add('timer-alert'); 
    else el.classList.remove('timer-alert');
  });
}

  setInterval(updateTimerDisplay, 1000);

  document.getElementById('btnToggleReview').onclick = () => { setReviewMode(!isReviewMode); if(isReviewMode) { syncReviewStateLocally(); pushReviewUpdate(); } render(); updateKifuList(); };
  document.getElementById('nav-prev').onclick = () => { if (viewIdx > 0) { viewIdx--; syncReviewStateLocally(); pushReviewUpdate(); render(); updateKifuList(); } };
  document.getElementById('nav-next').onclick = () => { if (viewIdx < state.history.length - 1) { viewIdx++; syncReviewStateLocally(); pushReviewUpdate(); render(); updateKifuList(); } };
  document.getElementById('nav-first').onclick = () => { if (isReviewMode) { viewIdx = 0; syncReviewStateLocally(); pushReviewUpdate(); render(); updateKifuList(); } };
  document.getElementById('nav-last').onclick = () => { if (isReviewMode) { viewIdx = state.history.length - 1; syncReviewStateLocally(); pushReviewUpdate(); render(); updateKifuList(); } };
    document.getElementById('btn-prom-yes').onclick = () => { 
    pendingProm.moveData.type = PROMOTE_MAP[pendingProm.moveData.type]; 
    pendingProm.moveData.isPromoted = true; 
    // ※ state.board への直接代入を削除（endProm内でモード別に処理するため）
    endProm(); 
  };
  document.getElementById('btn-prom-no').onclick = () => endProm();
    function endProm() { 
    const d = pendingProm.moveData; 
    const tx = pendingProm.x;
    const ty = pendingProm.y;

    if (isReviewMode) {
      // 感想戦モードの場合はローカルの検討状態(rvState)を更新
      rvState.board[ty][tx].type = d.type;
      sel = null; 
      possibleMoves = [];
      pushReviewUpdate();
    } else {
      // 対局モードの場合は通常通りFirebaseへ送信
      state.board[ty][tx].type = d.type;
      finish(d); 
    }

    pendingProm = null; 
    document.getElementById('promote-dialog').style.display = 'none'; 
    render(); 
  }

  const getRawMoves = (x, y, board, owner) => {
    const moves = []; const p = board[y][x]; if (!p) return moves; const f = (owner === 'S' ? -1 : 1);
    const add = (tx, ty) => { if (tx>=0 && tx<9 && ty>=0 && ty<9 && board[ty][tx]?.owner !== owner) moves.push({x:tx, y:ty}); };
    const slide = (vx, vy) => { let tx = x + vx, ty = y + vy; while (tx>=0 && tx<9 && ty>=0 && ty<9) { if (board[ty][tx]) { if (board[ty][tx].owner !== owner) moves.push({x:tx, y:ty}); break; } moves.push({x:tx, y:ty}); tx += vx; ty += vy; } };
    const t = p.type;
    if (['KI','TO','NY','NK','NG'].includes(t)) [[-1,f],[0,f],[1,f],[-1,0],[1,0],[0,-f]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='FU') add(x, y+f); else if (t==='KY') slide(0, f); else if (t==='KE') { add(x-1,y+f*2); add(x+1,y+f*2); }
    else if (t==='GI') [[-1,f],[0,f],[1,f],[-1,-f],[1,-f]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='KA') [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>slide(vx,vy));
    else if (t==='HI') [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>slide(vx,vy));
    else if (t==='OU') [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='UM') { [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>slide(vx,vy)); [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>add(x+vx,y+vy)); }
    else if (t==='RY') { [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>slide(vx,vy)); [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>add(x+vx,y+vy)); }
    return moves;
  };
  document.getElementById('btnResign').onclick = () => { if (state.winner || state.turn !== mySide) return; if (confirm("投了しますか？")) { state.winner = (mySide === 'S' ? 'G' : 'S'); state.winReason = "投了"; finish({ side: mySide, type: "投了" }); } };
      document.getElementById('btnKif').onclick = () => {
    let kif = "# KIF形式棋譜ファイル\n手合割：平手\n先手：先手\n後手：後手\n\n手数----指手----消費時間--\n";
    
    state.history.forEach((h, i) => { 
      if (i === 0) return; 
      let moveText = "";
      
      if (h.type.includes("投了") || h.type.includes("時間切れ")) {
        moveText = "投了";
      } else if (h.type.includes("反則")) {
        moveText = "投了"; // KIF互換のため反則も投了として出力
      } else if (typeof h.toX !== 'number') {
        moveText = "中断";
      } else {
        const isSame = (i > 1 && h.toX === state.history[i-1].toX && h.toY === state.history[i-1].toY); 
        const pos = isSame ? "同　" : ZEN_NUM[9 - h.toX] + KANJI_NUM[h.toY + 1]; 
        
        let piece = h.isPromoted ? SYMBOLS[UNPROMOTE_MAP[h.type] || h.type] + "成" : SYMBOLS[h.type.replace("(反則)","")];
        // 駒名が1文字（歩、金など）なら全角スペースを足して2文字にする
        if (piece.length === 1) piece += "　";

        const from = h.isDrop ? "打" : "(" + (9 - h.fromX) + (h.fromY + 1) + ")"; 
        moveText = pos + piece + from;
      }

      const lineNum = String(i).padStart(4, " ");
      
      // 指し手と時間の間のスペースを厳密に調整
      // KIFは「手数」「指し手」「時間」の開始位置が決まっています
      let displayMove = moveText.padEnd(7, "　"); 
      if (moveText === "投了" || moveText === "中断") {
          displayMove = "投了      "; 
      }

      // 時間の前にスペースを2つ入れ、( 0:00/00:00:00) の形式を維持
      kif += `${lineNum} ${displayMove} ( 0:00/00:00:00)\n`; 
    });

    const area = document.createElement("textarea"); 
    area.value = kif; document.body.appendChild(area); area.select();
    try { 
      document.execCommand("copy"); 
      alert("KIF形式でコピーしました。"); 
    } catch (err) { 
      alert("コピー失敗"); 
    } 
    document.body.removeChild(area);
  };

  function isCheckmate(board, turn, handS, handG) {
    for (let y = 0; y < 9; y++) for (let x = 0; x < 9; x++) if (board[y][x]?.owner === turn) { const moves = getRawMoves(x, y, board, turn); for (let m of moves) { const tb = JSON.parse(JSON.stringify(board)); tb[m.y][m.x] = tb[y][x]; tb[y][x] = null; if (!isChecked(tb, turn)) return false; } }
    const h = (turn === 'S' ? handS : handG) || []; for (let type of [...new Set(h)]) for (let y = 0; y < 9; y++) for (let x = 0; x < 9; x++) if (!board[y][x]) { const tb = JSON.parse(JSON.stringify(board)); tb[y][x] = { type, owner: turn }; if (!isChecked(tb, turn)) return false; }
    return true;
  }
</script>
</body>
</html>
