<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>2äººäºˆå®šèª¿æ•´ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼</title>
<style>
  body {
    font-family: sans-serif;
    margin: 0; padding: 1em;
    font-size: 16px;
  }
  .title-container {
    text-align: center;
    margin-bottom: 1em;
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5em;
    margin-bottom: 1em;
    justify-content: center;
    align-items: center;
  }
  label {
    display: flex;
    align-items: center;
    gap: 0.2em;
  }
  input, select, button {
    font-size: 1em;
    padding: 0.4em 0.7em;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed;
  }
  th, td {
    border: 1px solid #ccc;
    text-align: center;
    padding: 0.3em;
    vertical-align: top;
    user-select: none;
    word-break: break-word;
  }
  th {
    position: sticky;
    top: 0;
    background: #f0f0f0;
    z-index: 10;
  }
  th.weekend, td.weekend {
    color: red;
  }
  th.holiday, td.holiday {
    color: red;
  }
  td.selected {
    border: 3px solid orange !important;
    background-color: inherit !important;
  }
  td.both {
    background-color: #ccffcc !important;
  }
  .userA {
    color: blue;
    font-weight: bold;
  }
  .userB {
    color: green;
    font-weight: bold;
  }
  .chat {
    margin-top: 2em;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
  }
  .chat-log {
    border: 1px solid #ccc;
    height: 200px;
    overflow-y: auto;
    padding: 0.5em;
    background: #fafafa;
  }
  .chat-message {
    margin-bottom: 0.5em;
    white-space: pre-wrap;
  }
  @media screen and (max-width: 600px) {
    table, thead, tbody, th, td, tr {
      font-size: 12px;
    }
  }
</style>
</head>
<body>

<div class="title-container">
  <h1>2äººäºˆå®šèª¿æ•´ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼</h1>
</div>

<div class="controls">
  <label>ãƒ¦ãƒ¼ã‚¶ãƒ¼Aï¼š<input type="text" id="userAName" autocomplete="off" /></label>
  <label>ãƒ¦ãƒ¼ã‚¶ãƒ¼Bï¼š<input type="text" id="userBName" autocomplete="off" /></label>
  <label><span style="font-size: 1.5em; font-weight: bold;">ãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠï¼š</span>
  <select id="userSelect" disabled>
  <option value="">æœªé¸æŠ</option>
  <option value="A">ãƒ¦ãƒ¼ã‚¶ãƒ¼A</option>
  <option value="B">ãƒ¦ãƒ¼ã‚¶ãƒ¼B</option>
  </select>
  </label>
</div>

<div class="controls">
  <button id="btn-mark-ok">é¸æŠã‚»ãƒ«ã«â—‹</button>
  <button id="btn-mark-no">é¸æŠã‚»ãƒ«ã«Ã—</button>
  <button id="btn-clear-cell">é¸æŠã‚»ãƒ«ã‚’å‰Šé™¤</button>
  <button id="btn-clear-all">å…¨ãƒ‡ãƒ¼ã‚¿å‰Šé™¤</button>
</div>

<div class="controls">
  <button id="btn-prev-week">å‰ã®é€±</button>
  <button id="btn-today">ä»Šæ—¥ã¸æˆ»ã‚‹</button>
  <button id="btn-next-week">æ¬¡ã®é€±</button>
</div>

<table id="calendar"></table>

<div class="chat">
  <h2>ãƒãƒ£ãƒƒãƒˆ</h2>
  <div class="chat-log" id="chatLog"></div>
 <div class="controls" style="margin-top:0.5em; gap:0.5em;">
  <input type="text" id="chatInput" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›" style="flex:1; min-width: 0;" />
  <button id="btn-send">é€ä¿¡</button>
</div>

<div class="controls" style="margin-top:0.5em; gap:0.5em; justify-content: center;">
  <button id="btn-call-start">é€šè©±é–‹å§‹</button>
  <button id="btn-mute" disabled>ãƒŸãƒ¥ãƒ¼ãƒˆ</button>
  <button id="btn-call-end" disabled>é€šè©±çµ‚äº†</button>
  <span id="callStatusDisplay" style="margin-left:1em; font-weight: bold;"></span>
</div>
</div>
<audio id="remote-audio" autoplay></audio><br />
<label for="volume-control">ç›¸æ‰‹ã®éŸ³é‡ï¼š</label>
<input type="range" id="volume-control" min="0" max="1" step="0.01" value="1" />
<audio id="localAudio" autoplay muted style="display:none;"></audio>
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import { getDatabase, ref, onValue, set, remove, update, get, push } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

  const firebaseConfig = {
      apiKey: "AIzaSyCx5anv3WWOQyke9kqhhZ9Zx-RjynLuxzE",
      authDomain: "calendar-chousei.firebaseapp.com",
      databaseURL: "https://calendar-chousei-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "calendar-chousei",
      storageBucket: "calendar-chousei.firebasestorage.app",
      messagingSenderId: "368704703397",
      appId: "1:368704703397:web:86ae24d920aaf7c5a0f64c"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const roomName = location.pathname.split('/').pop().replace('.html', '');
  const callStatusRef = ref(db, `${roomName}/callStatus`);
  const userANameInput = document.getElementById('userAName');
  const userBNameInput = document.getElementById('userBName');
  const userSelect = document.getElementById('userSelect');
  const calendar = document.getElementById('calendar');
  const chatLog = document.getElementById('chatLog');
  const chatInput = document.getElementById('chatInput');
  const btnMarkOk = document.getElementById('btn-mark-ok');
  const btnMarkNo = document.getElementById('btn-mark-no');
  const btnClearCell = document.getElementById('btn-clear-cell');
  const btnClearAll = document.getElementById('btn-clear-all');
  const btnPrevWeek = document.getElementById('btn-prev-week');
  const btnToday = document.getElementById('btn-today');
  const btnNextWeek = document.getElementById('btn-next-week');
  const btnSend = document.getElementById('btn-send');
  const btnCallStart = document.getElementById('btn-call-start');
  const btnCallEnd = document.getElementById('btn-call-end');
  const btnMute = document.getElementById('btn-mute');
  const volumeControl = document.getElementById('volume-control');
  
  volumeControl.addEventListener('input', () => {
  const remoteAudio = document.getElementById('remote-audio');
  if (remoteAudio) {
    remoteAudio.volume = parseFloat(volumeControl.value);
  }
});

  let isMuted = false;
  let remoteStream = null;

btnMute.addEventListener('click', () => {
  if (!localStream) return;
  isMuted = !isMuted;
  localStream.getAudioTracks().forEach(track => {
    track.enabled = !isMuted;
  });
  btnMute.textContent = isMuted ? 'ãƒŸãƒ¥ãƒ¼ãƒˆè§£é™¤' : 'ãƒŸãƒ¥ãƒ¼ãƒˆ';
});
  
  const callStatusDisplay = document.getElementById('callStatusDisplay');

let localStream = null;
let peerConnection = null;
let callTimeoutId = null;
let localCallStartPressed = false;

const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
const signalingRef = ref(db, `${roomName}/signaling`);

// ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã® currentUser è¨­å®š
let currentUser = localStorage.getItem(`${roomName}_currentUser`) || '';

// UI ã®é¸æŠçŠ¶æ…‹ã«åæ˜ 
if (currentUser) {
  userSelect.value = currentUser;   // <select> ã®é¸æŠçŠ¶æ…‹ã‚’ã‚»ãƒƒãƒˆ
  userSelect.disabled = true;       // å®Œå…¨ç„¡åŠ¹åŒ–ã™ã‚‹å ´åˆ
}

let selectedCells = new Set();
let currentWeekOffset = 0;
let holidays = {};
let lockedUserA = false;
let lockedUserB = false;
let callStatus = 'none';

  function formatDate(date) {
    return date.toISOString().split('T')[0];
  }
  function getMonday(date) {
    const d = new Date(date);
    const day = d.getDay();
    const diff = (day === 0 ? -6 : 1) - day;
    d.setDate(d.getDate() + diff);
    d.setHours(0, 0, 0, 0);
    return d;
  }

  async function fetchHolidays() {
    try {
      const res = await fetch('https://holidays-jp.github.io/api/v1/date.json');
      if (!res.ok) throw new Error('ç¥æ—¥APIå–å¾—å¤±æ•—');
      holidays = await res.json();
      renderCalendar();
    } catch (e) {
      console.error(e);
      holidays = {};
      renderCalendar();
    }
  }

  function renderCalendar() {
    calendar.innerHTML = '';
    const thead = document.createElement('thead');
    const trHead = document.createElement('tr');
    thead.appendChild(trHead);
    trHead.appendChild(document.createElement('th'));

    const monday = getMonday(new Date());
    monday.setDate(monday.getDate() + currentWeekOffset * 7);
    const weekdays = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];

    for (let i = 0; i < 7; i++) {
      const d = new Date(monday);
      d.setDate(monday.getDate() + i);
      const mm = d.getMonth() + 1;
      const dd = d.getDate();
      const ymd = formatDate(d);

      const th = document.createElement('th');
      th.innerHTML = `${mm}/${dd}<br>(${weekdays[d.getDay()]})`;

      if (d.getDay() === 0 || d.getDay() === 6) th.classList.add('weekend');
      if (holidays[ymd]) {
        th.classList.add('holiday');
        th.title = holidays[ymd];
      }

      trHead.appendChild(th);
    }
    calendar.appendChild(thead);

    const tbody = document.createElement('tbody');
    for (let h = 9; h <= 22; h++) {
      for (let m = 0; m < 60; m += 30) {
        const tr = document.createElement('tr');
        const tdTime = document.createElement('td');
        tdTime.textContent = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
        tr.appendChild(tdTime);

        for (let i = 0; i < 7; i++) {
          const d = new Date(monday);
          d.setDate(monday.getDate() + i);
          const ymd = formatDate(d);
          const timeStr = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
          const key = `${ymd}_${timeStr}`;
          const td = document.createElement('td');
          td.dataset.key = key;

          if (d.getDay() === 0 || d.getDay() === 6) td.classList.add('weekend');
          if (holidays[ymd]) td.classList.add('holiday');

          td.addEventListener('click', (e) => {
  e.stopPropagation();
  if (!currentUser) {
    alert('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’é¸æŠã—ã¦ãã ã•ã„');
    return;
  }
  if (selectedCells.has(key)) {
    selectedCells.delete(key);
    td.classList.remove('selected');
  } else {
    selectedCells.add(key);
    td.classList.add('selected');
  }
});

          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
    }
    calendar.appendChild(tbody);
    updateScheduleTable();
  }

  async function updateScheduleTable() {
    const monday = getMonday(new Date());
    monday.setDate(monday.getDate() + currentWeekOffset * 7);
    const schedulesRef = ref(db, `${roomName}/schedules`);
    const snapshot = await get(schedulesRef);
    const schedules = snapshot.exists() ? snapshot.val() : {};

    const tds = calendar.querySelectorAll('tbody td[data-key]');
    tds.forEach(td => {
      const key = td.dataset.key;
      const data = schedules[key] || {};
      td.innerHTML = '';

      let hasA = false, hasB = false;
      if (data.A) {
        const divA = document.createElement('div');
        divA.textContent = `A: ${data.A}`;
        divA.classList.add('userA');
        td.appendChild(divA);
        if (data.A === 'â—‹') hasA = true;
      }
      if (data.B) {
        const divB = document.createElement('div');
        divB.textContent = `B: ${data.B}`;
        divB.classList.add('userB');
        td.appendChild(divB);
        if (data.B === 'â—‹') hasB = true;
      }
      td.classList.toggle('both', hasA && hasB);
    });
  }

  async function applyToSelectedCells(value) {
  if (selectedCells.size === 0 || !currentUser) return;
  const updatesObj = {};
  selectedCells.forEach(key => {
    updatesObj[`${roomName}/schedules/${key}/${currentUser}`] = value;
  });
  await update(ref(db), updatesObj);
  selectedCells.clear();
  updateScheduleTable();
}

async function clearSelectedCells() {
  if (selectedCells.size === 0 || !currentUser) return;
  const updatesObj = {};
  selectedCells.forEach(key => {
    updatesObj[`${roomName}/schedules/${key}/${currentUser}`] = null;
  });
  await update(ref(db), updatesObj);
  selectedCells.clear();
  updateScheduleTable();
}

  let isClearingData = false;

async function clearAllData() {
  if (!confirm('æœ¬å½“ã«å…¨ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;

  isClearingData = true; // ãƒ•ãƒ©ã‚°ON

  await remove(ref(db, `${roomName}/userNames`));
  await remove(ref(db, `${roomName}/schedules`));
  await remove(ref(db, `${roomName}/chatLog`));
  await remove(ref(db, `${roomName}/roomUsers`));
  await remove(ref(db, `${roomName}/callStatus`));
  await set(ref(db, `${roomName}/callStatus`), {
    status: 'none',
    users: { A: false, B: false },
    statusMessage: '',
    timestamp: null
  });
  await remove(ref(db, `${roomName}/signaling`));

  userANameInput.value = '';
  userBNameInput.value = '';
  selectedCells.clear();
  localStorage.removeItem(`${roomName}_currentUser`);
  currentUser = '';
  userSelect.innerHTML = '<option value="" selected>æœªé¸æŠ</option>';
  userSelect.disabled = true;

  updateCallStatusUI('none');

  isClearingData = false; // ãƒ•ãƒ©ã‚°OFF

  await remove(ref(db, `${roomName}/signaling`));
  selectedCells.clear();
  localStorage.removeItem(`${roomName}_currentUser`);
sessionStorage.setItem('wasCleared', '1');

lockedUserA = false;
lockedUserB = false;

  currentUser = '';
  
  userSelect.innerHTML = '<option value="" selected>æœªé¸æŠ</option>';
  userSelect.disabled = true;
  
  updateCallStatusUI('none');
  }
  async function startLocalStream() {
  if (localStream) {
    localStream.getTracks().forEach(track => track.stop());
    localStream = null;
  }
  try {
    localStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
      },
      video: false
    });
    localStream.getAudioTracks().forEach(track => {
      track.enabled = true;
      console.log('Audio track enabled:', track);
    });
    return localStream;
  } catch (error) {
    console.error('startLocalStream error:', error);
    throw error;
  }
}

function createPeerConnection() {
  if (peerConnection && peerConnection.signalingState !== 'closed') {
    console.log('createPeerConnection: æ—¢å­˜ã®peerConnectionã‚’å†åˆ©ç”¨ã—ã¾ã™');

    try {
      if (localStream && peerConnection.getSenders) {
        const senders = peerConnection.getSenders();
        localStream.getTracks().forEach(track => {
          const sameSender = senders.find(s => s.track === track);
          if (sameSender) {
            return;
          }

          const sameKindSender = senders.find(s => s.track && s.track.kind === track.kind);
          if (sameKindSender) {
            if (typeof sameKindSender.replaceTrack === 'function') {
              sameKindSender.replaceTrack(track).then(() => {
                console.log(`createPeerConnection(reuse): replaceTrack ã§ ${track.kind} ã‚’å·®ã—æ›¿ãˆã¾ã—ãŸ`);
              }).catch(err => {
                console.warn('createPeerConnection(reuse): replaceTrack ã«å¤±æ•—ã—ã¾ã—ãŸã€‚remove/add ã‚’è©¦ã¿ã¾ã™', err);
                try {
                  peerConnection.removeTrack(sameKindSender);
                } catch (e) {
                  console.warn('createPeerConnection(reuse): removeTrack ã§ã‚¨ãƒ©ãƒ¼', e);
                }
                try {
                  peerConnection.addTrack(track, localStream);
                  console.log(`createPeerConnection(reuse): ${track.kind} ã‚’ addTrack ã—ã¾ã—ãŸ`);
                } catch (e) {
                  console.warn('createPeerConnection(reuse): addTrack ã«å¤±æ•—', e);
                }
              });
            } else {
              try {
                peerConnection.removeTrack(sameKindSender);
              } catch (e) {
                console.warn('createPeerConnection(reuse): removeTrack ã§ã‚¨ãƒ©ãƒ¼', e);
              }
              try {
                peerConnection.addTrack(track, localStream);
                console.log(`createPeerConnection(reuse): ${track.kind} ã‚’ addTrack ã—ã¾ã—ãŸ`);
              } catch (e) {
                console.warn('createPeerConnection(reuse): addTrack ã«å¤±æ•—', e);
              }
            }
          } else {
            try {
              peerConnection.addTrack(track, localStream);
              console.log(`createPeerConnection(reuse): ${track.kind} ã‚’ addTrack ã—ã¾ã—ãŸ`);
            } catch (e) {
              console.warn('createPeerConnection(reuse): addTrack ã«å¤±æ•—', e);
            }
          }
        });
      }
    } catch (e) {
      console.warn('createPeerConnection(reuse): ãƒˆãƒ©ãƒƒã‚¯å†è¨­å®šä¸­ã«ã‚¨ãƒ©ãƒ¼', e);
    }

    return;
  }

  peerConnection = new RTCPeerConnection(configuration);
  console.log('createPeerConnection: æ–°ã—ã„RTCPeerConnectionã‚’ä½œæˆã—ã¾ã—ãŸ');

  if (remoteStream) {
    remoteStream.getTracks().forEach(track => {
      try {
        track.stop();
      } catch (e) {
        console.warn('remoteStream track stop error:', e);
      }
    });
    remoteStream = null;
  }

  peerConnection.ontrack = event => {
    if (event.streams && event.streams[0]) {
      remoteStream = event.streams[0];
    } else {
      if (!remoteStream) remoteStream = new MediaStream();
      remoteStream.addTrack(event.track);
    }

    const remoteAudio = document.getElementById('remote-audio');
    if (remoteAudio) {
      remoteAudio.srcObject = null;
      remoteAudio.srcObject = remoteStream;
      remoteAudio.play().catch(err => {
        console.warn('remoteAudio.play() blocked or failed:', err);
      });
    } else {
      const audio = document.createElement('audio');
      audio.id = 'remote-audio';
      audio.autoplay = true;
      audio.playsInline = true;
      document.body.appendChild(audio);

      audio.srcObject = null;
      audio.srcObject = remoteStream;
      audio.play().catch(err => console.warn("audio.play() error:", err));
    }
  };

  if (localStream) {
    try {
      localStream.getTracks().forEach(track => {
        const alreadyAdded = peerConnection.getSenders().some(sender => sender.track === track);
        if (!alreadyAdded) {
          peerConnection.addTrack(track, localStream);
          console.log(`createPeerConnection(new): ãƒ­ãƒ¼ã‚«ãƒ«ãƒˆãƒ©ãƒƒã‚¯(${track.kind})ã‚’è¿½åŠ ã—ã¾ã—ãŸ`);
        }
      });
    } catch (e) {
      console.warn('createPeerConnection(new): ãƒ­ãƒ¼ã‚«ãƒ«ãƒˆãƒ©ãƒƒã‚¯è¿½åŠ ã§ã‚¨ãƒ©ãƒ¼', e);
    }
  }

  peerConnection.oniceconnectionstatechange = () => {
    const state = peerConnection.iceConnectionState;
    console.log('ICE connection state:', state);

    if (state === 'failed' || state === 'closed') {
      update(ref(db, `${roomName}/callStatus`), {
        status: 'ended',
        users: { A: false, B: false },
        statusMessage: 'ICE: ' + state
      }).catch(console.error);

      endCallCleanup();
      resetUI();
    } else if (state === 'disconnected') {
      setTimeout(() => {
        if (peerConnection && peerConnection.iceConnectionState === 'disconnected') {
          update(ref(db, `${roomName}/callStatus`), {
            status: 'ended',
            users: { A: false, B: false },
            statusMessage: 'ICE: disconnected timeout'
          }).catch(console.error);

          endCallCleanup();
          resetUI();
        }
      }, 5000);
    }
  };

  peerConnection.onicecandidate = event => {
    if (event.candidate) {
      const candRef = ref(db, `${roomName}/signaling/candidates/${currentUser}`);
      const newCandRef = push(candRef);
      set(newCandRef, { candidate: event.candidate.toJSON() });
    }
  };
}

async function endCallCleanup() {
  console.log("=== é€šè©±çµ‚äº†: ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨æ¥ç¶šã‚’è§£æ”¾ ===");

  try {
    await Promise.all([
      remove(ref(db, `${roomName}/signaling/candidates/A`)),
      remove(ref(db, `${roomName}/signaling/candidates/B`)),
      remove(ref(db, `${roomName}/signaling/offer`)),
      remove(ref(db, `${roomName}/signaling/answer`)),
    ]);
    console.log('ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°ã®å€™è£œã¨offer/answerã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
  } catch (e) {
    console.error('å€™è£œå‰Šé™¤ã‚¨ãƒ©ãƒ¼:', e);
  }

  if (remoteStream) {
    remoteStream.getTracks().forEach(track => {
      try {
        track.stop();
      } catch (e) {
        console.warn('remoteStream track stop error:', e);
      }
    });
    remoteStream = null;
  }

  if (localStream) {
    localStream.getTracks().forEach(track => {
      try {
        track.stop();
      } catch (e) {
        console.warn('localStream track stop error:', e);
      }
    });
    localStream = null;
  }

  if (peerConnection) {
    peerConnection.ontrack = null;
    peerConnection.onicecandidate = null;
    peerConnection.oniceconnectionstatechange = null;

    try {
      await Promise.all(peerConnection.getSenders().map(sender => peerConnection.removeTrack(sender)));
    } catch (e) {
      console.warn('peerConnection removeTrack error:', e);
    }

    peerConnection.close();
    await new Promise(resolve => setTimeout(resolve, 500));

    peerConnection = null;
  }

  const remoteAudio = document.getElementById('remote-audio');
  if (remoteAudio) {
    remoteAudio.pause();
    remoteAudio.srcObject = null;
  }

  console.log("=== endCallCleanup å®Œäº† ===");
}

async function sendOffer() {
  createPeerConnection();

  if (localStream) {
    localStream.getTracks().forEach(track => {
      const alreadyAdded = peerConnection.getSenders().some(sender => sender.track === track);
      if (!alreadyAdded) {
        console.log(`sendOffer: ãƒ­ãƒ¼ã‚«ãƒ«ãƒˆãƒ©ãƒƒã‚¯(${track.kind})ã‚’è¿½åŠ `);
        peerConnection.addTrack(track, localStream);
      }
    });
  } else {
    console.warn("sendOffer: localStream ãŒã¾ã ã‚ã‚Šã¾ã›ã‚“");
  }

  const offer = await peerConnection.createOffer();
  await peerConnection.setLocalDescription(offer);

  await set(ref(db, `${roomName}/signaling/offer`), { sdp: offer.sdp, type: offer.type, from: currentUser });
}

function startCallTimeout() {
  if (callTimeoutId) clearTimeout(callTimeoutId);

  callTimeoutId = setTimeout(async () => {
    await update(callStatusRef, {
      status: 'none',
      timestamp: null
    });

    callStatusDisplay.textContent = 'é€šè©±çµ‚äº†ï¼ˆ30ç§’çµŒéï¼‰';

    if (peerConnection) {
      peerConnection.getSenders().forEach(sender => peerConnection.removeTrack(sender));
      peerConnection.close();
      peerConnection = null;
    }

    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }

    await remove(ref(db, `${roomName}/signaling`));
  }, 30000);
}

async function sendAnswer() {
  const offerSnapshot = await get(ref(db, `${roomName}/signaling/offer`));
  if (!offerSnapshot.exists()) return;
  const offer = offerSnapshot.val();

  createPeerConnection();
  await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

  if (localStream) {
    localStream.getTracks().forEach(track => {
      const alreadyAdded = peerConnection.getSenders().some(sender => sender.track === track);
      if (!alreadyAdded) {
        console.log(`sendAnswer: ãƒ­ãƒ¼ã‚«ãƒ«ãƒˆãƒ©ãƒƒã‚¯(${track.kind})ã‚’è¿½åŠ `);
        peerConnection.addTrack(track, localStream);
      }
    });
  } else {
    console.warn("sendAnswer: localStream ãŒã¾ã ã‚ã‚Šã¾ã›ã‚“");
  }

  const answer = await peerConnection.createAnswer();
  await peerConnection.setLocalDescription(answer);

  await set(ref(db, `${roomName}/signaling/answer`), { sdp: answer.sdp, type: answer.type, from: currentUser });
}

function listenSignaling() {
  onValue(ref(db, `${roomName}/signaling/offer`), snapshot => {
    const offer = snapshot.val();
    if (!offer || offer.from === currentUser) return;
    handleOffer(offer);
  });

  async function handleOffer(offer) {
    createPeerConnection();
    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
    await sendAnswer();
  }

  onValue(ref(db, `${roomName}/signaling/answer`), async snapshot => {
    const answer = snapshot.val();
    if (!answer || answer.from === currentUser) return;
    if (peerConnection) {
      await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
    }
  });

  onValue(ref(db, `${roomName}/signaling/candidates/A`), snapshot => {
    if (currentUser === 'B') {
      const candidates = snapshot.val();
      if (!candidates) return;
      Object.values(candidates).forEach(data => {
        if (data?.candidate && peerConnection) {
          peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
      });
    }
  });

  onValue(ref(db, `${roomName}/signaling/candidates/B`), snapshot => {
    if (currentUser === 'A') {
      const candidates = snapshot.val();
      if (!candidates) return;
      Object.values(candidates).forEach(data => {
        if (data?.candidate && peerConnection) {
          peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
      });
    }
  });

  onValue(ref(db, `${roomName}/roomUsers`), () => {
  // ã‚»ãƒ¬ã‚¯ãƒˆã¯è¡¨ç¤ºå°‚ç”¨ã€‚ç¾åœ¨ã®é¸æŠçŠ¶æ…‹ã ã‘åæ˜ ã€‚
  updateUserSelectDisplay();
});
}

async function getUserType(uid) {
  const snapshot = await get(ref(db, `${roomName}/users/${uid}/type`));
  return snapshot.exists() ? snapshot.val() : null;
}

async function updateCallStatus(status) {
  try {
    const snap = await get(ref(db, `${roomName}/callStatus`));
    const prev = snap.exists() ? snap.val() : {};
    const users = prev && prev.users ? prev.users : { A: false, B: false };

    const statusMessage = status === 'waiting'
      ? 'ç›¸æ‰‹ãŒé€šè©±é–‹å§‹ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã®ã‚’å¾…ã£ã¦ã„ã¾ã™'
      : (status === 'started' ? 'é€šè©±ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸ' : (status === 'ended' ? 'é€šè©±ãŒçµ‚äº†ã—ã¾ã—ãŸ' : ''));

    await set(ref(db, `${roomName}/callStatus`), {
      status,
      users,
      statusMessage,
      timestamp: new Date().toISOString()
    });
  } catch (e) {
    console.error('updateCallStatus error:', e);
    await set(ref(db, `${roomName}/callStatus`), {
      status,
      users: { A: false, B: false },
      statusMessage: '',
      timestamp: new Date().toISOString()
    });
  }
}

let isRoomFull = false; // æº€å®¤è¡¨ç¤ºç”¨ã®ãƒ•ãƒ©ã‚°ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«1ã¤

function updateUserSelectDisplay() {
  userSelect.innerHTML = '';
  const opt = document.createElement('option');

  if (currentUser) {
    // ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ç¢ºå®šã—ã¦ã„ã‚‹å´ã ã‘ã‚’è¡¨ç¤º
    opt.value = currentUser;      // 'A' or 'B'
    opt.textContent = currentUser;
    userSelect.disabled = true;   // è¡¨ç¤ºå°‚ç”¨ã«ã™ã‚‹ãªã‚‰ true ã®ã¾ã¾ã§OK
  } else {
    // æœªé¸æŠã€‚æº€å®¤ãªã‚‰ã€Œæº€å®¤ã€ã‚’è¡¨ç¤ºã€ãã†ã§ãªã‘ã‚Œã°ã€Œæœªé¸æŠã€
    opt.value = '';
    opt.textContent = isRoomFull ? 'æº€å®¤' : 'æœªé¸æŠ';
    userSelect.disabled = isRoomFull; // æº€å®¤ã®ã¨ãã ã‘ç„¡åŠ¹åŒ–
  }

  opt.selected = true;
  userSelect.appendChild(opt);

  // roomUsers ã‚’å–å¾—ã—ã¦æº€å®¤ãƒã‚§ãƒƒã‚¯
  const roomUsersRef = ref(db, `${roomName}/roomUsers`);
  get(roomUsersRef).then(snap => {
    const roomUsers = snap.exists() ? snap.val() : {};
    if (roomUsers.A && roomUsers.B) {
      const fullOpt = document.createElement('option');
      fullOpt.value = 'full';
      fullOpt.textContent = 'æº€å®¤';
      userSelect.appendChild(fullOpt);

      userSelect.disabled = true; // æº€å®¤ãªã®ã§ç„¡åŠ¹åŒ–
    } else {
      userSelect.disabled = false; // ç©ºããŒã‚ã‚‹ã®ã§æœ‰åŠ¹åŒ–
    }
  });
}

function resetUI() {
  localCallStartPressed = false;
  updateMyButtonStatusLocal();
  btnCallStart.disabled = false;
  btnCallEnd.disabled = true;
  btnMute.disabled = true;
  btnMute.textContent = 'ãƒŸãƒ¥ãƒ¼ãƒˆ';
  isMuted = false;

  if (localStream) {
  try {
    localStream.getTracks().forEach(track => {
      if (track.readyState === 'live') track.stop();
    });
  } catch (e) {
    console.warn('localStream stop error:', e);
  }
  localStream = null;
}

if (remoteStream) {
  try {
    remoteStream.getTracks().forEach(track => {
      if (track.readyState === 'live') track.stop();
    });
  } catch (e) {
    console.warn('remoteStream stop error:', e);
  }
  remoteStream = null;
}

  const localAudio = document.getElementById('localAudio');
  if (localAudio) localAudio.srcObject = null;

  const remoteAudio = document.getElementById('remote-audio');
  if (remoteAudio) remoteAudio.srcObject = null;

  if (peerConnection) {
    try {
      peerConnection.getSenders().forEach(sender => peerConnection.removeTrack(sender));
      peerConnection.close();
    } catch (e) {
      console.error('peerConnection close error:', e);
    }
    peerConnection = null;
  }
}

  renderCalendar();
  async function sendMessage() {
  if (!currentUser) {
    callStatusDisplay.textContent = 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’é¸æŠã—ã¦ãã ã•ã„';
    return;
  }

  const text = chatInput.value.trim();
  if (!text) return;

  const userName = currentUser;
  const newMsgRef = ref(db, `${roomName}/chatLog`);
  const snapshot = await get(newMsgRef);
  const chatData = snapshot.exists() ? snapshot.val() : [];
  chatData.push({ user: currentUser, name: userName, text, time: new Date().toISOString() });
  await set(newMsgRef, chatData);
  chatInput.value = '';
}

  function renderChat(chatData) {
    chatLog.innerHTML = '';
    chatData.slice(-100).forEach(entry => {
      const div = document.createElement('div');
      div.classList.add('chat-message');
      const nameSpan = document.createElement('span');
      nameSpan.textContent = `${entry.name}: `;
      nameSpan.style.color = entry.user === 'A' ? 'blue' : 'green';
      nameSpan.style.fontWeight = 'bold';

      const textSpan = document.createElement('span');
      textSpan.textContent = entry.text;
      textSpan.style.color = entry.user === 'A' ? 'blue' : 'green';

      div.appendChild(nameSpan);
      div.appendChild(textSpan);
      chatLog.appendChild(div);
    });
    chatLog.scrollTop = chatLog.scrollHeight;
  }

async function initializeUsers() {
  // ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã®é¸æŠã¯ localStorage ã‚’çœŸå®Ÿã¨ã™ã‚‹
  const saved = localStorage.getItem(`${roomName}_currentUser`);
  currentUser = saved || '';

  // UI ã¯ currentUser ã ã‘ã§æç”»ï¼ˆroomUsers ã‚’å‚ç…§ã—ã¦ä¸Šæ›¸ãã—ãªã„ï¼‰
  updateUserSelectDisplay();
  renderCalendar();
}

// --- DOMContentLoaded ã§åˆæœŸåŒ– ---
document.addEventListener('DOMContentLoaded', async () => {
  await initializeUsers();
});

// å®Œå…¨ç„¡åŠ¹åŒ–ã™ã‚‹å ´åˆã€change ã¯å®Ÿè³ªä½¿ã‚ãªã„ãŒæ®‹ã™
userSelect.addEventListener('change', async e => {
  const val = e.target.value;
  if (val === '') return;

  if (sessionStorage.getItem('wasCleared') === '1') {
    sessionStorage.removeItem('wasCleared');
  }

  const roomUsersSnapshot = await get(ref(db, `${roomName}/roomUsers`));
  const roomUsers = roomUsersSnapshot.exists() ? roomUsersSnapshot.val() : {};

  if (val === 'A') {
    if (!roomUsers.A) {
      currentUser = 'A';
      await update(ref(db, `${roomName}/roomUsers`), { A: true });
      userSelect.disabled = true;
      localStorage.setItem(`${roomName}_currentUser`, 'A');
    } else {
      alert('ãƒ¦ãƒ¼ã‚¶ãƒ¼Aã¯æ—¢ã«ç¢ºå®šã—ã¦ã„ã¾ã™');
      e.target.value = '';
    }
  } else if (val === 'B') {
    if (!roomUsers.B) {
      currentUser = 'B';
      await update(ref(db, `${roomName}/roomUsers`), { B: true });
      userSelect.disabled = true;
      localStorage.setItem(`${roomName}_currentUser`, 'B');
    } else {
      alert('ãƒ¦ãƒ¼ã‚¶ãƒ¼Bã¯æ—¢ã«ç¢ºå®šã—ã¦ã„ã¾ã™');
      e.target.value = '';
    }
  }
});

initializeUsers();
listenSignaling();

const userNamesRef = ref(db, `${roomName}/userNames`);

onValue(userNamesRef, async (snapshot) => {
  const data = snapshot.val() || {};

  // åå‰æ¬„ã¸åæ˜ 
  userANameInput.value = data.A || '';
  userBNameInput.value = data.B || '';

  // roomUsers æ›´æ–°
  const nextRoomUsers = {
    A: !!data.A,
    B: !!data.B
  };
  await set(ref(db, `${roomName}/roomUsers`), nextRoomUsers);

  // æº€å®¤ãƒ•ãƒ©ã‚°
  isRoomFull = nextRoomUsers.A && nextRoomUsers.B;

  // ğŸ”‘ ã“ã“ãŒãƒã‚¤ãƒ³ãƒˆï¼š
  // ã¾ã  currentUser ãŒæœªé¸æŠãªã‚‰ Firebase ã®çŠ¶æ…‹ã‚’è¦‹ã¦è‡ªå‹•ã§å‰²ã‚Šå½“ã¦ã‚‹
  if (!currentUser) {
    if (!nextRoomUsers.A) {
      currentUser = 'A';
      localStorage.setItem(`${roomName}_currentUser`, 'A');
    } else if (!nextRoomUsers.B) {
      currentUser = 'B';
      localStorage.setItem(`${roomName}_currentUser`, 'B');
    }
  }

  updateUserSelectDisplay();
  renderCalendar();
});

userANameInput.addEventListener('input', async () => {
  const name = userANameInput.value.trim();
  if (!name) {
    await remove(ref(db, `${roomName}/userNames/A`));
  } else {
    await set(ref(db, `${roomName}/userNames/A`), name);
    // ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯Aã«ç¢ºå®šï¼ˆä»–ãƒ–ãƒ©ã‚¦ã‚¶ã¯æœªé¸æŠã®ã¾ã¾ï¼‰
    currentUser = 'A';
    localStorage.setItem(`${roomName}_currentUser`, 'A');
  }
  updateUserSelectDisplay();
});

userBNameInput.addEventListener('input', async () => {
  const name = userBNameInput.value.trim();
  if (!name) {
    await remove(ref(db, `${roomName}/userNames/B`));
  } else {
    await set(ref(db, `${roomName}/userNames/B`), name);
    // ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯Bã«ç¢ºå®š
    currentUser = 'B';
    localStorage.setItem(`${roomName}_currentUser`, 'B');
  }
  updateUserSelectDisplay();
});

  btnMarkOk.addEventListener('click', () => applyToSelectedCells('â—‹'));
  btnMarkNo.addEventListener('click', () => applyToSelectedCells('Ã—'));
  btnClearCell.addEventListener('click', clearSelectedCells);
  btnClearAll.addEventListener('click', async () => {
    await clearAllData();
    renderCalendar();
    renderChat([]);
  });
  btnPrevWeek.addEventListener('click', () => {
    currentWeekOffset--;
    renderCalendar();
  });
  btnToday.addEventListener('click', () => {
    currentWeekOffset = 0;
    renderCalendar();
  });
  btnNextWeek.addEventListener('click', () => {
    currentWeekOffset++;
    renderCalendar();
  });
  btnSend.addEventListener('click', sendMessage);
  let isCallStarting = false;

btnCallStart.addEventListener('click', async () => {
  if (isCallStarting) {
    return;
  }
  isCallStarting = true;
  btnCallStart.disabled = true;

  if (!currentUser) {
    callStatusDisplay.textContent = 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’é¸æŠã—ã¦ãã ã•ã„';
    isCallStarting = false;
    btnCallStart.disabled = false;
    return;
  }

  try {
    if (peerConnection) {
      try {
        peerConnection.getSenders().forEach(sender => {
          try {
            peerConnection.removeTrack(sender);
          } catch (e) {
            console.warn('removeTrack error:', e);
          }
        });
        peerConnection.close();
      } catch (e) {
        console.warn('peerConnection closeæ™‚ã®ã‚¨ãƒ©ãƒ¼:', e);
      }
      peerConnection = null;
    }

    if (localStream) {
      localStream.getTracks().forEach(track => {
        try {
          track.stop();
        } catch (e) {
          console.warn('localStream track stop error:', e);
        }
      });
      localStream = null;
    }

    await startLocalStream();

    resetMuteState();
    createPeerConnection();

    if (localStream) {
      localStream.getTracks().forEach(track => {
        const senderExists = peerConnection.getSenders().some(sender => sender.track === track);
        if (!senderExists) {
          peerConnection.addTrack(track, localStream);
        }
      });
    }

const localAudio = document.getElementById('localAudio');
if (localAudio) {
  localAudio.srcObject = localStream;
  localAudio.play().catch(err => {
    console.warn('localAudio.play() blocked or failed:', err);
  });
}

    await remove(ref(db, `${roomName}/signaling`));

    const callStatusSnap = await get(callStatusRef);
    const callData = callStatusSnap.exists() ? callStatusSnap.val() : {
      status: 'none',
      users: { A: false, B: false }
    };

    if (!callData.users) {
      callData.users = { A: false, B: false };
    }

    callData.users[currentUser] = true;

    let newStatus = 'waiting';
    if (callData.users.A && callData.users.B) {
      newStatus = 'started';
      await sendOffer();
    } else if (!callData.users.A && !callData.users.B) {
      newStatus = 'none';
    } else {
      newStatus = 'waiting';
    }

    await update(callStatusRef, {
      status: newStatus,
      users: callData.users,
      statusMessage: newStatus === 'waiting'
        ? 'ç›¸æ‰‹ãŒé€šè©±é–‹å§‹ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã®ã‚’å¾…ã£ã¦ã„ã¾ã™'
        : (newStatus === 'started' ? 'é€šè©±ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸ' : '')
    });

    localCallStartPressed = true;
    updateMyButtonStatusLocal();

  } catch (e) {
    console.error(e);
    callStatusDisplay.textContent = 'é€šè©±ã®æº–å‚™ã«å¤±æ•—ã—ã¾ã—ãŸ';
    localCallStartPressed = false;
    updateMyButtonStatusLocal();
  } finally {
    isCallStarting = false;
  }
});

btnCallEnd.addEventListener('click', async () => {
  if (!currentUser) {
    alert('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’é¸æŠã—ã¦ãã ã•ã„');
    return;
  }

  try {
    const callStatusSnap = await get(callStatusRef);
    const callData = callStatusSnap.exists() ? callStatusSnap.val() : {
      status: 'none',
      users: { A: false, B: false }
    };

    if (callData.users && callData.users[currentUser] !== undefined) {
      callData.users[currentUser] = false;
    }

await update(ref(db, `${roomName}/callStatus`), {
  status: 'ended',
  users: { A: false, B: false },
  statusMessage: 'é€šè©±ãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸ'
});

    localCallStartPressed = false;
    updateMyButtonStatusLocal();

    btnCallStart.disabled = false;
    btnCallEnd.disabled = true;
    btnMute.disabled = true;
    btnMute.textContent = 'ãƒŸãƒ¥ãƒ¼ãƒˆ';

    isMuted = false;

    if (localStream) {
      try {
        localStream.getAudioTracks().forEach(track => {
          track.enabled = true;
        });
        localStream.getTracks().forEach(track => {
          if (track.readyState === 'live') {
            track.stop();
          }
        });
      } catch (e) {
        console.warn('localStream stop error:', e);
      }
      localStream = null;
    }

    if (remoteStream) {
      try {
        remoteStream.getTracks().forEach(track => {
          if (track.readyState === 'live') {
            track.stop();
          }
        });
      } catch (e) {
        console.warn('remoteStream stop error:', e);
      }
      remoteStream = null;
    }

    const remoteAudio = document.getElementById('remote-audio');
    if (remoteAudio) {
      remoteAudio.srcObject = null;
    }

    const localAudio = document.getElementById('localAudio');
    if (localAudio) {
      localAudio.srcObject = null;
    }

    if (peerConnection) {
  try {
    await Promise.all(peerConnection.getSenders().map(sender => peerConnection.removeTrack(sender)));
    peerConnection.close();
    await new Promise(resolve => setTimeout(resolve, 200));
  } catch (e) {
    console.warn('peerConnection closeæ™‚ã®ã‚¨ãƒ©ãƒ¼:', e);
  }
  peerConnection = null;
}

    try {
      await remove(ref(db, `${roomName}/signaling`));
    } catch (e) {
      console.error('signaling remove error:', e);
    }

    callStatusDisplay.textContent = 'é€šè©±ã¯çµ‚äº†ã—ã¾ã—ãŸ';
    
    window.location.reload();

  } catch (e) {
    console.error('é€šè©±çµ‚äº†å‡¦ç†ã§ã‚¨ãƒ©ãƒ¼:', e);
    callStatusDisplay.textContent = 'é€šè©±çµ‚äº†æ™‚ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
  }
});

let hasReloaded = false;
onValue(callStatusRef, (snapshot) => {
  const callData = snapshot.val();
  if (!callData) return;
  if (callData.status === 'ended' && localCallStartPressed && !hasReloaded) {
    hasReloaded = true;
    window.location.reload();
    return;
    }

  const iPressed = !!callData.users?.[currentUser];
  const otherPressed = !!callData.users?.[currentUser === 'A' ? 'B' : 'A'];
  const status = callData.status;

  localCallStartPressed = iPressed;

  switch (status) {
    case 'ended':
      localCallStartPressed = false;
      updateMyButtonStatusLocal(); 
      resetUI();
      callStatusDisplay.textContent = 'é€šè©±ã¯çµ‚äº†ã—ã¾ã—ãŸ';

      isMuted = false;
      btnCallStart.disabled = false;
      btnCallEnd.disabled = true;
      btnMute.disabled = true;
      btnMute.textContent = 'ãƒŸãƒ¥ãƒ¼ãƒˆ';

      if (localStream) {
        try {
          localStream.getTracks().forEach(track => {
            if (track.readyState === 'live') track.stop();
          });
        } catch (e) {
          console.warn('localStream stop error:', e);
        }
        localStream = null;
      }

      if (remoteStream) {
        try {
          remoteStream.getTracks().forEach(track => {
            if (track.readyState === 'live') track.stop();
          });
        } catch (e) {
          console.warn('remoteStream stop error:', e);
        }
        remoteStream = null;
      }

      const remoteAudio = document.getElementById('remote-audio');
      if (remoteAudio) remoteAudio.srcObject = null;

      const localAudio = document.getElementById('localAudio');
      if (localAudio) localAudio.srcObject = null;

      if (peerConnection) {
        try {
          peerConnection.getSenders().forEach(sender => peerConnection.removeTrack(sender));
          peerConnection.close();
        } catch (e) {
          console.error('peerConnection close error:', e);
        }
        peerConnection = null;
      }
      break;

    case 'waiting':
      callStatusDisplay.textContent = 'é€šè©±ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚Œã¾ã—ãŸï¼ˆç›¸æ‰‹ã‚’å¾…ã£ã¦ã„ã¾ã™ï¼‰';

      if (!iPressed && !otherPressed) {
        updateMyButtonStatus('none');
      } else if (!iPressed && otherPressed) {
        updateMyButtonStatus('none');
      } else if (iPressed && !otherPressed) {
        updateMyButtonStatusLocal();
      } else {
        updateMyButtonStatus('started');
      }
      break;

    case 'started':
      callStatusDisplay.textContent = 'é€šè©±ä¸­';
      updateMyButtonStatus('started');
      break;

    case 'none':
    default:
      callStatusDisplay.textContent = '';
      resetUI();
      break;
  }
});

onValue(ref(db, `${roomName}/schedules`), snapshot => updateScheduleTable());
onValue(ref(db, `${roomName}/chatLog`), snapshot => {
  const chatData = snapshot.exists() ? snapshot.val() : [];
  renderChat(chatData);
});

fetchHolidays();
renderCalendar();

document.addEventListener('click', (e) => {
  if (!e.target.closest('td')) {
    selectedCells.forEach(key => {
      const td = calendar.querySelector(`td[data-key="${key}"]`);
      if (td) td.classList.remove('selected');
    });
    selectedCells.clear();
  }
});

function updateCallStatusUI(status) {
  callStatus = status;
  callStatusDisplay.textContent = {
    'started': 'é€šè©±ä¸­',
    'waiting': 'é€šè©±ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚Œã¾ã—ãŸï¼ˆç›¸æ‰‹ã‚’å¾…ã£ã¦ã„ã¾ã™ï¼‰',
    'ended': 'é€šè©±ãŒçµ‚äº†ã—ã¾ã—ãŸ',
    'none': ''
  }[status] || '';

  updateMyButtonStatus(status);
}

function updateMyButtonStatus(status) {
  switch (status) {
    case 'started':
      btnCallStart.disabled = true;
      btnCallEnd.disabled = false;
      btnMute.disabled = false;
      break;
    case 'none':
    default:
      btnCallStart.disabled = false;
      btnCallEnd.disabled = true;
      btnMute.disabled = true;
      btnMute.textContent = 'ãƒŸãƒ¥ãƒ¼ãƒˆ';
      isMuted = false;
      break;
  }
}

function updateMyButtonStatusLocal() {
  if (localCallStartPressed) {
    btnCallStart.disabled = true;
    btnCallEnd.disabled = false;
    btnMute.disabled = false;
  } else {
    btnCallStart.disabled = false;
    btnCallEnd.disabled = true;
    btnMute.disabled = true;
  }
}

function resetMuteState() {
  isMuted = false;
  btnMute.textContent = 'ãƒŸãƒ¥ãƒ¼ãƒˆ';

  if (localStream) {
    localStream.getAudioTracks().forEach(track => {
      track.enabled = true;
    });
  }
}

(async () => {
  const callStatusSnap = await get(callStatusRef);
  const callData = callStatusSnap.exists() ? callStatusSnap.val() : {};

  if (callData.status === 'waiting') {
    if (callData.user !== currentUser) {
      if (localCallStartPressed) {
        localCallStartPressed = false;
        updateMyButtonStatusLocal();
      }
      callStatusDisplay.textContent = 'ç›¸æ‰‹ãŒé€šè©±ã‚’é–‹å§‹ã—ã¾ã—ãŸï¼ˆã‚ãªãŸã®å¿œç­”å¾…ã¡ï¼‰';
    }
  }
})();

volumeControl.addEventListener('input', () => {
  const remoteAudio = document.getElementById('remote-audio');
  if (remoteAudio) remoteAudio.volume = parseFloat(volumeControl.value);
});

</script>
</body>
</html>