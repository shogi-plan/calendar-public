<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>フルスクラッチ将棋 — 投了 & 持ち駒領域修正版</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
:root{
  --ui-font: 14px;
  --ui-font-lg: 16px;
  --btn-pad-y: 8px;
  --btn-pad-x: 12px;
}
body{
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
  display:flex; flex-direction:column; align-items:center;
  padding:10px; box-sizing:border-box;
}
h1{ font-size: clamp(16px, 2.4vw, 20px); margin: 6px 0 10px; }

#controls{
  margin-top:8px; display:flex; flex-wrap:wrap; gap:10px;
  justify-content:center; align-items:center;
  font-size: var(--ui-font);
}
#controls label{ display:flex; align-items:center; gap:6px; }
#controls input[type="number"], #controls select{
  font-size: var(--ui-font);
  padding: 4px 6px;
}
#controls button{
  font-size: var(--ui-font-lg);
  padding: var(--btn-pad-y) var(--btn-pad-x);
  border-radius:8px; border:1px solid #666; background:#f7f7f7; cursor:pointer;
}
#controls button:hover{ background:#efefef; }
#timebar{ margin:8px 0 6px; font-size: var(--ui-font-lg); }

/* board */
#board{
  display:grid; grid-template-columns:repeat(9,1fr); grid-template-rows:repeat(9,1fr);
  gap:0; border:3px solid #333; width:92vmin; height:92vmin; max-width:none; position:relative;
  transition: transform 0.18s ease;
  transform-origin: center center;
}
/* board rotate 180deg on flipped */
#board.flipped{ transform: rotate(180deg); }

.cell{
  display:flex; align-items:center; justify-content:center; cursor:pointer;
  background:#f5deb3; border:1px solid #999; font-weight:bold;
  font-size: clamp(14px, 3.8vmin, 28px);
  user-select:none; transition:background-color .08s;
  position:relative; overflow:hidden;
}
.selected{ outline:3px solid #ffcd00; background:#fff5a6; }

.piece{ display:flex; align-items:center; justify-content:center; width:100%; height:100%; line-height:1; box-sizing:border-box; }
.piece.promoted{ color:#b30000; font-weight:700; }
/* initial-opponent pieces appear rotated (based on initSide property) */
.piece.opposite{ transform: rotate(180deg); }

/* hands: fixed block under each label so they don't push each other */
#hands{ margin-top:10px; display:flex; gap:18px; justify-content:center; font-size: var(--ui-font-lg); align-items:flex-start; width:100%; box-sizing:border-box; padding:0 10px;}
.hand-block{ display:flex; flex-direction:column; align-items:center; gap:6px; width:220px; box-sizing:border-box; }
.hand-label{ display:block; text-align:center; min-height:1.2em; }
.hand{ display:flex; gap:6px; flex-wrap:wrap; justify-content:center; width:100%; min-height:44px; border:1px solid #ddd; padding:6px; box-sizing:border-box; background:#fff; border-radius:6px; overflow:auto; max-height:120px; }
.hand span{ display:inline-flex; align-items:center; justify-content:center; padding:6px 10px; border-radius:8px; background:#fff; border:1px solid #aaa; cursor:pointer; font-size:1.0em; }
.hand span.selected{ outline:3px solid #ffcd00; background:#fff5a6; }
/* visually rotate opponent's hand piece glyphs so they look correct */
#handG span{ display:inline-flex; transform: rotate(180deg); }

/* kifu list */
#kifuPanel{ display:none; width:95vw; max-width:640px; margin-top:12px; }
#kifuPanel h2{ font-size: var(--ui-font-lg); margin: 8px 0; }
#kifuList{ border:1px solid #999; padding:8px; border-radius:8px; max-height:220px; overflow:auto; background:#fff; list-style: none; margin:0; padding-left:0; }
#kifuList li{ padding:6px 8px; border-bottom:1px solid #eee; cursor:pointer; display:flex; justify-content:space-between; align-items:center; }
#kifuList li.kifu-selected{ background:#eaf6ff; outline:2px solid #9cd2ff; }

#kansoControls{ width:95vw; max-width:640px; margin-top:8px; display:flex; justify-content:center; gap:12px; }
#kansoControls button{ font-size:14px; padding:8px 12px; border-radius:8px; }

.hidden{ display:none !important; }
</style>
</head>
<body>
<h1>遠タメ将棋</h1>

<div id="controls">
  <label>自分の役割：
    <select id="mySide">
      <option value="S">先手で開始</option>
      <option value="G">後手で開始</option>
    </select>
  </label>

  <label>持ち時間：
    <input type="number" id="timeMinutes" value="5" min="0" style="width:64px;">分
  </label>
  <label>秒読み：
    <input type="number" id="timeSeconds" value="30" min="0" style="width:64px;">秒
  </label>

  <button id="toggleKanso">感想戦へ</button>
  <button id="copyKif">KIFcopy</button>
  <button id="flipBoard" title="盤を180度回転">反転</button>
  <!-- 投了ボタン: 対局モードのみ表示 -->
  <button id="resign">投了</button>
</div>

<div id="timebar">
  <span>先手：<span id="timerS">05:00</span></span> ｜ 
  <span>後手：<span id="timerG">05:00</span></span>
</div>

<div id="board"></div>

<div id="kansoControls" class="hidden">
  <button id="prev">一手戻る</button>
  <button id="next">一手進む</button>
</div>

<!-- 持ち駒をラベル下に固定する構造 -->
<div id="hands">
  <div class="hand-block">
    <div class="hand-label">自分の持ち駒</div>
    <div id="handS" class="hand"></div>
  </div>
  <div class="hand-block">
    <div class="hand-label">相手の持ち駒</div>
    <div id="handG" class="hand"></div>
  </div>
</div>

<section id="kifuPanel">
  <h2>棋譜（リストの項目をクリックするとその局面へジャンプ）</h2>
  <ol id="kifuList"></ol>
</section>

<script>
// ========== 定数・ユーティリティ ==========
const PIECE_SYMBOLS={FU:'歩',KY:'香',KE:'桂',GI:'銀',KI:'金',KA:'角',HI:'飛',OU:'玉',TO:'と',NY:'成香',NK:'成桂',NG:'成銀',UM:'馬',RY:'龍'};
const PROMOTABLE=['FU','KY','KE','GI','KA','HI'];
function clone(obj){ return JSON.parse(JSON.stringify(obj)); }
function unpromote(type){
  switch(type){case 'TO': return 'FU'; case 'NY': return 'KY'; case 'NK': return 'KE'; case 'NG': return 'GI'; case 'UM': return 'KA'; case 'RY': return 'HI'; default: return type;}
}
function inBoard(x,y){ return x>=0 && x<9 && y>=0 && y<9; }
function inPromotionZone(owner,y){ return owner==='S' ? (y<=2) : (y>=6); }
function moveCanPromote(owner, fromY, toY, pieceType){
  if(!PROMOTABLE.includes(pieceType)) return false;
  return inPromotionZone(owner, fromY) || inPromotionZone(owner, toY);
}
function mustAutoPromote(type, owner, toY){
  if(type==='FU' || type==='KY'){ return owner==='S' ? (toY===0) : (toY===8); }
  if(type==='KE'){ return owner==='S' ? (toY<=1) : (toY>=7); }
  return false;
}

// ========== 初期盤面 ==========
function createInitialBoard(){
  const row=(arr,yInit)=>arr.map(x=>x?{type:x.type,owner:x.owner,initSide:yInit>=6?'B':'T'}:null);
  return [
    row([{type:'KY',owner:'G'},{type:'KE',owner:'G'},{type:'GI',owner:'G'},{type:'KI',owner:'G'},{type:'OU',owner:'G'},{type:'KI',owner:'G'},{type:'GI',owner:'G'},{type:'KE',owner:'G'},{type:'KY',owner:'G'}],0),
    row([null,{type:'HI',owner:'G'},null,null,null,null,null,{type:'KA',owner:'G'},null],1),
    row(Array(9).fill({type:'FU',owner:'G'}),2),
    row(Array(9).fill(null),3),
    row(Array(9).fill(null),4),
    row(Array(9).fill(null),5),
    row(Array(9).fill({type:'FU',owner:'S'}),6),
    row([null,{type:'KA',owner:'S'},null,null,null,null,null,{type:'HI',owner:'S'},null],7),
    row([{type:'KY',owner:'S'},{type:'KE',owner:'S'},{type:'GI',owner:'S'},{type:'KI',owner:'S'},{type:'OU',owner:'S'},{type:'KI',owner:'S'},{type:'GI',owner:'S'},{type:'KE',owner:'S'},{type:'KY',owner:'S'}],8)
  ];
}

// ========== 状態 ==========
let initialBoard = createInitialBoard();
let boardState = clone(initialBoard);
let selected = null;                // {x,y}
let selectedHand = null;            // {type, owner, index}
let handS = [], handG = [];
let kifu = [];
// history の各要素は {board, handS, handG, mover}
// mover: そのスナップに到達させた「最後に指したプレイヤー」（'S' / 'G' / null）
let history = [{board: clone(boardState), handS:[], handG:[], mover: null}];
let historyIndex = 0;

let mySide = 'S';
let currentPlayer = 'S';
let kansoMode = false;
let gameOver = false;

let boardFlipped = false; // 盤回転状態（ローカルのみ保持）

// ========== タイマー ==========
let mainTimeS = 300, mainTimeG = 300;   // 秒
let byoBase = 30;
let byoRemainS = 0, byoRemainG = 0;
let timerId = null;

function readTimeSettings(){
  const m = Math.max(0, parseInt(document.getElementById('timeMinutes').value)||0);
  const s = Math.max(0, parseInt(document.getElementById('timeSeconds').value)||0);
  mainTimeS = mainTimeG = m*60;
  byoBase = s;
  byoRemainS = byoRemainG = 0;
  updateTimerDisplay();
}
function startTick(){
  if(timerId) clearInterval(timerId);
  timerId = setInterval(()=> tickOneSecond(), 1000);
}
function stopTick(){ if(timerId){ clearInterval(timerId); timerId = null; } }

function tickOneSecond(){
  if(gameOver || kansoMode) return;

  let over = false;

  if(currentPlayer==='S'){
    if(mainTimeS>0){
      mainTimeS = Math.max(0, mainTimeS-1);
    }else{
      if(byoBase<=0){
        over = true;
      }else{
        if(byoRemainS<=0) byoRemainS = byoBase;
        byoRemainS = Math.max(0, byoRemainS-1);
        if(byoRemainS===0) over = true;
      }
    }
  }else{
    if(mainTimeG>0){
      mainTimeG = Math.max(0, mainTimeG-1);
    }else{
      if(byoBase<=0){
        over = true;
      }else{
        if(byoRemainG<=0) byoRemainG = byoBase;
        byoRemainG = Math.max(0, byoRemainG-1);
        if(byoRemainG===0) over = true;
      }
    }
  }

  updateTimerDisplay();
  if(over){
    timeOver(currentPlayer);
  }
}
function timeOver(side){
  gameOver = true;
  stopTick();
  alert(`${side==='S'?'先手':'後手'}の時間切れで負けです。`);
}
function onMoveFinishedSwitchTurn(){
  if(currentPlayer==='S'){
    if(mainTimeS<=0) byoRemainS = byoBase;
  }else{
    if(mainTimeG<=0) byoRemainG = byoBase;
  }
  updateTimerDisplay();
}
function updateTimerDisplay(){
  const timerSEl = document.getElementById('timerS');
  const timerGEl = document.getElementById('timerG');
  const fmt = (mt, byorem)=> {
    if(mt>0){
      const m = Math.floor(mt/60), s = mt%60;
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }else{
      const s = Math.max(0, byorem>0? byorem : 0);
      return `${String(s).padStart(2,'0')}`;
    }
  };
  if(timerSEl) timerSEl.textContent = fmt(mainTimeS, byoRemainS);
  if(timerGEl) timerGEl.textContent = fmt(mainTimeG, byoRemainG);
}

// ========== DOM ==========
const boardEl = document.getElementById('board');
const handSEl = document.getElementById('handS');
const handGEl = document.getElementById('handG');
const kifuPanelEl = document.getElementById('kifuPanel');
const kifuListEl = document.getElementById('kifuList');
const kansoControlsEl = document.getElementById('kansoControls');
const resignBtn = document.getElementById('resign');

// ========== 盤生成 ==========
function createBoardCells(){
  boardEl.innerHTML = '';
  const frag = document.createDocumentFragment();
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.x = x; cell.dataset.y = y;
      cell.addEventListener('click', ()=> cellClick(x,y));
      frag.appendChild(cell);
    }
  }
  boardEl.appendChild(frag);
}

function renderPieceToCell(cell, p){
  const el = document.createElement('div');
  el.className = 'piece';
  if(['TO','NY','NK','NG','UM','RY'].includes(p.type)){ el.classList.add('promoted'); }
  el.textContent = PIECE_SYMBOLS[p.type] || p.type;
  // initSide によって初期側の駒（相手側駒）を回転
  if(p.initSide === 'T'){ el.classList.add('opposite'); }
  cell.appendChild(el);
}

function renderBoard(){
  // 盤だけ回転（UI文字は回転させない）
  boardEl.classList.toggle('flipped', boardFlipped);

  const cells = boardEl.childNodes;
  for (let i=0;i<cells.length;i++){
    const cell = cells[i];
    const x = parseInt(cell.dataset.x), y = parseInt(cell.dataset.y);
    cell.classList.toggle('selected', selected && selected.x===x && selected.y===y);
    cell.textContent = '';
    const p = boardState[y][x];
    if(p){ renderPieceToCell(cell, p); }
  }
  renderHands();
  if(kansoMode) renderKifuList();
}

function renderHands(){
  if(!handSEl || !handGEl) return;
  handSEl.innerHTML = '';
  handGEl.innerHTML = '';

  // 先手の持ち駒
  for(let i=0;i<handS.length;i++){
    const t = handS[i];
    const s = document.createElement('span');
    s.textContent = PIECE_SYMBOLS[t] || t;
    s.className = (selectedHand && selectedHand.type===t && selectedHand.owner==='S' && selectedHand.index===i) ? 'selected' : '';
    s.onclick = ()=>{
      if(gameOver) return;
      // 選択可能は「現在の手番」だけ
      if(currentPlayer!=='S') return;
      if(selectedHand && selectedHand.owner==='S' && selectedHand.index===i){
        selectedHand = null;
      }else{
        selectedHand = {type:t, owner:'S', index: i};
      }
      selected = null;
      renderBoard();
    };
    handSEl.appendChild(s);
  }

  // 後手の持ち駒
  for(let i=0;i<handG.length;i++){
    const t = handG[i];
    const s = document.createElement('span');
    s.textContent = PIECE_SYMBOLS[t] || t;
    s.className = (selectedHand && selectedHand.type===t && selectedHand.owner==='G' && selectedHand.index===i) ? 'selected' : '';
    s.onclick = ()=>{
      if(gameOver) return;
      if(currentPlayer!=='G') return;
      if(selectedHand && selectedHand.owner==='G' && selectedHand.index===i){
        selectedHand = null;
      }else{
        selectedHand = {type:t, owner:'G', index: i};
      }
      selected = null;
      renderBoard();
    };
    handGEl.appendChild(s);
  }
}

function renderKifuList(){
  kifuListEl.innerHTML = '';
  kifu.forEach((m, i)=>{
    const li = document.createElement('li');
    li.dataset.index = i;
    const idx = i+1;
    const span = document.createElement('span');
    span.textContent = `${idx}. ${m}`;
    li.appendChild(span);
    li.addEventListener('click', ()=>{
      const prev = kifuListEl.querySelector('li.kifu-selected');
      if(prev) prev.classList.remove('kifu-selected');
      li.classList.add('kifu-selected');
      if(history[i]){ jumpToHistory(i); }
    });
    if(i===historyIndex) li.classList.add('kifu-selected');
    kifuListEl.appendChild(li);
  });
}

// ========== 着手可能性（簡易） ==========
function getLegalMoves(x,y){
  const piece = boardState[y][x];
  if(!piece) return new Set();
  const o = piece.owner;
  const dir = (o === 'S') ? -1 : +1;
  const t = piece.type;
  const moves = new Set();
  const addStep = (dx,dy) => {
    const nx = x+dx, ny = y+dy; if(!inBoard(nx,ny)) return;
    const target = boardState[ny][nx];
    if(!target || target.owner !== o) moves.add(`${nx},${ny}`);
  };
  const addSlide = (sx,sy) => {
    let nx=x+sx, ny=y+sy;
    while(inBoard(nx,ny)){
      const target = boardState[ny][nx];
      if(!target){ moves.add(`${nx},${ny}`); }
      else { if(target.owner !== o) moves.add(`${nx},${ny}`); break; }
      nx+=sx; ny+=sy;
    }
  };
  switch(t){
    case 'FU': addStep(0,dir); break;
    case 'KY': addSlide(0,dir); break;
    case 'KE': addStep(-1,2*dir); addStep(1,2*dir); break;
    case 'GI': addStep(-1,dir); addStep(0,dir); addStep(1,dir); addStep(-1,-dir); addStep(1,-dir); break;
    case 'KI': case 'TO': case 'NY': case 'NK': case 'NG':
      addStep(-1,dir); addStep(0,dir); addStep(1,dir); addStep(-1,0); addStep(1,0); addStep(0,-dir); break;
    case 'KA': addSlide(1,1); addSlide(1,-1); addSlide(-1,1); addSlide(-1,-1); break;
    case 'HI': addSlide(1,0); addSlide(-1,0); addSlide(0,1); addSlide(0,-1); break;
    case 'OU': addStep(1,0); addStep(-1,0); addStep(0,1); addStep(0,-1); addStep(1,1); addStep(1,-1); addStep(-1,1); addStep(-1,-1); break;
    case 'UM': addSlide(1,1); addSlide(1,-1); addSlide(-1,1); addSlide(-1,-1); addStep(1,0); addStep(-1,0); addStep(0,1); addStep(0,-1); break;
    case 'RY': addSlide(1,0); addSlide(-1,0); addSlide(0,1); addSlide(0,-1); addStep(1,1); addStep(1,-1); addStep(-1,1); addStep(-1,-1); break;
  }
  return moves;
}
function isKingInCheck(owner){
  let kingPos = null;
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const p=boardState[y][x];
      if(p && p.type==='OU' && p.owner===owner){ kingPos={x,y}; break; }
    }
    if(kingPos) break;
  }
  if(!kingPos) return false;
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const p=boardState[y][x];
      if(p && p.owner !== owner){
        const moves = getLegalMoves(x,y);
        if(moves.has(`${kingPos.x},${kingPos.y}`)) return true;
      }
    }
  }
  return false;
}
function hasAnyLegalResponse(owner){
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const p = boardState[y][x];
      if(!p || p.owner !== owner) continue;
      const moves = getLegalMoves(x,y);
      for(const key of moves){
        const [nx,ny] = key.split(',').map(Number);
        const savedFrom = boardState[y][x];
        const savedTo   = boardState[ny][nx];
        boardState[ny][nx] = savedFrom; boardState[y][x] = null;
        const stillInCheck = isKingInCheck(owner);
        boardState[y][x] = savedFrom; boardState[ny][nx] = savedTo;
        if(!stillInCheck) return true;
      }
    }
  }
  return false;
}
function checkDoublePawn(type,x,owner){
  if(type !== 'FU') return false;
  for(let y=0;y<9;y++){
    const p = boardState[y][x];
    if(p && p.type === 'FU' && p.owner === owner) return true;
  }
  return false;
}
function isUchifuzume(dropX,dropY,type){
  if(type !== 'FU') return false;
  const opponent = (currentPlayer === 'S') ? 'G' : 'S';
  const prev = boardState[dropY][dropX];
  boardState[dropY][dropX] = { type: type, owner: currentPlayer, initSide: (currentPlayer==='S' ? 'B' : 'T') };
  const oppInCheck = isKingInCheck(opponent);
  let mate = false;
  if(oppInCheck){
    const hasResponse = hasAnyLegalResponse(opponent);
    if(!hasResponse) mate = true;
  }
  boardState[dropY][dropX] = prev;
  return mate;
}

// ========== 移動・打ち ==========
function attemptMove(from, to){
  if(gameOver || kansoMode) return;
  const piece = boardState[from.y][from.x]; if(!piece) return;
  const legal = getLegalMoves(from.x, from.y); if(!legal.has(`${to.x},${to.y}`)) return;

  const canPromote = moveCanPromote(piece.owner, from.y, to.y, piece.type);
  const mustProm = mustAutoPromote(piece.type, piece.owner, to.y);

  let finalType = piece.type;
  if(mustProm){
    if(piece.type==='FU') finalType='TO';
    else if(piece.type==='KY') finalType='NY';
    else if(piece.type==='KE') finalType='NK';
  }else if(canPromote){
    const yes = window.confirm('成りますか？');
    if(yes){
      if(piece.type==='FU') finalType='TO';
      else if(piece.type==='KY') finalType='NY';
      else if(piece.type==='KE') finalType='NK';
      else if(piece.type==='GI') finalType='NG';
      else if(piece.type==='KA') finalType='UM';
      else if(piece.type==='HI') finalType='RY';
    }
  }
  performMove(from, to, finalType);
}

function performMove(from, to, finalPieceType){
  const piece = boardState[from.y][from.x];
  const dest  = boardState[to.y][to.x];

  if(dest){
    if(dest.type==='OU'){
      boardState[to.y][to.x] = null;
      boardState[from.y][from.x] = null;
      kifu.push(`${currentPlayer==='S'?'▲':'△'}${9-to.x}${to.y+1}${PIECE_SYMBOLS[piece.type]||piece.type}`);
      renderBoard();
      alert((currentPlayer==='S'?'先手':'後手')+'が玉を取りました。勝ち。');
      gameOver = true; stopTick();
      return;
    }else{
      const base = unpromote(dest.type);
      if(currentPlayer==='S') handS.push(base); else handG.push(base);
    }
  }

  const movedPiece = { type: finalPieceType || piece.type, owner: piece.owner, initSide: piece.initSide };
  boardState[to.y][to.x] = movedPiece;
  boardState[from.y][from.x] = null;

  if(!kansoMode){ kifu.push(`${currentPlayer==='S'?'▲':'△'}${9-to.x}${to.y+1}${PIECE_SYMBOLS[movedPiece.type]||movedPiece.type}`); }

  // 履歴には「この局面に到達させた最後に指した人」を保存（mover）
  history.push({board: clone(boardState), handS: clone(handS), handG: clone(handG), mover: currentPlayer});
  historyIndex = history.length - 1;

  selected = null;
  selectedHand = null;

  // 次は相手の手
  currentPlayer = (currentPlayer==='S') ? 'G' : 'S';
  onMoveFinishedSwitchTurn();

  renderBoard();
  updateTimerDisplay();
}

// 感想戦用の移動（履歴・棋譜は残さないが、感想戦でも交互に指せるようにする）
function attemptKansoMove(from, to){
  if(gameOver || !kansoMode) return;
  const piece = boardState[from.y][from.x]; if(!piece) return;
  // 感想戦でもその局面で指す側（currentPlayer）に合わせて操作を許可
  if(piece.owner !== currentPlayer) return;
  const legal = getLegalMoves(from.x, from.y); if(!legal.has(`${to.x},${to.y}`)) return;

  const canPromote = moveCanPromote(piece.owner, from.y, to.y, piece.type);
  const mustProm = mustAutoPromote(piece.type, piece.owner, to.y);

  let finalType = piece.type;
  if(mustProm){
    if(piece.type==='FU') finalType='TO';
    else if(piece.type==='KY') finalType='NY';
    else if(piece.type==='KE') finalType='NK';
  }else if(canPromote){
    const yes = window.confirm('成りますか？');
    if(yes){
      if(piece.type==='FU') finalType='TO';
      else if(piece.type==='KY') finalType='NY';
      else if(piece.type==='KE') finalType='NK';
      else if(piece.type==='GI') finalType='NG';
      else if(piece.type==='KA') finalType='UM';
      else if(piece.type==='HI') finalType='RY';
    }
  }
  performKansoMove(from, to, finalType);
}

function performKansoMove(from, to, finalPieceType){
  const piece = boardState[from.y][from.x];
  if(!piece) return;
  const dest = boardState[to.y][to.x];
  if(dest){
    if(dest.type==='OU'){
      // 玉取りでも感想戦では履歴は増やさず、駒を消す／移動するのみ
      boardState[to.y][to.x] = null;
      boardState[from.y][from.x] = null;
      selected = null; selectedHand = null;
      renderBoard();
      return;
    }else{
      const base = unpromote(dest.type);
      if(piece.owner==='S') handS.push(base); else handG.push(base);
    }
  }

  boardState[to.y][to.x] = { type: finalPieceType || piece.type, owner: piece.owner, initSide: piece.initSide };
  boardState[from.y][from.x] = null;
  selected = null; selectedHand = null;

  // 感想戦中でも交互に手番を変更する（期待値1）
  currentPlayer = (currentPlayer==='S') ? 'G' : 'S';
  onMoveFinishedSwitchTurn();

  renderBoard();
}

// 打ち（record=trueなら棋譜/履歴に記録、falseなら感想戦打ち：履歴は増やさない）
function dropFromHand(x,y, record=true){
  if(gameOver) return;
  if(!selectedHand) return;
  if(boardState[y][x]) return;

  // 所有者確認（選択された持ち駒の owner が currentPlayer と一致するか）
  if(selectedHand.owner !== currentPlayer){
    alert('その駒は現在の手番では使えません');
    selectedHand = null; renderBoard(); return;
  }

  const type = selectedHand.type;
  if(type==='FU'){
    if((currentPlayer==='S' && y===0) || (currentPlayer==='G' && y===8)){
      alert('行き所のない場所には歩は打てません'); selectedHand=null; renderBoard(); return;
    }
    if(checkDoublePawn(type, x, currentPlayer) && record){ alert('二歩は禁止です'); return; }
  }
  if(isUchifuzume(x,y,type) && record){ alert('打ち歩詰めは禁止です'); return; }

  // initSide は駒の所有者で決定
  boardState[y][x] = { type: type, owner: currentPlayer, initSide: (currentPlayer==='S' ? 'B' : 'T') };

  // 手駒から削除
  if(selectedHand.owner==='S'){
    if(typeof selectedHand.index==='number') handS.splice(selectedHand.index,1);
    else { const idx = handS.indexOf(type); if(idx>=0) handS.splice(idx,1); }
  }else{
    if(typeof selectedHand.index==='number') handG.splice(selectedHand.index,1);
    else { const idx = handG.indexOf(type); if(idx>=0) handG.splice(idx,1); }
  }

  if(record){
    kifu.push(`${currentPlayer==='S'?'▲':'△'}打${9-x}${y+1}${PIECE_SYMBOLS[type]||type}`);
    history.push({board: clone(boardState), handS: clone(handS), handG: clone(handG), mover: currentPlayer});
    historyIndex = history.length - 1;
    currentPlayer = (currentPlayer==='S') ? 'G' : 'S';
    onMoveFinishedSwitchTurn();
  }else{
    // 感想戦打ち：履歴追加しないが手番交代は行う（期待値1）
    currentPlayer = (currentPlayer==='S') ? 'G' : 'S';
    onMoveFinishedSwitchTurn();
  }

  selectedHand = null;
  renderBoard();
  updateTimerDisplay();
}

// ========== クリック処理 ==========
function cellClick(x,y){
  if(gameOver) return;
  const p = boardState[y][x];

  // 感想戦モード
  if(kansoMode){
    if(selectedHand && !p){ dropFromHand(x,y, false); return; }

    if(p){
      // その局面で指す側の手番（currentPlayer）に合わせて操作を許可
      if(p.owner !== currentPlayer) return;
      if(selected && selected.x===x && selected.y===y){ selected=null; renderBoard(); return; }
      selected = {x,y}; selectedHand=null; renderBoard(); return;
    }

    if(selected){
      const from = selected;
      selected = null;
      attemptKansoMove(from, {x,y});
      return;
    }
    return;
  }

  // 通常対局
  if(selectedHand && !p){ dropFromHand(x,y, true); return; }

  if(p && p.owner === currentPlayer){
    if(selected && selected.x===x && selected.y===y){ selected=null; renderBoard(); return; }
    selected = {x,y}; selectedHand=null; renderBoard(); return;
  }

  if(selected){
    const from = selected;
    selected = null;
    attemptMove(from, {x,y});
    renderBoard();
    return;
  }
}

// ========== 局面ジャンプ ==========
function jumpToHistory(idx){
  historyIndex = Math.max(0, Math.min(idx, history.length-1));
  const snap = history[historyIndex];
  boardState = clone(snap.board);
  handS = clone(snap.handS);
  handG = clone(snap.handG);
  // snap.mover が null の場合は初期局面（次に指すのは mySide）
  if(snap.mover === null){
    currentPlayer = mySide;
  }else{
    // snap.mover は最後に指したプレイヤーなので、次に指すのはその逆
    currentPlayer = (snap.mover === 'S') ? 'G' : 'S';
  }
  selected = null; selectedHand = null;
  renderBoard();
  updateTimerDisplay();
}

// ========== リセット / イベント ==========
function resetGameCore(){
  initialBoard = createInitialBoard();
  boardState = clone(initialBoard);
  selected = null; selectedHand = null;
  handS = []; handG = [];
  kifu = []; history = [{board: clone(boardState), handS:[], handG:[], mover: null}]; 
  historyIndex = 0;
  currentPlayer = mySide;
  kansoMode = false; gameOver = false;

  readTimeSettings();
  stopTick();
  startTick();

  document.getElementById('kansoControls').classList.add('hidden');
  kifuPanelEl.style.display = 'none';
  document.getElementById('toggleKanso').textContent = '感想戦へ';

  // 投了ボタンは対局モードのみ表示
  resignBtn.classList.remove('hidden');

  // 盤反転はローカル設定を尊重
  boardEl.classList.toggle('flipped', boardFlipped);

  renderBoard();
  updateTimerDisplay();
}

function resetGame(){
  mySide = document.getElementById('mySide').value;
  resetGameCore();
}

document.getElementById('mySide').addEventListener('change', e => { mySide = e.target.value; resetGame(); });

document.getElementById('toggleKanso').addEventListener('click', ()=>{
  kansoMode = !kansoMode;
  document.getElementById('toggleKanso').textContent = kansoMode ? '対局へ' : '感想戦へ';
  document.getElementById('prev').classList.toggle('hidden', !kansoMode);
  document.getElementById('next').classList.toggle('hidden', !kansoMode);
  kansoControlsEl.classList.toggle('hidden', !kansoMode);
  kifuPanelEl.style.display = kansoMode ? 'block' : 'none';
  if(kansoMode) renderKifuList();
  if(kansoMode){ 
    stopTick(); 
    // 感想戦中は投了ボタンを隠す（投了は対局中のみ）
    resignBtn.classList.add('hidden');
  }
  else { 
    if(!gameOver) startTick(); 
    resignBtn.classList.remove('hidden');
  }
});

document.getElementById('prev').addEventListener('click', ()=>{
  if(!kansoMode) return;
  if(historyIndex>0){ historyIndex--; jumpToHistory(historyIndex); }
});
document.getElementById('next').addEventListener('click', ()=>{
  if(!kansoMode) return;
  if(historyIndex < history.length-1){ historyIndex++; jumpToHistory(historyIndex); }
});

document.getElementById('copyKif').addEventListener('click', ()=>{
  const head = `先手：先手\n後手：後手\n手合割：平手\n開始日時：${new Date().toLocaleString()}\n\n`;
  const body = kifu.map((m,i)=>`${i+1} ${m}`).join('\n');
  const tail = `\nまで${kifu.length}手`;
  navigator.clipboard.writeText(head+body+tail).then(()=>alert('日本語棋譜をコピーしました'));
});

// 盤反転（盤のみ rotate(180deg)）— ローカルのみ保持
document.getElementById('flipBoard').addEventListener('click', ()=>{
  boardFlipped = !boardFlipped;
  localStorage.setItem('boardFlipped', boardFlipped ? '1' : '0');
  boardEl.classList.toggle('flipped', boardFlipped);
  renderBoard();
});

// 投了ボタン（対局モードのみ有効）
// 押下時に Confirm を表示し、「どちらが負けになるか」を明示する
resignBtn.addEventListener('click', ()=>{
  if(kansoMode || gameOver) return;
  const sideLabel = currentPlayer==='S' ? '先手' : '後手';
  const ok = confirm(`${sideLabel}（現在の手番）が投了すると、${sideLabel}の負けになります。\n本当に投了しますか？`);
  if(!ok) return;
  // 投了確定
  gameOver = true;
  stopTick();
  alert(`${sideLabel}の投了により${sideLabel}の負けです。`);
  // 必要ならここで履歴やUIロックを追加できます
});

// ========== 起動 ==========
document.addEventListener('DOMContentLoaded', () => {
  // ローカル保存された反転状態を復元
  boardFlipped = localStorage.getItem('boardFlipped') === '1';

  createBoardCells();
  readTimeSettings();
  resetGameCore(); // reset 内で boardFlipped を尊重して反映
});
</script>
</body>
</html>
