<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>遠タメ将棋 Online</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
  <style>
    :root { 
      --board-color: #edc9af; 
      --primary-btn: #2196f3; 
      --danger-btn: #d32f2f; 
      --select-color: #ff9800;
      --call-btn: #4caf50;
    }
    body { 
  font-family: sans-serif; 
  display: flex; 
  flex-direction: column; 
  align-items: center; 
  background: #eee; 
  margin: 0; 
  padding: 2px; 
  /* overflow-x: hidden; を削除し、必要に応じてスクロール可能にする */
  touch-action: manipulation; 
}

#game-main { 
  display: flex; 
  flex-direction: row; 
  justify-content: center;     /* 中央寄せ */
  align-items: flex-start; 
  width: 100%;
  max-width: 100vw;            /* 画面幅を絶対超えない */
  gap: 2px;                    /* 隙間を最小限に */
  margin: 0 auto;
  overflow: hidden;            /* スクロールを禁止 */
  padding: 5px 2px;
  box-sizing: border-box;
}

    #board-container { position: relative; width: 58vw; max-width: 380px; aspect-ratio: 1 / 1; flex-shrink: 1; }
    #board { display: grid; grid-template-columns: repeat(9, 11.1111%); grid-template-rows: repeat(9, 11.1111%); border: 1px solid #222; width: 100%; height: 100%; background: var(--board-color); box-sizing: border-box; }
    
    /* --- 左右に配置する駒台（2列×10行） --- */
    .hand { 
      width: 38px;               /* 幅を縮小 */
      height: 58vw;              /* 盤面の新しい幅(58vw)に合わせる */
      max-height: 380px; 
      border: 1px solid #999; 
      background: #fff; 
      display: flex; 
      flex-direction: column; 
      flex-wrap: wrap; 
      align-content: flex-start; 
      padding: 14px 2px 2px 2px; /* パディングも微調整 */
      gap: 2px; 
      border-radius: 3px; 
      position: relative; 
      box-sizing: border-box;
      flex-shrink: 0;
    }
    .hand::before { content: attr(data-label); position: absolute; top: 1px; left: 0; width: 100%; text-align: center; font-size: 9px; font-weight: bold; color: #333; }
    
    /* 駒：10行に収まるサイズに自動調整 */
    .hand span { 
      width: 16px;               /* 19pxから3px縮小 */
      height: calc((100% - 18px) / 10); 
      border: 1px solid #777; 
      background: #f0f0f0; 
      display: inline-flex; 
      align-items: center; 
      justify-content: center; 
      font-size: 10px;           /* 文字も少し小さく */
      box-sizing: border-box;
      flex-shrink: 0;
      cursor: pointer;
    }
    .hand span.selected-piece { background: var(--select-color) !important; color: white; border-color: #e68a00; }

    /* 棋譜パネル：先手駒台のさらに右側に配置 */
    #review-panel { display: none; width: 75px; height: 58vw; max-height: 380px; background: #fff; border: 1px solid #999; border-radius: 2px; flex-direction: column; box-sizing: border-box; flex-shrink: 0; }

    /* その他パーツのスタイル（以前のものを維持） */
    .cell { display: flex; align-items: center; justify-content: center; border: 0.5px solid rgba(0,0,0,0.2); box-sizing: border-box; width: 100%; height: 100%; }
    .selected { background: var(--select-color) !important; box-shadow: inset 0 0 5px rgba(0,0,0,0.3); }
    .piece-font { font-weight: bold; font-size: 4.5vw; line-height: 1; }
    @media (min-width: 500px) { .piece-font { font-size: 22px; } }
    .piece { 
  z-index: 10; 
  pointer-events: none; 
  display: flex;             /* 中央揃えを確実にする */
  align-items: center; 
  justify-content: center; 
}
    .piece.opposite { transform: rotate(180deg); }
    .piece.promoted { color: var(--danger-btn); }
    .kifu-list { flex-grow: 1; overflow-y: scroll; background: #fafafa; font-size: 9px; padding: 0; margin: 0; }
    .kifu-item { padding: 5px 1px; cursor: pointer; border-bottom: 1px solid #eee; text-align: center; white-space: nowrap; }
    .kifu-item.active { background: var(--primary-btn); color: white; }
    .nav-controls { display: grid; grid-template-columns: 1fr 1fr; background: #ddd; gap: 1px; padding: 1px; }
    .nav-btn { font-size: 9px; padding: 7px 0; border: 1px solid #bbb; background: #fff; cursor: pointer; font-weight: bold; }
    #nav-pos { grid-column: span 2; font-size: 9px; text-align: center; background: #eee; padding: 2px 0; border-bottom: solid 1px #ccc; }
    .controls { display: flex; gap: 2px; margin-bottom: 4px; flex-wrap: wrap; justify-content: center; background: #ddd; padding: 4px; border-radius: 4px; width: 98%; box-sizing: border-box; }
    button { cursor: pointer; border: none; border-radius: 3px; font-weight: bold; padding: 5px 6px; font-size: 11px; }
    button:disabled { background: #bbb !important; opacity: 0.6; cursor: not-allowed; }
    #btnReset { background: var(--danger-btn); color: white; }
    #btnToggleReview { background: var(--primary-btn); color: white; }
    .status-area { display: flex; gap: 4px; margin-bottom: 4px; width: 100%; justify-content: center; }
    .timer { font-family: monospace; font-size: 14px; font-weight: bold; background: #fff; padding: 2px 4px; border: 1px solid #555; border-radius: 3px; min-width: 70px; text-align: center; }
    .your-turn { border-color: var(--danger-btn); background: #ffebee; }
    .timer-alert { color: var(--danger-btn) !important; }
    #promote-dialog { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border: 4px solid #5d4037; z-index: 2000; text-align: center; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); min-width: 160px; }
    .call-area { display: flex; flex-wrap: wrap; gap: 4px; margin: 4px 0; background: #fff; padding: 5px; border-radius: 5px; border: 1px solid #ccc; align-items: center; justify-content: center; width: 98%; box-sizing: border-box; }
    #btnCallStart { background: var(--call-btn); color: white; }
    #btnMute { background: #757575; color: white; }
    #btnCallEnd { background: var(--danger-btn); color: white; }
    #callStatusDisplay { font-size: 10px; color: #333; font-weight: bold; }
    .vol-ctrl { font-size: 10px; display: flex; align-items: center; gap: 2px; }
    .chat-message { margin-bottom: 4px; line-height: 1.4; border-bottom: 1px dotted #eee; padding-bottom: 2px; font-size: 12px;}
    .chat-name { font-weight: bold; margin-right: 5px; }
    .chat-name.S { color: #1976d2; }
    .chat-name.G { color: #d32f2f; }
/* 相手側の持ち駒を上下反転させる */
.hand.opponent {
  transform: rotate(180deg);
}

  </style>
</head>
<body>

<h1>遠タメ将棋 Online</h1>

<div class="controls">
  <div style="font-size:10px; margin-bottom:2px; width:100%; text-align:center;">
    持時:<select id="cfgMain" style="font-size:10px;"><option value="0">0分</option><option value="10" selected>10分</option><option value="15">15分</option><option value="30">30分</option></select>
    / 秒読:<select id="cfgByo" style="font-size:10px;"><option value="30" selected>30秒</option><option value="60">60秒</option></select>
    <button id="btnReset">初期化</button>
    <button id="btnFlip">反転</button>
    <button id="btnToggleReview" disabled>感想戦</button>
    <button id="btnResign">投了</button>
  </div>
  <select id="mySideSelect" style="font-size:10px;"><option value="S">先手▲</option><option value="G">後手△</option></select>
  <div id="status-txt" style="font-size:11px; font-weight:bold; margin-left:10px;">接続待ち...</div>
</div>

<div class="call-area">
  <button id="btnCallStart">通話開始</button>
  <button id="btnMute" disabled>ミュート</button>
  <button id="btnCallEnd" disabled>通話終了</button>
  <div class="vol-ctrl">
    音量:<input type="range" id="volume-control" min="0" max="1" step="0.1" value="1" style="width:50px;">
  </div>
  <span id="callStatusDisplay">オフライン</span>
</div>

<div class="status-area">
  <div id="timer-S" class="timer">▲ --:--</div>
  <div id="timer-G" class="timer">△ --:--</div>
</div>

<div id="game-main">
  <div class="hand" id="handG" data-label="△後手"></div>

  <div id="board-container">
    <div id="board"></div>
    <div id="promote-dialog">
      <div style="margin-bottom:15px; font-weight:bold; font-size:16px;">成りますか？</div>
      <div style="display: flex; gap: 15px; justify-content: center;">
        <button id="btn-prom-yes" style="background:var(--danger-btn); color:white; padding: 12px 20px; font-size: 16px;">成る</button>
        <button id="btn-prom-no" style="background:#757575; color:white; padding: 12px 20px; font-size: 16px;">不成</button>
      </div>
    </div>
  </div>

  <div class="hand" id="handS" data-label="▲先手"></div>

  <div id="review-panel">
    <div id="nav-pos">0/0</div>
    <div id="kifu-container" class="kifu-list"></div>
    <div class="nav-controls">
      <button id="nav-prev" class="nav-btn">＜ 前</button>
      <button id="nav-next" class="nav-btn">次 ＞</button>
      <button id="nav-first" class="nav-btn">《 最初</button>
      <button id="nav-last" class="nav-btn">最後 》</button>
      <button id="btnKif" class="nav-btn" style="grid-column: span 2; background: #4caf50; color: white;">KIF</button>
    </div>
  </div>
</div>

<div id="chat-container" style="width: 95%; max-width: 500px; margin: 10px auto; background: #fff; border: 1px solid #ccc; border-radius: 5px; box-sizing: border-box;">
  <div id="chatLog" style="height: 120px; overflow-y: auto; padding: 5px; background: #fafafa;"></div>
  <div style="display: flex; padding: 5px; gap: 5px;">
    <input type="text" id="chatInput" placeholder="メッセージを入力..." style="flex: 1; padding: 5px;">
    <button id="btnSend" style="background: var(--primary-btn); color: white;">送信</button>
    <button id="btnClearChat" style="background: var(--danger-btn); color: white;">削除</button>
  </div>
</div>

<audio id="remote-audio" autoplay></audio>
<audio id="localAudio" autoplay muted style="display:none;"></audio>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import { getDatabase, ref, set, onValue, push, remove, update, get } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

  const firebaseConfig = {
      apiKey: "AIzaSyCx5anv3WWOQyke9kqhhZ9Zx-RjynLuxzE",
      authDomain: "calendar-chousei.firebaseapp.com",
      databaseURL: "https://calendar-chousei-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "calendar-chousei",
      storageBucket: "calendar-chousei.firebasestorage.app",
      messagingSenderId: "368704703397",
      appId: "1:368704703397:web:86ae24d920aaf7c5a0f64c"
  };
  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  
  const params = new URLSearchParams(location.search);
  const roomName = params.get('room') || "default_room";
  const gameRef = ref(db, `${roomName}/shogiData`);
  const reviewRef = ref(db, `${roomName}/reviewData`);
  const callStatusRef = ref(db, `${roomName}/callStatus`);
  const signalingRef = ref(db, `${roomName}/signaling`);

  const SYMBOLS = {FU:'歩',KY:'香',KE:'桂',GI:'銀',KI:'金',KA:'角',HI:'飛',OU:'玉',TO:'と',NY:'杏',NK:'圭',NG:'全',UM:'馬',RY:'龍'};
  const PROMOTE_MAP = {FU:'TO',KY:'NY',KE:'NK',GI:'NG',KA:'UM',HI:'RY'};
  const UNPROMOTE_MAP = {TO:'FU',NY:'KY',NK:'KE',NG:'GI',UM:'KA',RY:'HI'};
  const KANJI_NUM = ["","一","二","三","四","五","六","七","八","九"];
  const ZEN_NUM = ["","１","２","３","４","５","６","７","８","９"];

  let state = { board: "[]", handS: [], handG: [], turn: 'S', timers: {S: 600, G: 600}, config: {main: 600, byo: 30}, lastTick: 0, history: [], winner: null, winReason: "" };
  let sel = null, selH = null, possibleMoves = [], pendingProm = null;
  let isReviewMode = sessionStorage.getItem(`isReview_${roomName}`) === "true";
  let viewIdx = -1, rvState = null;

  let mySide = sessionStorage.getItem(`mySide_${roomName}`) || 'S';
  const mySideSelect = document.getElementById('mySideSelect');
  const boardEl = document.getElementById('board');
  mySideSelect.value = mySide;
  boardEl.style.transform = (mySide === 'G') ? 'rotate(180deg)' : 'rotate(0deg)';
  updateHandOrientation();

  mySideSelect.onchange = (e) => { 
    mySide = e.target.value; 
    sessionStorage.setItem(`mySide_${roomName}`, mySide);
    boardEl.style.transform = (mySide === 'G') ? 'rotate(180deg)' : 'rotate(0deg)'; 
    updateHandOrientation();
    window.location.reload();
  };

  // --- 通話維持用（バックグラウンド対策強化版） ---
  let wakeLock = null;
  let silenceAudio = null;
  let audioCtx = null;
  const silenceData = "data:audio/wav;base64,UklGRigAAABXQVZFRm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==";

  async function startKeepAlive() {
    try {
      if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen');
      
      if (!silenceAudio) { 
        silenceAudio = new Audio(silenceData); 
        silenceAudio.loop = true; 
        silenceAudio.volume = 0.01; 
      }
      await silenceAudio.play();

      if (!audioCtx) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
        const buffer = audioCtx.createBuffer(1, 1, 22050);
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        source.connect(audioCtx.destination);
        source.start();
        audioCtx.onstatechange = () => {
          if (audioCtx.state === 'suspended' && localCallStartPressed) audioCtx.resume();
        };
      }
      if (audioCtx.state === 'suspended') await audioCtx.resume();
    } catch (err) { console.warn("Keep-alive Error:", err); }
  }

  function stopKeepAlive() {
    if (wakeLock) { try { wakeLock.release(); } catch(e){} wakeLock = null; }
    if (silenceAudio) { silenceAudio.pause(); }
    if (audioCtx) { try { audioCtx.close(); } catch(e){} audioCtx = null; }
  }

  document.addEventListener('visibilitychange', async () => {
    if (document.visibilityState === 'visible' && localCallStartPressed) {
      if ('wakeLock' in navigator && !wakeLock) {
        try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e){}
      }
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    }
  });

  // --- WebRTC / 通話機能（ICE Restart統合） ---
  let localStream = null, peerConnection = null, localCallStartPressed = false, isMuted = false;
  const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
  const btnCallStart = document.getElementById('btnCallStart'), btnCallEnd = document.getElementById('btnCallEnd'), btnMute = document.getElementById('btnMute'), callStatusDisplay = document.getElementById('callStatusDisplay'), volumeControl = document.getElementById('volume-control');

  volumeControl.addEventListener('input', () => { const ra = document.getElementById('remote-audio'); if (ra) ra.volume = parseFloat(volumeControl.value); });
  btnMute.onclick = () => { if (!localStream) return; isMuted = !isMuted; localStream.getAudioTracks().forEach(t => t.enabled = !isMuted); btnMute.textContent = isMuted ? '解除' : 'ミュート'; btnMute.style.background = isMuted ? "var(--danger-btn)" : "#757575"; };

  async function startLocalStream() { 
    if (localStream) localStream.getTracks().forEach(t => t.stop()); 
    localStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }, video: false }); 
    return localStream; 
  }

  function createPeerConnection() {
    if (peerConnection && peerConnection.signalingState !== 'closed') return;
    peerConnection = new RTCPeerConnection(configuration);
    
    // ICE接続状態の監視（自動再接続用）
    peerConnection.oniceconnectionstatechange = () => {
      const state = peerConnection.iceConnectionState;
      console.log("ICE Connection:", state);
      if (state === "failed" || state === "disconnected") handleIceRestart();
    };

    peerConnection.ontrack = e => { const ra = document.getElementById('remote-audio'); if (ra) ra.srcObject = e.streams[0]; };
    if (localStream) localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
    peerConnection.onicecandidate = e => { if (e.candidate) push(ref(db, `${roomName}/signaling/candidates/${mySide}`), { candidate: e.candidate.toJSON() }); };
  }

  async function sendOffer() { 
    createPeerConnection(); 
    const offer = await peerConnection.createOffer(); 
    await peerConnection.setLocalDescription(offer); 
    await set(ref(db, `${roomName}/signaling/offer`), { sdp: offer.sdp, type: offer.type, from: mySide }); 
  }

  async function sendAnswer() { 
    const snap = await get(ref(db, `${roomName}/signaling/offer`)); 
    if (!snap.exists()) return; 
    const offer = snap.val(); 
    createPeerConnection(); 
    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer)); 
    const answer = await peerConnection.createAnswer(); 
    await peerConnection.setLocalDescription(answer); 
    await set(ref(db, `${roomName}/signaling/answer`), { sdp: answer.sdp, type: answer.type, from: mySide }); 
  }

  async function handleIceRestart() {
    if (!peerConnection || peerConnection.signalingState === 'closed') return;
    try {
      const offer = await peerConnection.createOffer({ iceRestart: true });
      await peerConnection.setLocalDescription(offer);
      await set(ref(db, `${roomName}/signaling/offer`), { sdp: offer.sdp, type: offer.type, from: mySide, isRestart: true });
    } catch (e) { console.error("Restart ICE failed:", e); }
  }

  btnCallStart.onclick = async () => { 
    btnCallStart.disabled = true; 
    try { 
      await startKeepAlive(); 
      await startLocalStream(); 
      createPeerConnection(); 
      const snap = await get(callStatusRef); 
      const callData = snap.exists() ? snap.val() : { status: 'none', users: { S: false, G: false } }; 
      if (!callData.users) callData.users = { S: false, G: false }; 
      callData.users[mySide] = true; 
      let newStatus = 'waiting'; 
      if (callData.users.S && callData.users.G) { newStatus = 'started'; await sendOffer(); } 
      await update(callStatusRef, { status: newStatus, users: callData.users, timestamp: new Date().toISOString() }); 
      localCallStartPressed = true; 
      updateCallUI(); 
    } catch (e) { btnCallStart.disabled = false; stopKeepAlive(); } 
  };

  btnCallEnd.onclick = async () => { 
    await update(callStatusRef, { status: 'ended', users: { S: false, G: false } }); 
    handleCallEndInternal(); 
  };

  function handleCallEndInternal() { 
    localCallStartPressed = false; 
    stopKeepAlive(); 
    if (peerConnection) { peerConnection.close(); peerConnection = null; } 
    if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; } 
    remove(signalingRef); 
    updateCallUI(); 
    if (!sessionStorage.getItem(`reloaded_${roomName}`)) { 
      sessionStorage.setItem(`reloaded_${roomName}`, '1'); 
      window.location.reload(); 
    } 
  }

  function updateCallUI() { 
    btnCallStart.disabled = localCallStartPressed; 
    btnCallEnd.disabled = !localCallStartPressed; 
    btnMute.disabled = !localCallStartPressed; 
  }

  onValue(callStatusRef, (snap) => { 
    const data = snap.val(); 
    if (!data) return; 
    if (data.status === 'ended' && localCallStartPressed) { handleCallEndInternal(); return; } 
    const iPressed = !!data.users?.[mySide]; 
    localCallStartPressed = iPressed; 
    updateCallUI(); 
    if (data.status === 'started') callStatusDisplay.textContent = "通話中"; 
    else if (data.status === 'waiting') callStatusDisplay.textContent = iPressed ? "相手の応答待ち..." : "相手が通話を呼んでいます"; 
    else { callStatusDisplay.textContent = "オフライン"; sessionStorage.removeItem(`reloaded_${roomName}`); } 
  });

  onValue(ref(db, `${roomName}/signaling/offer`), snap => { const offer = snap.val(); if (offer && offer.from !== mySide) sendAnswer(); });
  onValue(ref(db, `${roomName}/signaling/answer`), async snap => { const answer = snap.val(); if (answer && answer.from !== mySide && peerConnection) await peerConnection.setRemoteDescription(new RTCSessionDescription(answer)); });
  onValue(ref(db, `${roomName}/signaling/candidates/S`), snap => { if (mySide === 'G' && peerConnection && snap.exists()) Object.values(snap.val()).forEach(d => peerConnection.addIceCandidate(new RTCIceCandidate(d.candidate))); });
  onValue(ref(db, `${roomName}/signaling/candidates/G`), snap => { if (mySide === 'S' && peerConnection && snap.exists()) Object.values(snap.val()).forEach(d => peerConnection.addIceCandidate(new RTCIceCandidate(d.candidate))); });

  // --- Firebase 将棋データ監視 ---
  onValue(gameRef, (snap) => {
    const data = snap.val();
    if (!data) return;
    if (!data.winner) {
        isReviewMode = false;
        sessionStorage.setItem(`isReview_${roomName}`, "false");
        document.getElementById('btnToggleReview').textContent = "感想戦";
        document.getElementById('review-panel').style.display = 'none';
        document.getElementById('btnToggleReview').disabled = true;
    } else {
        document.getElementById('btnToggleReview').disabled = false;
    }
    state.board = JSON.parse(data.board);
    state.handS = data.handS || [];
    state.handG = data.handG || [];
    state.turn = data.turn || 'S';
    state.timers = data.timers || {S:600, G:600};
    state.config = data.config || {main:600, byo:30};
    state.lastTick = data.lastTick || 0;
    state.winner = data.winner || null;
    state.winReason = data.winReason || "";
    state.history = data.history || [];
    if (state.winner) showGameOverPopup(state.winner, state.winReason || "");
    if (!isReviewMode) { 
        viewIdx = state.history.length - 1; 
        syncReviewStateLocally(); 
    }
    render(); 
    updateKifuList();
  });

  onValue(reviewRef, (snap) => {
    if (!isReviewMode) return;
    const data = snap.val();
    if (data) {
        viewIdx = data.viewIdx;
        rvState = { board: JSON.parse(data.board), handS: data.handS || [], handG: data.handG || [] };
        render();
        updateKifuList();
    }
  });
  
  // --- チャット機能の追加 ---
  const chatLog = document.getElementById('chatLog');
  const chatInput = document.getElementById('chatInput');
  const btnSend = document.getElementById('btnSend');
  const btnClearChat = document.getElementById('btnClearChat'); // 消去ボタンを取得

  // 送信処理
  btnSend.onclick = async () => {
    const text = chatInput.value.trim();
    if (!text) return;
    const snap = await get(ref(db, `${roomName}/chatLog`));
    const logs = snap.val() || [];
    const senderName = (mySide === 'S') ? "先手" : "後手";
    logs.push({ 
      user: mySide, 
      name: senderName, 
      text: text, 
      time: new Date().toISOString() 
    });
    await set(ref(db, `${roomName}/chatLog`), logs);
    chatInput.value = '';
  };

  // チャット履歴の全削除（Firebase上のデータを消去）
  btnClearChat.onclick = async () => {
    if (confirm("チャットの履歴をすべて削除してもよろしいですか？")) {
      await remove(ref(db, `${roomName}/chatLog`));
    }
  };

  // エンターキー送信対応
  chatInput.onkeydown = (e) => { if(e.key === 'Enter') btnSend.click(); };

  // ログの監視と表示
  onValue(ref(db, `${roomName}/chatLog`), (snap) => {
    const logs = snap.val() || [];
    chatLog.innerHTML = '';
    logs.slice(-50).forEach(msg => {
      const div = document.createElement('div');
      div.className = 'chat-message';
      div.innerHTML = `<span class="chat-name ${msg.user}">${msg.name}:</span><span>${msg.text}</span>`;
      chatLog.appendChild(div);
    });
    chatLog.scrollTop = chatLog.scrollHeight;
  });

  // --- 将棋 UI / ロジック ---
  function setReviewMode(bool) {
    isReviewMode = bool;
    sessionStorage.setItem(`isReview_${roomName}`, bool.toString());
    document.getElementById('btnToggleReview').textContent = bool ? "戻る" : "感想戦";
    document.getElementById('review-panel').style.display = bool ? 'flex' : 'none';
    if (bool) pushReviewUpdate();
  }

  const cells = [];
  for (let y = 0; y < 9; y++) {
    cells[y] = [];
    for (let x = 0; x < 9; x++) {
      const c = document.createElement('div');
      c.className = 'cell';
      c.onclick = () => handleCellClick(x, y);
      boardEl.appendChild(c);
      cells[y][x] = c;
    }
  }

  function pushReviewUpdate() {
    if (!isReviewMode) return;
    set(reviewRef, { viewIdx: viewIdx, board: JSON.stringify(rvState.board), handS: rvState.handS || [], handG: rvState.handG || [], timestamp: Date.now() });
  }

  function finish(moveData) {
    const now = Date.now();
    if (state.lastTick !== 0) {
      const elapsed = Math.floor((now - state.lastTick) / 1000);
      if (state.timers[state.turn] > 0) state.timers[state.turn] = Math.max(0, state.timers[state.turn] - elapsed);
    }
    state.lastTick = now;
    let foulReason = "";
    if (isChecked(state.board, state.turn)) { foulReason = "王手放置"; }
    else if (moveData.isDrop && moveData.type === 'FU') {
      let count = 0;
      for (let y = 0; y < 9; y++) if (state.board[y][moveData.toX]?.type === 'FU' && state.board[y][moveData.toX]?.owner === state.turn) count++;
      if (count > 1) foulReason = "二歩";
    }
    if (foulReason) {
      state.winner = (state.turn === 'S' ? 'G' : 'S');
      state.winReason = foulReason;
      state.history.push({ ...moveData, board: JSON.stringify(state.board), handS: [...(state.handS || [])], handG: [...(state.handG || [])], type: moveData.type + "(反則)" });
    } else {
      const nextTurn = (state.turn === 'S' ? 'G' : 'S');
      if (state.history.length > 2 && isCheckmate(state.board, nextTurn, state.handS, state.handG)) { state.winner = state.turn; state.winReason = "詰み"; }
      state.turn = nextTurn;
      state.history.push({ ...moveData, board: JSON.stringify(state.board), handS: [...(state.handS || [])], handG: [...(state.handG || [])] });
    }
    sel = null; selH = null; possibleMoves = [];
        sel = null; selH = null; possibleMoves = [];
    // updateを使用し、タイムスタンプを付与することで同期の確実性を高めます
    update(gameRef, { 
      board: JSON.stringify(state.board), 
      handS: state.handS || [], 
      handG: state.handG || [], 
      turn: state.turn, 
      timers: state.timers, 
      config: state.config, 
      lastTick: state.lastTick, 
      winner: state.winner || null, 
      winReason: state.winReason || "", 
      history: state.history,
      updatedAt: Date.now() // 更新時間を混ぜることで強制的に同期を走らせる
    });
  }

  const isChecked = (board, owner) => {
    let kx = -1, ky = -1;
    for(let y=0; y<9; y++) for(let x=0; x<9; x++) if(board[y][x]?.type==='OU' && board[y][x]?.owner===owner) { kx=x; ky=y; break; }
    if (kx === -1) return false;
    const enemy = (owner === 'S' ? 'G' : 'S');
    for(let y=0; y<9; y++) for(let x=0; x<9; x++) if(board[y][x]?.owner === enemy) if(getRawMoves(x, y, board, enemy).some(m => m.x===kx && m.y===ky)) return true;
    return false;
  };

  function showGameOverPopup(winner, reason = "") {
    const key = `shown_${roomName}_${state.history.length}`;
    if (sessionStorage.getItem(key)) return;
    sessionStorage.setItem(key, "true");
    setReviewMode(true);
    syncReviewStateLocally(); 
    pushReviewUpdate();
    setTimeout(() => { alert((reason ? `${reason}により、` : "") + (winner === 'S' ? '先手▲' : '後手△') + "の勝ちです！"); }, 200);
  }

  document.getElementById('btnReset').onclick = () => {
    if(!confirm("初期化しますか？")) return;
    Object.keys(sessionStorage).forEach(k => { if(k.startsWith("shown_") || k.startsWith("isReview_")) sessionStorage.removeItem(k); });
    setReviewMode(false);
    remove(reviewRef);
    const m = (parseInt(document.getElementById('cfgMain').value) || 0) * 60, b = (parseInt(document.getElementById('cfgByo').value) || 30);
    const board = Array(9).fill(null).map(() => Array(9).fill(null));
    const setup = (y, o, ps) => ps.forEach((p, x) => { if (p) board[y][x] = { type: p, owner: o } });
    setup(0,'G',['KY','KE','GI','KI','OU','KI','GI','KE','KY']); board[1][1]={type:'HI',owner:'G'}; board[1][7]={type:'KA',owner:'G'}; setup(2,'G',Array(9).fill('FU'));
    setup(6,'S',Array(9).fill('FU')); board[7][1]={type:'KA',owner:'S'}; board[7][7]={type:'HI',owner:'S'}; setup(8,'S',['KY','KE','GI','KI','OU','KI','GI','KE','KY']);
    const bStr = JSON.stringify(board);
    set(gameRef, { board: bStr, handS: [], handG: [], turn: 'S', timers: {S: m, G: m}, config: {main: m, byo: b}, lastTick: 0, winner: null, winReason: "", history: [{ board: bStr, handS: [], handG: [], type: '開始' }] });
  };
  
  function syncReviewStateLocally() { 
    if (viewIdx < 0 || viewIdx >= state.history.length) viewIdx = state.history.length - 1; 
    const hist = state.history[viewIdx]; 
    rvState = { board: JSON.parse(hist.board), handS: [...(hist.handS || [])], handG: [...(hist.handG || [])] }; 
    sel = null; selH = null; possibleMoves = []; 
  }

  function handleCellClick(x, y) {
    if (isReviewMode) {
      const target = rvState.board[y][x];
      if (sel && sel.x === x && sel.y === y) { sel = null; possibleMoves = []; render(); return; }
      if (sel && possibleMoves.some(m => m.x === x && m.y === y)) {
        const fromP = rvState.board[sel.y][sel.x];
        if (target && target.owner !== fromP.owner) (fromP.owner === 'S' ? rvState.handS : rvState.handG).push(UNPROMOTE_MAP[target.type] || target.type);
        rvState.board[y][x] = { type: fromP.type, owner: fromP.owner }; rvState.board[sel.y][sel.x] = null;
        const promLine = (fromP.owner === 'S') ? [0,1,2] : [6,7,8];
        if (PROMOTE_MAP[fromP.type] && (promLine.includes(y) || promLine.includes(sel.y))) if(confirm("成りますか？")) rvState.board[y][x].type = PROMOTE_MAP[fromP.type];
        sel = null; possibleMoves = []; 
        pushReviewUpdate();
        render(); 
        return;
      }
      if (selH) { 
        if (!target) { 
            rvState.board[y][x] = { type: selH.type, owner: selH.owner }; 
            (selH.owner === 'S' ? rvState.handS : rvState.handG).splice(selH.idx, 1); 
            selH = null; pushReviewUpdate(); render(); 
        } else { selH = null; render(); } 
        return; 
      }
      if (target) { sel = { x, y }; possibleMoves = getRawMoves(x, y, rvState.board, target.owner); render(); }
      return;
    }
    if (state.winner || state.turn !== mySide || pendingProm) return;
    const target = state.board[y][x];
    if (sel && sel.x === x && sel.y === y) { sel = null; possibleMoves = []; render(); return; }
    if (sel && possibleMoves.some(m => m.x === x && m.y === y)) {
      const fromP = state.board[sel.y][sel.x];
      if (target && target.owner !== mySide) { const h = (mySide === 'S' ? state.handS : state.handG) || []; h.push(UNPROMOTE_MAP[target.type] || target.type); if (mySide === 'S') state.handS = h; else state.handG = h; }
      const moveData = { side: mySide, fromX: sel.x, fromY: sel.y, toX: x, toY: y, type: fromP.type, isDrop: false, isPromoted: false };
      state.board[y][x] = { type: fromP.type, owner: mySide }; state.board[sel.y][sel.x] = null;
      const promLine = (mySide === 'S') ? [0,1,2] : [6,7,8];
      if (PROMOTE_MAP[fromP.type] && (promLine.includes(y) || promLine.includes(sel.y))) {
        const deadLine = (mySide === 'S') ? 0 : 8;
        if (((fromP.type === 'FU' || fromP.type === 'KY') && y === deadLine) || (fromP.type === 'KE' && (mySide==='S' ? y<=1 : y>=7))) { state.board[y][x].type = PROMOTE_MAP[fromP.type]; moveData.type = PROMOTE_MAP[fromP.type]; moveData.isPromoted = true; finish(moveData); } 
        else { pendingProm = { x, y, moveData }; document.getElementById('promote-dialog').style.display = 'block'; render(); }
      } else { finish(moveData); }
      return;
    }
    if (selH) { if (!target) { state.board[y][x] = { type: selH.type, owner: mySide }; (mySide === 'S' ? state.handS : state.handG).splice(selH.idx, 1); finish({ side: mySide, toX: x, toY: y, type: selH.type, isDrop: true }); } else { selH = null; render(); } return; }
    if (target && target.owner === mySide) { sel = { x, y }; possibleMoves = getRawMoves(x, y, state.board, mySide); render(); }
  }

  function render() {
  // 感想戦モードでデータが未定義なら、強制的に同期させる
  if (isReviewMode && !rvState) {
    if (state.history && state.history.length > 0) {
      syncReviewStateLocally();
    } else {
      return; // 描画可能なデータがなければ中断
    }
  }

  let b, hs, hg;
  if (isReviewMode) { 
    b = rvState.board; 
    hs = rvState.handS; 
    hg = rvState.handG; 
  } else { 
    b = state.board; 
    hs = state.handS; 
    hg = state.handG; 
  }
    for (let y = 0; y < 9; y++) for (let x = 0; x < 9; x++) {
      const c = cells[y][x]; const p = b[y][x];
      c.className = `cell ${sel?.x===x && sel?.y===y ? 'selected' : ''}`;
      c.innerHTML = p ? `<div class="piece piece-font ${p.owner!=='S'?'opposite':''} ${UNPROMOTE_MAP[p.type]?'promoted':''}">${SYMBOLS[p.type]}</div>` : '';
    }
    const drawH = (id, list, owner) => {
      const el = document.getElementById(id); el.innerHTML = '';
      (list || []).forEach((t, i) => {
        const s = document.createElement('span'); s.className = "piece-font"; s.textContent = SYMBOLS[t];
        if (selH?.idx === i && selH?.owner === owner) s.classList.add('selected-piece');
        s.onclick = (e) => { e.stopPropagation(); if (!isReviewMode && (state.winner || state.turn !== mySide || owner !== mySide)) return; if (selH?.idx === i) selH = null; else { selH = { type: t, owner, idx: i }; sel = null; possibleMoves = []; } render(); };
        el.appendChild(s);
      });
    };
    drawH('handS', hs, 'S'); drawH('handG', hg, 'G');
    const st = document.getElementById('status-txt');
    if (state.winner && !isReviewMode) { st.textContent = `${state.winner === 'S' ? '先手' : '後手'}勝`; st.style.color = "red"; }
    else if (isReviewMode) { st.textContent = "感想戦"; st.style.color = "orange"; }
    else { st.textContent = state.turn === mySide ? "手番" : "待機"; st.style.color = "black"; }
    document.getElementById('nav-pos').textContent = `${viewIdx}/${state.history.length-1}`;
    document.getElementById('timer-S').className = `timer ${!isReviewMode && state.turn==='S'?'your-turn':''}`;
    document.getElementById('timer-G').className = `timer ${!isReviewMode && state.turn==='G'?'your-turn':''}`;
  }

  function updateKifuList() {
    const container = document.getElementById('kifu-container'); container.innerHTML = '';
    state.history.forEach((h, i) => {
      const div = document.createElement('div'); div.className = `kifu-item ${isReviewMode && viewIdx === i ? 'active' : ''}`;
      div.textContent = formatKifuText(h, i);
      div.onclick = () => { if (!isReviewMode) setReviewMode(true); viewIdx = i; syncReviewStateLocally(); pushReviewUpdate(); render(); updateKifuList(); };
      container.appendChild(div); if (isReviewMode && viewIdx === i) div.scrollIntoView({ block: 'nearest' });
    });
  }
  
  function updateHandOrientation() {
  const gameMain = document.getElementById('game-main');
  const board = document.getElementById('board-container');
  const handS = document.getElementById('handS');
  const handG = document.getElementById('handG');

  // 一旦 opponent を全解除
  handS.classList.remove('opponent');
  handG.classList.remove('opponent');

  // game-main を一旦空にする
  gameMain.innerHTML = '';

  if (mySide === 'S') {
    // 自分＝先手 → 自分(handS)を右
    handG.classList.add('opponent');   // 相手を上下反転

    gameMain.appendChild(handG);       // 左：相手
    gameMain.appendChild(board);
    gameMain.appendChild(handS);       // 右：自分
  } else {
    // 自分＝後手 → 自分(handG)を右
    handS.classList.add('opponent');   // 相手を上下反転

    gameMain.appendChild(handS);       // 左：相手
    gameMain.appendChild(board);
    gameMain.appendChild(handG);       // 右：自分
  }
}

  function formatKifuText(move, idx) {
    if (idx === 0) return "開始";
    if (move.type === "投了" || move.type === "時間切れ") { return `${idx}.${move.side === 'S' ? "▲" : "△"}${move.type}`; }
    const side = move.side === 'S' ? "▲" : "△", x = 9 - move.toX, y = KANJI_NUM[move.toY + 1];
    const isSame = (idx > 1 && move.toX === state.history[idx-1].toX && move.toY === state.history[idx-1].toY);
    let type = SYMBOLS[move.type.replace("(反則)","")];
    if (move.isPromoted) type += "成"; else if (move.isDrop) type += "打";
    return `${idx}.${side}${isSame ? "同" : x+y}${type}`;
  }

  function updateTimerDisplay() {
    const now = Date.now();
    const elapsed = (state.lastTick === 0 || isReviewMode || state.winner) ? 0 : Math.floor((now - state.lastTick) / 1000);
    ['S', 'G'].forEach(s => {
      let remMain = state.timers[s]; let displayStr = ""; let isByoAlert = false; const el = document.getElementById(`timer-${s}`);
      if (state.turn === s && !state.winner && !isReviewMode && state.lastTick !== 0) {
        if (remMain > 0) {
          const currentRem = Math.max(0, remMain - elapsed);
          if (currentRem > 0) displayStr = `${s==='S'?'▲':'△'} ${Math.floor(currentRem/60)}:${(currentRem%60).toString().padStart(2,'0')}`;
          else { const byoRem = Math.max(0, (state.config.byo || 30) - (elapsed - remMain)); displayStr = `${s==='S'?'▲':'△'} 秒:${byoRem}`; if (byoRem <= 5) isByoAlert = true; }
        } else { const byoRem = Math.max(0, (state.config.byo || 30) - elapsed); displayStr = `${s==='S'?'▲':'△'} 秒:${byoRem}`; if (byoRem <= 5) isByoAlert = true; }
        if (displayStr.includes("秒:0") && !state.winner) { state.winner = (s === 'S' ? 'G' : 'S'); state.winReason = "時間切れ"; finish({ side: s, type: "時間切れ" }); }
      } else { if (remMain > 0) displayStr = `${s==='S'?'▲':'△'} ${Math.floor(remMain/60)}:${(remMain%60).toString().padStart(2,'0')}`; else displayStr = `${s==='S'?'▲':'△'} 秒:${state.config.byo || 30}`; }
      el.textContent = displayStr; if (isByoAlert) el.classList.add('timer-alert'); else el.classList.remove('timer-alert');
    });
  }
  setInterval(updateTimerDisplay, 1000);

  document.getElementById('btnToggleReview').onclick = () => { setReviewMode(!isReviewMode); if(isReviewMode) { syncReviewStateLocally(); pushReviewUpdate(); } render(); updateKifuList(); };
  document.getElementById('nav-prev').onclick = () => { if (viewIdx > 0) { viewIdx--; syncReviewStateLocally(); pushReviewUpdate(); render(); updateKifuList(); } };
  document.getElementById('nav-next').onclick = () => { if (viewIdx < state.history.length - 1) { viewIdx++; syncReviewStateLocally(); pushReviewUpdate(); render(); updateKifuList(); } };
  document.getElementById('nav-first').onclick = () => { if (isReviewMode) { viewIdx = 0; syncReviewStateLocally(); pushReviewUpdate(); render(); updateKifuList(); } };
  document.getElementById('nav-last').onclick = () => { if (isReviewMode) { viewIdx = state.history.length - 1; syncReviewStateLocally(); pushReviewUpdate(); render(); updateKifuList(); } };
  document.getElementById('btn-prom-yes').onclick = () => { pendingProm.moveData.type = PROMOTE_MAP[pendingProm.moveData.type]; pendingProm.moveData.isPromoted = true; state.board[pendingProm.y][pendingProm.x].type = pendingProm.moveData.type; endProm(); };
  document.getElementById('btn-prom-no').onclick = () => endProm();
  function endProm() { const d = pendingProm.moveData; pendingProm = null; document.getElementById('promote-dialog').style.display = 'none'; finish(d); }

  const getRawMoves = (x, y, board, owner) => {
    const moves = []; const p = board[y][x]; if (!p) return moves; const f = (owner === 'S' ? -1 : 1);
    const add = (tx, ty) => { if (tx>=0 && tx<9 && ty>=0 && ty<9 && board[ty][tx]?.owner !== owner) moves.push({x:tx, y:ty}); };
    const slide = (vx, vy) => { let tx = x + vx, ty = y + vy; while (tx>=0 && tx<9 && ty>=0 && ty<9) { if (board[ty][tx]) { if (board[ty][tx].owner !== owner) moves.push({x:tx, y:ty}); break; } moves.push({x:tx, y:ty}); tx += vx; ty += vy; } };
    const t = p.type;
    if (['KI','TO','NY','NK','NG'].includes(t)) [[-1,f],[0,f],[1,f],[-1,0],[1,0],[0,-f]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='FU') add(x, y+f); else if (t==='KY') slide(0, f); else if (t==='KE') { add(x-1,y+f*2); add(x+1,y+f*2); }
    else if (t==='GI') [[-1,f],[0,f],[1,f],[-1,-f],[1,-f]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='KA') [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>slide(vx,vy));
    else if (t==='HI') [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>slide(vx,vy));
    else if (t==='OU') [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='UM') { [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>slide(vx,vy)); [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>add(x+vx,y+vy)); }
    else if (t==='RY') { [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>slide(vx,vy)); [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>add(x+vx,y+vy)); }
    return moves;
  };
  document.getElementById('btnFlip').onclick = () => { boardEl.style.transform = boardEl.style.transform === 'rotate(180deg)' ? 'rotate(0deg)' : 'rotate(180deg)'; };
  document.getElementById('btnResign').onclick = () => { if (state.winner || state.turn !== mySide) return; if (confirm("投了しますか？")) { state.winner = (mySide === 'S' ? 'G' : 'S'); state.winReason = "投了"; finish({ side: mySide, type: "投了" }); } };
  document.getElementById('btnKif').onclick = () => {
    let kif = "# KIF形式棋譜ファイル\n手合割：平手\n先手：先手\n後手：後手\n\n手数----指手----消費時間--\n";
    state.history.forEach((h, i) => { if (i === 0) return; const isSame = (i > 1 && h.toX === state.history[i-1].toX && h.toY === state.history[i-1].toY); let moveStr = isSame ? "同　" : ZEN_NUM[9 - h.toX] + KANJI_NUM[h.toY + 1]; let pieceStr = h.isPromoted ? SYMBOLS[UNPROMOTE_MAP[h.type] || h.type] + "成" : SYMBOLS[h.type.replace("(反則)","")]; let fromStr = h.isDrop ? "打" : "(" + (9 - h.fromX) + (h.fromY + 1) + ")"; kif += String(i).padStart(4, " ") + " " + moveStr + pieceStr + fromStr + "( 0:00/00:00:00)\n"; });
    const area = document.createElement("textarea"); area.value = kif; document.body.appendChild(area); area.select(); try { document.execCommand("copy"); alert("KIF形式でコピーしました。"); } catch (err) { alert("コピー失敗"); } document.body.removeChild(area);
  };
  function isCheckmate(board, turn, handS, handG) {
    for (let y = 0; y < 9; y++) for (let x = 0; x < 9; x++) if (board[y][x]?.owner === turn) { const moves = getRawMoves(x, y, board, turn); for (let m of moves) { const tb = JSON.parse(JSON.stringify(board)); tb[m.y][m.x] = tb[y][x]; tb[y][x] = null; if (!isChecked(tb, turn)) return false; } }
    const h = (turn === 'S' ? handS : handG) || []; for (let type of [...new Set(h)]) for (let y = 0; y < 9; y++) for (let x = 0; x < 9; x++) if (!board[y][x]) { const tb = JSON.parse(JSON.stringify(board)); tb[y][x] = { type, owner: turn }; if (!isChecked(tb, turn)) return false; }
    return true;
  }
</script>
</body>
</html>
