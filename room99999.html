<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>遠タメ将棋 Online (Pro)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root { --ui-font: 14px; }
    body { font-family: "Yu Gothic", sans-serif; display: flex; flex-direction: column; align-items: center; background: #f0f0f0; padding: 5px; margin: 0; }
    h1 { font-size: 1rem; color: #5d4037; margin: 5px 0; }
    
    .status-area { display: flex; gap: 10px; align-items: center; margin-bottom: 5px; }
    #status-badge { background: #795548; color: #fff; padding: 4px 12px; border-radius: 20px; font-size: 11px; font-weight: bold; }
    .timer { font-family: monospace; font-size: 16px; font-weight: bold; background: #fff; padding: 2px 8px; border-radius: 4px; border: 1px solid #ccc; }
    .your-turn { background: #d32f2f !important; }
    
    #board { display: grid; grid-template-columns: repeat(9,1fr); grid-template-rows: repeat(9,1fr); border: 2px solid #333; width: 92vmin; height: 92vmin; background: #f5deb3; }
    .cell { display: flex; align-items: center; justify-content: center; border: 0.5px solid #999; font-size: clamp(16px, 5vmin, 32px); cursor: pointer; user-select: none; position: relative; }
    .selected { background: rgba(255, 245, 166, 0.9) !important; box-shadow: inset 0 0 0 3px orange; }
    .valid-dest::after { content: ""; position: absolute; width: 20%; height: 20%; background: rgba(0, 0, 0, 0.2); border-radius: 50%; }
    .piece { font-weight: bold; z-index: 2; }
    .piece.opposite { transform: rotate(180deg); }
    .piece.promoted { color: #d32f2f; }

    .controls, .review-controls { display: flex; gap: 5px; margin-bottom: 5px; flex-wrap: wrap; justify-content: center; }
    button { padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer; color: white; background: #8d6e63; font-size: 11px; }
    input[type="number"] { width: 40px; }

    #hands { display: flex; justify-content: space-around; width: 100%; max-width: 500px; margin-top: 5px; }
    .hand-block { width: 48%; text-align: center; font-size: 10px; }
    .hand { min-height: 35px; border: 1px solid #d7ccc8; background: #fff; display: flex; gap: 2px; border-radius: 4px; flex-wrap: wrap; padding: 2px; }
    .hand span { border: 1px solid #aaa; padding: 1px 3px; border-radius: 2px; cursor: pointer; background: #eee; font-size: 12px; }
    
    .modal { display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:white; padding:20px; border-radius:8px; box-shadow:0 0 10px rgba(0,0,0,0.5); z-index:100; }
  </style>
</head>
<body>

<h1>遠タメ将棋 Online</h1>

<div class="status-area">
  <div id="status-badge">接続中...</div>
  <div id="timer-S" class="timer">先手 --:--</div>
  <div id="timer-G" class="timer">後手 --:--</div>
</div>

<div class="controls">
  <select id="mySideSelect"><option value="S">先手(▲)</option><option value="G">後手(△)</option></select>
  <button onclick="document.getElementById('configModal').style.display='block'">時間設定</button>
  <button id="btnReview" style="background:#0288d1;">感想戦モード</button>
  <button id="btnReset" style="background:#d32f2f;">リセット</button>
</div>

<div id="reviewPanel" class="review-controls" style="display:none; background:#e1f5fe; padding:5px; border-radius:5px;">
  <button id="revStart">|◀</button>
  <button id="revPrev">◀</button>
  <input type="range" id="revSlider" min="0" value="0" style="width:100px;">
  <span id="revIndex">0 / 0</span>
  <button id="revNext">▶</button>
  <button id="revEnd">▶|</button>
  <button id="revClose" style="background:#555;">対局に戻る</button>
</div>

<div id="board"></div>

<div id="hands">
  <div class="hand-block">▲先手 持ち駒<div class="hand" id="handS"></div></div>
  <div class="hand-block">△後手 持ち駒<div class="hand" id="handG"></div></div>
</div>

<div id="configModal" class="modal">
  <h3>対局設定</h3>
  持ち時間: <input type="number" id="cfgMain" value="10"> 分<br><br>
  秒読み: <input type="number" id="cfgByo" value="30"> 秒<br><br>
  <button onclick="updateConfig()" style="background:#4caf50;">設定を反映してリセット</button>
  <button onclick="this.parentElement.style.display='none'" style="background:#999;">キャンセル</button>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import { getDatabase, ref, set, onValue, update } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

  const firebaseConfig = {
      apiKey: "AIzaSyCx5anv3WWOQyke9kqhhZ9Zx-RjynLuxzE",
      authDomain: "calendar-chousei.firebaseapp.com",
      databaseURL: "https://calendar-chousei-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "calendar-chousei",
      storageBucket: "calendar-chousei.firebasestorage.app",
      messagingSenderId: "368704703397",
      appId: "1:368704703397:web:86ae24d920aaf7c5a0f64c"
  };
  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const roomName = location.pathname.split('/').pop().replace('.html', '') || "shogi_room";
  const gameRef = ref(db, `${roomName}/shogiData`);

  const SYMBOLS = {FU:'歩',KY:'香',KE:'桂',GI:'銀',KI:'金',KA:'角',HI:'飛',OU:'玉',TO:'と',NY:'成香',NK:'成桂',NG:'成銀',UM:'馬',RY:'龍'};
  const PROMOTE_MAP = {FU:'TO',KY:'NY',KE:'NK',GI:'NG',KA:'UM',HI:'RY'};
  const UNPROMOTE_MAP = {TO:'FU',NY:'KY',NK:'KE',NG:'GI',UM:'KA',RY:'HI'};

  let state = { board: [], handS: [], handG: [], turn: 'S', history: [], config: {main: 600, byo: 30}, timers: {S: 600, G: 600}, lastTick: 0 };
  let mySide = 'S', sel = null, selH = null, possibleMoves = [], isReview = false, reviewIdx = 0;
  let timerInterval = null;

  // --- 駒の動きロジック ---
  const getRawMoves = (x, y, board, owner) => {
    const moves = []; const p = board[y][x]; if (!p) return moves;
    const f = (owner === 'S') ? -1 : 1;
    const add = (tx, ty) => { if (tx>=0 && tx<9 && ty>=0 && ty<9 && board[ty][tx]?.owner !== owner) moves.push({x:tx, y:ty}); };
    const slide = (vx, vy) => {
      let tx = x + vx, ty = y + vy;
      while (tx>=0 && tx<9 && ty>=0 && ty<9) {
        if (board[ty][tx]) { if (board[ty][tx].owner !== owner) moves.push({x:tx, y:ty}); break; }
        moves.push({x:tx, y:ty}); tx += vx; ty += vy;
      }
    };
    const t = p.type;
    if (['KI','TO','NY','NK','NG'].includes(t)) [[-1,f],[0,f],[1,f],[-1,0],[1,0],[0,-f]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='FU') add(x, y+f);
    else if (t==='KY') slide(0, f);
    else if (t==='KE') { add(x-1,y+f*2); add(x+1,y+f*2); }
    else if (t==='GI') [[-1,f],[0,f],[1,f],[-1,-f],[1,-f]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='KA') [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>slide(vx,vy));
    else if (t==='HI') [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>slide(vx,vy));
    else if (t==='OU') [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='UM') { [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>slide(vx,vy)); [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>add(x+vx,y+vy)); }
    else if (t==='RY') { [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>slide(vx,vy)); [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>add(x+vx,y+vy)); }
    return moves;
  };

  const isSafeMove = (fx, fy, tx, ty, currentBoard, owner) => {
    const temp = JSON.parse(JSON.stringify(currentBoard));
    temp[ty][tx] = temp[fy][fx]; temp[fy][fx] = null;
    let kx=-1, ky=-1;
    for(let y=0; y<9; y++) for(let x=0; x<9; x++) if(temp[y][x]?.type==='OU' && temp[y][x]?.owner===owner) {kx=x; ky=y; break;}
    if (kx===-1) return true;
    const enemy = (owner==='S'?'G':'S');
    for(let y=0; y<9; y++) for(let x=0; x<9; x++) if(temp[y][x]?.owner===enemy) if(getRawMoves(x,y,temp,enemy).some(m=>m.x===kx && m.y===ky)) return false;
    return true;
  };

  // --- Firebase 同期 ---
  onValue(gameRef, (snap) => {
    const data = snap.val();
    if (!data) return;
    const isFirstLoad = !state.board.length;
    state = { ...data, board: JSON.parse(data.board), history: JSON.parse(data.history || "[]") };
    if (!isReview) render();
    startTimer();
  });

  window.updateConfig = () => {
    const m = parseInt(document.getElementById('cfgMain').value) * 60;
    const b = parseInt(document.getElementById('cfgByo').value);
    const board = Array(9).fill(null).map(()=>Array(9).fill(null));
    const setup = (y,o,ps) => ps.forEach((p,x)=>{if(p)board[y][x]={type:p,owner:o}});
    setup(0,'G',['KY','KE','GI','KI','OU','KI','GI','KE','KY']);
    board[1][1] = {type:'HI', owner:'G'}; board[1][7] = {type:'KA', owner:'G'};
    setup(2,'G',Array(9).fill('FU')); setup(6,'S',Array(9).fill('FU'));
    board[7][1] = {type:'KA', owner:'S'}; board[7][7] = {type:'HI', owner:'S'};
    setup(8,'S',['KY','KE','GI','KI','OU','KI','GI','KE','KY']);

    const newState = {
      board: JSON.stringify(board),
      handS: [], handG: [], turn: 'S',
      config: {main: m, byo: b},
      timers: {S: m, G: m},
      lastTick: Date.now(),
      history: JSON.stringify([{board, handS:[], handG:[], turn:'S'}])
    };
    set(gameRef, newState);
    document.getElementById('configModal').style.display='none';
  };

  function syncMove() {
    state.lastTick = Date.now();
    const snapshot = { board: state.board, handS: state.handS, handG: state.handG, turn: state.turn };
    state.history.push(JSON.parse(JSON.stringify(snapshot)));
    set(gameRef, { ...state, board: JSON.stringify(state.board), history: JSON.stringify(state.history) });
  }

  // --- タイマー処理 ---
  function startTimer() {
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(() => {
      if (isReview) return;
      const now = Date.now();
      const diff = Math.floor((now - state.lastTick) / 1000);
      if (diff <= 0) return;

      let currentT = state.timers[state.turn];
      if (currentT > 0) {
        currentT = Math.max(0, state.timers[state.turn] - diff);
      } else {
        // 秒読み
      }
      
      updateTimerDisplay(state.turn, currentT, diff);

      // 時間切れ判定
      if (currentT === 0 && (state.config.byo - diff) < 0) {
        alert(state.turn === 'S' ? "先手切れ負け" : "後手切れ負け");
        clearInterval(timerInterval);
      }
    }, 1000);
  }

  function updateTimerDisplay(turn, mainTime, diff) {
    const el = document.getElementById(`timer-${turn}`);
    const total = mainTime > 0 ? mainTime : Math.max(0, state.config.byo - diff);
    const m = Math.floor(total / 60);
    const s = total % 60;
    el.textContent = `${turn==='S'?'先手':'後手'} ${m}:${s.toString().padStart(2,'0')}`;
    if (mainTime <= 0) el.style.color = 'red'; else el.style.color = 'black';
  }

  // --- 描画・操作 ---
  function handleCellClick(x, y) {
    if (isReview || state.turn !== mySide) return;
    const p = state.board[y][x];

    if (selH) {
      if (!p) {
        state.board[y][x] = {type: selH.type, owner: mySide};
        const newHand = [...(mySide==='S'?state.handS:state.handG)];
        newHand.splice(selH.idx, 1);
        if (mySide==='S') state.handS = newHand; else state.handG = newHand;
        state.turn = (mySide==='S'?'G':'S'); selH = null; render(); syncMove();
      } else { selH = null; render(); }
      return;
    }

    if (p && p.owner === mySide) {
      if (sel?.x === x && sel?.y === y) { sel = null; possibleMoves = []; }
      else {
        sel = {x, y};
        possibleMoves = getRawMoves(x, y, state.board, mySide).filter(m => isSafeMove(x, y, m.x, m.y, state.board, mySide));
      }
      render();
    } else if (sel && possibleMoves.some(m => m.x===x && m.y===y)) {
      if (p && p.owner !== mySide) {
        const captured = UNPROMOTE_MAP[p.type] || p.type;
        if (mySide === 'S') state.handS = [...state.handS, captured]; else state.handG = [...state.handG, captured];
      }
      let type = state.board[sel.y][sel.x].type;
      const isLast = (mySide==='S' ? y===0 : y===8);
      if (((type==='FU'||type==='KY') && isLast) || (type==='KE' && (mySide==='S'?y<=1:y>=7))) {
        type = PROMOTE_MAP[type];
      } else if (PROMOTE_MAP[type] && (mySide==='S'?(y<=2||sel.y<=2):(y>=6||sel.y>=6))) {
        if (confirm("成りますか？")) type = PROMOTE_MAP[type];
      }
      // 消費時間の計算とタイマー更新
      const now = Date.now();
      const used = Math.floor((now - state.lastTick) / 1000);
      state.timers[state.turn] = Math.max(0, state.timers[state.turn] - used);
      
      state.board[y][x] = {type, owner: mySide};
      state.board[sel.y][sel.x] = null;
      state.turn = (mySide==='S'?'G':'S');
      sel = null; possibleMoves = []; render(); syncMove();
    } else { sel = null; possibleMoves = []; render(); }
  }

  function render(targetState = state) {
    const bEl = document.getElementById('board'); bEl.innerHTML = '';
    targetState.board.forEach((row, y) => {
      row.forEach((p, x) => {
        const c = document.createElement('div');
        c.className = `cell ${sel?.x===x && sel?.y===y ? 'selected' : ''} ${possibleMoves.some(m=>m.x===x&&m.y===y)?'valid-dest':''}`;
        if (p) {
          const d = document.createElement('div');
          d.className = `piece ${p.owner!=='S'?'opposite':''} ${UNPROMOTE_MAP[p.type]?'promoted':''}`;
          d.textContent = SYMBOLS[p.type];
          c.appendChild(d);
        }
        c.onclick = () => handleCellClick(x, y);
        bEl.appendChild(c);
      });
    });
    const drawH = (id, list, owner) => {
      const el = document.getElementById(id); el.innerHTML = '';
      (list||[]).forEach((t, i) => {
        const s = document.createElement('span'); s.textContent = SYMBOLS[t];
        if (selH?.idx === i && selH?.owner === owner) s.style.background = '#ffea00';
        s.onclick = (e) => { if(!isReview && state.turn===mySide && owner===mySide){ selH={type:t,owner,idx:i}; sel=null; possibleMoves=[]; render(); } };
        el.appendChild(s);
      });
    };
    drawH('handS', targetState.handS, 'S'); drawH('handG', targetState.handG, 'G');
    document.getElementById('status-badge').textContent = `手番: ${targetState.turn==='S'?'▲先手':'△後手'}`;
  }

  // --- 感想戦ロジック ---
  document.getElementById('btnReview').onclick = () => {
    isReview = true;
    reviewIdx = state.history.length - 1;
    document.querySelector('.controls').style.display = 'none';
    document.getElementById('reviewPanel').style.display = 'flex';
    updateReview();
  };
  document.getElementById('revClose').onclick = () => {
    isReview = false;
    document.querySelector('.controls').style.display = 'flex';
    document.getElementById('reviewPanel').style.display = 'none';
    render();
  };
  function updateReview() {
    const h = state.history[reviewIdx];
    sel = null; possibleMoves = [];
    render(h);
    document.getElementById('revSlider').max = state.history.length - 1;
    document.getElementById('revSlider').value = reviewIdx;
    document.getElementById('revIndex').textContent = `${reviewIdx} / ${state.history.length - 1} 手`;
  }
  document.getElementById('revNext').onclick = () => { if(reviewIdx < state.history.length-1) { reviewIdx++; updateReview(); } };
  document.getElementById('revPrev').onclick = () => { if(reviewIdx > 0) { reviewIdx--; updateReview(); } };
  document.getElementById('revStart').onclick = () => { reviewIdx = 0; updateReview(); };
  document.getElementById('revEnd').onclick = () => { reviewIdx = state.history.length-1; updateReview(); };
  document.getElementById('revSlider').oninput = (e) => { reviewIdx = parseInt(e.target.value); updateReview(); };

  document.getElementById('mySideSelect').onchange = (e) => {
    mySide = e.target.value;
    document.getElementById('board').style.transform = (mySide === 'G') ? 'rotate(180deg)' : 'rotate(0deg)';
    render();
  };
  document.getElementById('btnReset').onclick = () => { if(confirm("リセットしますか？")) updateConfig(); };
</script>
</body>
</html>
