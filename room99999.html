<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>遠タメ将棋 Online (Corrected)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root { --ui-font: 14px; }
    body { font-family: "Yu Gothic", sans-serif; display: flex; flex-direction: column; align-items: center; background: #f0f0f0; padding: 5px; margin: 0; }
    h1 { font-size: 1rem; color: #5d4037; margin: 5px 0; }
    #status-badge { background: #795548; color: #fff; padding: 4px 15px; border-radius: 20px; margin-bottom: 5px; font-size: 12px; font-weight: bold; }
    .your-turn { background: #d32f2f !important; }
    #board { display: grid; grid-template-columns: repeat(9,1fr); grid-template-rows: repeat(9,1fr); border: 2px solid #333; width: 92vmin; height: 92vmin; background: #f5deb3; }
    .cell { display: flex; align-items: center; justify-content: center; border: 0.5px solid #999; font-size: clamp(16px, 5vmin, 32px); cursor: pointer; user-select: none; }
    .selected { background: rgba(255, 245, 166, 0.9) !important; box-shadow: inset 0 0 0 3px orange; }
    .valid-dest { position: relative; }
    .valid-dest::after { content: ""; position: absolute; width: 25%; height: 25%; background: rgba(0, 0, 0, 0.15); border-radius: 50%; }
    .piece { font-weight: bold; }
    .piece.opposite { transform: rotate(180deg); }
    .piece.promoted { color: #d32f2f; }
    .controls { display: flex; gap: 5px; margin-bottom: 5px; }
    button { padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; color: white; background: #8d6e63; font-size: 11px; }
    #hands { display: flex; justify-content: space-around; width: 100%; max-width: 500px; margin-top: 5px; }
    .hand-block { width: 48%; text-align: center; font-size: 10px; }
    .hand { min-height: 40px; border: 1px solid #d7ccc8; background: #fff; display: flex; gap: 3px; border-radius: 4px; flex-wrap: wrap; padding: 3px; }
    .hand span { border: 1px solid #aaa; padding: 1px 4px; border-radius: 3px; cursor: pointer; background: #eee; font-size: 13px; }
  </style>
</head>
<body>

<h1>遠タメ将棋 Online</h1>
<div id="status-badge">接続中...</div>

<div class="controls">
  <select id="mySideSelect"><option value="S">先手(▲)</option><option value="G">後手(△)</option></select>
  <button id="btnReset" style="background:#d32f2f;">初期化</button>
  <button id="btnFlip">盤反転</button>
</div>

<div id="board"></div>

<div id="hands">
  <div class="hand-block">▲先手 持ち駒<div class="hand" id="handS"></div></div>
  <div class="hand-block">△後手 持ち駒<div class="hand" id="handG"></div></div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

  const firebaseConfig = {
      apiKey: "AIzaSyCx5anv3WWOQyke9kqhhZ9Zx-RjynLuxzE",
      authDomain: "calendar-chousei.firebaseapp.com",
      databaseURL: "https://calendar-chousei-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "calendar-chousei",
      storageBucket: "calendar-chousei.firebasestorage.app",
      messagingSenderId: "368704703397",
      appId: "1:368704703397:web:86ae24d920aaf7c5a0f64c"
  };
  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const roomName = location.pathname.split('/').pop().replace('.html', '') || "shogi_room";
  const gameRef = ref(db, `${roomName}/shogiData`);

  const SYMBOLS = {FU:'歩',KY:'香',KE:'桂',GI:'銀',KI:'金',KA:'角',HI:'飛',OU:'玉',TO:'と',NY:'成香',NK:'成桂',NG:'成銀',UM:'馬',RY:'龍'};
  const PROMOTE_MAP = {FU:'TO',KY:'NY',KE:'NK',GI:'NG',KA:'UM',HI:'RY'};
  const UNPROMOTE_MAP = {TO:'FU',NY:'KY',NK:'KE',NG:'GI',UM:'KA',RY:'HI'};

  let state = { board: [], handS: [], handG: [], turn: 'S' };
  let mySide = 'S', sel = null, selH = null, possibleMoves = [];

  const getRawMoves = (x, y, board, owner) => {
    const moves = [];
    const p = board[y][x];
    if (!p) return moves;
    const f = (owner === 'S') ? -1 : 1;
    const add = (tx, ty) => {
      if (tx>=0 && tx<9 && ty>=0 && ty<9 && board[ty][tx]?.owner !== owner) moves.push({x:tx, y:ty});
    };
    const slide = (vx, vy) => {
      let tx = x + vx, ty = y + vy;
      while (tx>=0 && tx<9 && ty>=0 && ty<9) {
        if (board[ty][tx]) { if (board[ty][tx].owner !== owner) moves.push({x:tx, y:ty}); break; }
        moves.push({x:tx, y:ty}); tx += vx; ty += vy;
      }
    };

    const t = p.type;
    if (['KI','TO','NY','NK','NG'].includes(t)) [[-1,f],[0,f],[1,f],[-1,0],[1,0],[0,-f]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='FU') add(x, y+f);
    else if (t==='KY') slide(0, f);
    else if (t==='KE') { add(x-1,y+f*2); add(x+1,y+f*2); }
    else if (t==='GI') [[-1,f],[0,f],[1,f],[-1,-f],[1,-f]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='KA') [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>slide(vx,vy));
    else if (t==='HI') [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>slide(vx,vy));
    else if (t==='OU') [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='UM') { [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>slide(vx,vy)); [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>add(x+vx,y+vy)); }
    else if (t==='RY') { [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>slide(vx,vy)); [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>add(x+vx,y+vy)); }
    return moves;
  };

  const isSafeMove = (fx, fy, tx, ty, currentBoard, owner) => {
    // 盤面を完全にコピーしてシミュレート
    const tempBoard = JSON.parse(JSON.stringify(currentBoard));
    tempBoard[ty][tx] = tempBoard[fy][fx];
    tempBoard[fy][fx] = null;
    
    let kx = -1, ky = -1;
    for(let y=0; y<9; y++) for(let x=0; x<9; x++) {
      if(tempBoard[y][x]?.type==='OU' && tempBoard[y][x]?.owner===owner) { kx=x; ky=y; break; }
    }
    if (kx === -1) return true;

    const enemy = (owner === 'S' ? 'G' : 'S');
    for(let y=0; y<9; y++) for(let x=0; x<9; x++) {
      if(tempBoard[y][x]?.owner === enemy) {
        const moves = getRawMoves(x, y, tempBoard, enemy);
        if(moves.some(m => m.x===kx && m.y===ky)) return false;
      }
    }
    return true;
  };

  onValue(gameRef, (snap) => {
    const data = snap.val();
    if (!data) return;
    state = { ...data, board: JSON.parse(data.board) };
    render();
  });

  function sync() { set(gameRef, { ...state, board: JSON.stringify(state.board) }); }

  function resetGame() {
    if (!confirm("初期化しますか？")) return;
    const b = Array(9).fill(null).map(()=>Array(9).fill(null));
    const setup = (y,o,ps) => ps.forEach((p,x)=>{if(p)b[y][x]={type:p,owner:o}});
    setup(0,'G',['KY','KE','GI','KI','OU','KI','GI','KE','KY']);
    b[1][1] = {type:'HI', owner:'G'}; b[1][7] = {type:'KA', owner:'G'};
    setup(2,'G',Array(9).fill('FU'));
    setup(6,'S',Array(9).fill('FU'));
    b[7][1] = {type:'KA', owner:'S'}; b[7][7] = {type:'HI', owner:'S'};
    setup(8,'S',['KY','KE','GI','KI','OU','KI','GI','KE','KY']);
    state = { board: b, handS: [], handG: [], turn: 'S' };
    render(); sync();
  }

  function handleCellClick(x, y) {
    if (state.turn !== mySide) return;
    const p = state.board[y][x];

    if (selH) {
      if (!p) {
        if (selH.type==='FU' && state.board.some(r => r[x]?.type==='FU' && r[x]?.owner===mySide)) return;
        state.board[y][x] = {type: selH.type, owner: mySide};
        if (mySide==='S') state.handS.splice(selH.idx,1); else state.handG.splice(selH.idx,1);
        state.turn = (mySide==='S'?'G':'S'); selH = null; render(); sync();
      } else { selH = null; render(); }
      return;
    }

    if (p && p.owner === mySide) {
      if (sel?.x === x && sel?.y === y) { sel = null; possibleMoves = []; }
      else {
        sel = {x, y};
        possibleMoves = getRawMoves(x, y, state.board, mySide).filter(m => isSafeMove(x, y, m.x, m.y, state.board, mySide));
      }
      render();
    } else if (sel && possibleMoves.some(m => m.x===x && m.y===y)) {
      const fromP = state.board[sel.y][sel.x];
      if (p && p.owner !== mySide) {
        state[mySide==='S'?'handS':'handG'].push(UNPROMOTE_MAP[p.type] || p.type);
      }
      
      let type = fromP.type;
      const isLast = (mySide==='S' ? y===0 : y===8);
      const isKE_Last = (mySide==='S' ? y<=1 : y>=7);
      
      // 強制成りの判定
      if ((type==='FU' || type==='KY') && isLast) type = PROMOTE_MAP[type];
      else if (type==='KE' && isKE_Last) type = PROMOTE_MAP[type];
      // 選択成りの判定
      else if (PROMOTE_MAP[type] && ((mySide==='S'?(y<=2||sel.y<=2):(y>=6||sel.y>=6)))) {
        if (confirm("成りますか？")) type = PROMOTE_MAP[type];
      }

      state.board[y][x] = {type, owner: mySide};
      state.board[sel.y][sel.x] = null;
      state.turn = (mySide==='S'?'G':'S');
      sel = null; possibleMoves = [];
      render(); sync();
    } else { sel = null; possibleMoves = []; render(); }
  }

  function render() {
    const bEl = document.getElementById('board'); bEl.innerHTML = '';
    state.board.forEach((row, y) => {
      row.forEach((p, x) => {
        const c = document.createElement('div');
        c.className = `cell ${sel?.x===x && sel?.y===y ? 'selected' : ''} ${possibleMoves.some(m=>m.x===x&&m.y===y)?'valid-dest':''}`;
        if (p) {
          const d = document.createElement('div');
          d.className = `piece ${p.owner!=='S'?'opposite':''} ${UNPROMOTE_MAP[p.type]?'promoted':''}`;
          d.textContent = SYMBOLS[p.type];
          c.appendChild(d);
        }
        c.onclick = () => handleCellClick(x, y);
        bEl.appendChild(c);
      });
    });
    const drawH = (id, list, owner) => {
      const el = document.getElementById(id); el.innerHTML = '';
      (list||[]).sort().forEach((t, i) => {
        const s = document.createElement('span'); s.textContent = SYMBOLS[t];
        if (selH?.idx === i && selH?.owner === owner) s.style.background = '#ffea00';
        s.onclick = (e) => { e.stopPropagation(); if (state.turn===mySide && owner===mySide) { selH={type:t,owner,idx:i}; sel=null; possibleMoves=[]; render(); } };
        el.appendChild(s);
      });
    };
    drawH('handS', state.handS, 'S'); drawH('handG', state.handG, 'G');
    const badge = document.getElementById('status-badge');
    badge.textContent = `手番: ${state.turn==='S'?'▲先手':'△後手'} ${state.turn===mySide?'(あなたの番)':''}`;
    badge.className = state.turn===mySide ? 'your-turn' : '';
  }

  document.getElementById('mySideSelect').onchange = (e) => {
    mySide = e.target.value;
    document.getElementById('board').style.transform = (mySide === 'G') ? 'rotate(180deg)' : 'rotate(0deg)';
    render();
  };
  document.getElementById('btnReset').onclick = resetGame;
  document.getElementById('btnFlip').onclick = () => {
    const b = document.getElementById('board');
    b.style.transform = b.style.transform === 'rotate(180deg)' ? 'rotate(0deg)' : 'rotate(180deg)';
  };
</script>
</body>
</html>
