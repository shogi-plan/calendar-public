<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>遠タメ将棋 Online (Official Rules)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root { --ui-font: 14px; }
    body { font-family: "Yu Gothic", sans-serif; display: flex; flex-direction: column; align-items: center; background: #f0f0f0; padding: 10px; margin: 0; }
    h1 { font-size: 1.2rem; color: #5d4037; margin: 10px 0; }
    #status-badge { background: #795548; color: #fff; padding: 4px 12px; border-radius: 20px; margin-bottom: 10px; font-size: 12px; }
    #board { display: grid; grid-template-columns: repeat(9,1fr); grid-template-rows: repeat(9,1fr); border: 2px solid #333; width: 92vmin; height: 92vmin; background: #f5deb3; position: relative; }
    .cell { display: flex; align-items: center; justify-content: center; border: 0.5px solid #999; font-size: clamp(16px, 4vmin, 30px); cursor: pointer; font-weight: bold; user-select: none; }
    .selected { background: #fff5a6 !important; box-shadow: inset 0 0 0 3px orange; z-index: 5; }
    .valid-move { background: rgba(255, 165, 0, 0.3) !important; }
    .piece.opposite { transform: rotate(180deg); }
    .piece.promoted { color: #d32f2f; }
    .controls { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-bottom: 10px; max-width: 500px; }
    button { padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; color: white; font-weight: bold; background: #8d6e63; font-size: 12px; }
    #hands { display: flex; justify-content: space-around; width: 100%; margin: 10px 0; max-width: 500px; }
    .hand { min-height: 40px; border: 1px solid #d7ccc8; background: #fff; padding: 5px; display: flex; gap: 5px; border-radius: 5px; flex-wrap: wrap; margin-top: 4px; width: 100%; }
    .hand span { border: 1px solid #aaa; padding: 2px 6px; border-radius: 3px; cursor: pointer; background: #eee; }
    .hand span.selected { background: #ffea00 !important; outline: 2px solid orange; }
    #kifuList { height: 80px; overflow-y: auto; background: #fff; width: 92vmin; max-width: 500px; border: 1px solid #d7ccc8; list-style: none; padding: 5px; font-size: 12px; margin: 10px 0; }
    .hidden { display: none !important; }
  </style>
</head>
<body>

<h1>遠タメ将棋 Online</h1>
<div id="status-badge">接続中...</div>

<div class="controls">
  <label>自分: <select id="mySideSelect"><option value="S">先手</option><option value="G">後手</option></select></label>
  <button id="btnReset" style="background:#d32f2f;">同期初期化</button>
  <button id="btnFlip">盤面反転</button>
  <button id="btnKanso">感想戦モード</button>
</div>

<div id="board"></div>

<div id="hands">
  <div style="width:45%">先手<div class="hand" id="handS"></div></div>
  <div style="width:45%">後手<div class="hand" id="handG"></div></div>
</div>

<ul id="kifuList" class="hidden"></ul>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

  const firebaseConfig = {
      apiKey: "AIzaSyCx5anv3WWOQyke9kqhhZ9Zx-RjynLuxzE",
      authDomain: "calendar-chousei.firebaseapp.com",
      databaseURL: "https://calendar-chousei-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "calendar-chousei",
      storageBucket: "calendar-chousei.firebasestorage.app",
      messagingSenderId: "368704703397",
      appId: "1:368704703397:web:86ae24d920aaf7c5a0f64c"
  };
  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const roomName = location.pathname.split('/').pop().replace('.html', '') || "default_room";
  const gameRef = ref(db, `${roomName}/shogiData`);

  const SYMBOLS = {FU:'歩',KY:'香',KE:'桂',GI:'銀',KI:'金',KA:'角',HI:'飛',OU:'玉',TO:'と',NY:'成香',NK:'成桂',NG:'成銀',UM:'馬',RY:'龍'};
  let state = { board: [], handS: [], handG: [], turn: 'S', kifu: [], history: [], hIdx: 0 };
  let mySide = 'S', isKanso = false, sel = null, selH = null, validMoves = [];

  onValue(gameRef, (snapshot) => {
    const data = snapshot.val();
    if (!data) return;
    state = { ...data, board: JSON.parse(data.board), history: JSON.parse(data.history) };
    render();
  });

  async function sync() {
    await set(gameRef, { ...state, board: JSON.stringify(state.board), history: JSON.stringify(state.history) });
  }

  function resetGame() {
    if (!confirm("初期配置に戻しますか？")) return;
    const b = Array(9).fill(null).map(()=>Array(9).fill(null));
    const setup = (y,o,ps) => ps.forEach((p,x)=>{if(p)b[y][x]={type:p,owner:o}});
    setup(0,'G',['KY','KE','GI','KI','OU','KI','GI','KE','KY']);
    setup(1,'G',[null,'HI',null,null,null,null,null,'KA',null]); // 飛車(右)・角(左)
    setup(2,'G',Array(9).fill('FU'));
    setup(6,'S',Array(9).fill('FU'));
    setup(7,'S',[null,'KA',null,null,null,null,null,'HI',null]); // 角(左)・飛車(右)
    setup(8,'S',['KY','KE','GI','KI','OU','KI','GI','KE','KY']);
    state = { board: b, handS: [], handG: [], turn: 'S', kifu: [], history: [{board: b, handS: [], handG: []}], hIdx: 0 };
    sync();
  }

  // --- 駒の動き定義 ---
  function getPossibleMoves(x, y, board, owner) {
    const moves = [];
    const p = board[y][x];
    if (!p) return moves;
    const dy = (owner === 'S') ? -1 : 1;

    const add = (tx, ty) => {
      if (tx<0 || tx>8 || ty<0 || ty>8) return false;
      if (board[ty][tx] && board[ty][tx].owner === owner) return false;
      moves.push({x: tx, y: ty});
      return !board[ty][tx]; // 駒があればそこで止まる（走り駒用）
    };

    const slide = (vx, vy) => {
      let tx = x + vx, ty = y + vy;
      while (add(tx, ty)) { tx += vx; ty += vy; }
    };

    const type = p.type;
    // 金・成駒の動き
    if (['KI','TO','NY','NK','NG'].includes(type)) {
      [[-1,dy],[0,dy],[1,dy],[-1,0],[1,0],[0,-dy]].forEach(([vx,vy])=>add(x+vx, y+vy));
    } else if (type === 'FU') { add(x, y+dy); }
    else if (type === 'KY') { slide(0, dy); }
    else if (type === 'KE') { add(x-1, y+dy*2); add(x+1, y+dy*2); }
    else if (type === 'GI') { [[-1,dy],[0,dy],[1,dy],[-1,-dy],[1,-dy]].forEach(([vx,vy])=>add(x+vx, y+vy)); }
    else if (type === 'KA') { slide(1,1); slide(1,-1); slide(-1,1); slide(-1,-1); }
    else if (type === 'HI') { slide(0,1); slide(0,-1); slide(1,0); slide(-1,0); }
    else if (type === 'OU') { [-1,0,1].forEach(vx=>[-1,0,1].forEach(vy=>add(x+vx, y+vy))); }
    else if (type === 'UM') { slide(1,1); slide(1,-1); slide(-1,1); slide(-1,-1); [0,1,0,-1,1,0,-1,0].forEach((v,i,a)=>i%2==0&&add(x+v, y+a[i+1])); }
    else if (type === 'RY') { slide(0,1); slide(0,-1); slide(1,0); slide(-1,0); [1,1,1,-1,-1,1,-1,-1].forEach((v,i,a)=>i%2==0&&add(x+v, y+a[i+1])); }

    return moves;
  }

  function handleCellClick(x, y) {
    if (isKanso || state.turn !== mySide) return;
    const p = state.board[y][x];

    if (selH) {
      if (!p) {
        // 二歩チェック
        if (selH.type === 'FU' && state.board.some(row => row[x]?.type === 'FU' && row[x]?.owner === mySide)) {
          alert("二歩は打てません"); return;
        }
        state.board[y][x] = {type: selH.type, owner: mySide};
        if (mySide === 'S') state.handS.splice(selH.idx, 1); else state.handG.splice(selH.idx, 1);
        finishMove(`打${9-x}${y+1}${SYMBOLS[selH.type]}`);
      }
      selH = null; validMoves = []; render(); return;
    }

    if (p && p.owner === mySide) {
      sel = {x, y};
      validMoves = getPossibleMoves(x, y, state.board, mySide);
      render();
    } else if (sel && validMoves.some(m => m.x === x && m.y === y)) {
      const fromP = state.board[sel.y][sel.x];
      if (p) {
        const unp = (t) => ({TO:'FU',NY:'KY',NK:'KE',NG:'GI',UM:'KA',RY:'HI'}[t]||t);
        if (mySide === 'S') state.handS.push(unp(p.type)); else state.handG.push(unp(p.type));
      }
      let type = fromP.type;
      const isPZ = (o,ty) => o==='S' ? ty<=2 : ty>=6;
      if (['FU','KY','KE','GI','KA','HI'].includes(type) && (isPZ(mySide,y) || isPZ(mySide,sel.y))) {
        if (confirm("成りますか？")) type = {FU:'TO',KY:'NY',KE:'NK',GI:'NG',KA:'UM',HI:'RY'}[type];
      }
      state.board[y][x] = {type, owner: mySide};
      state.board[sel.y][sel.x] = null;
      finishMove(`${9-x}${y+1}${SYMBOLS[type]}`);
      sel = null; validMoves = [];
    } else {
      sel = null; validMoves = []; render();
    }
  }

  function finishMove(txt) {
    state.kifu.push(txt);
    state.turn = (state.turn === 'S') ? 'G' : 'S';
    state.history.push({ board: JSON.parse(JSON.stringify(state.board)), handS: [...state.handS], handG: [...state.handG] });
    state.hIdx = state.history.length - 1;
    sync();
  }

  function render() {
    const boardEl = document.getElementById('board'); boardEl.innerHTML = '';
    state.board.forEach((row, y) => {
      row.forEach((p, x) => {
        const c = document.createElement('div');
        const isValid = validMoves.some(m => m.x === x && m.y === y);
        c.className = `cell ${sel?.x===x && sel?.y===y ? 'selected' : ''} ${isValid ? 'valid-move' : ''}`;
        if (p) {
          const d = document.createElement('div');
          d.className = `piece ${p.owner!=='S'?'opposite':''} ${['TO','NY','NK','NG','UM','RY'].includes(p.type)?'promoted':''}`;
          d.textContent = SYMBOLS[p.type];
          c.appendChild(d);
        }
        c.onclick = () => handleCellClick(x, y);
        boardEl.appendChild(c);
      });
    });
    const drawHand = (id, list, owner) => {
      const el = document.getElementById(id); el.innerHTML = '';
      list.forEach((t, i) => {
        const s = document.createElement('span'); s.textContent = SYMBOLS[t];
        if(selH?.idx===i && selH?.owner===owner) s.className = 'selected';
        s.onclick = (e) => { e.stopPropagation(); if(state.turn===mySide && owner===mySide){ selH={type:t,owner,idx:i}; sel=null; render(); } };
        el.appendChild(s);
      });
    };
    drawHand('handS', state.handS, 'S'); drawHand('handG', state.handG, 'G');
    document.getElementById('status-badge').textContent = `手番: ${state.turn==='S'?'先手':'後手'} (${mySide==='S'?'先手':'後手'})`;
  }

  document.getElementById('btnReset').onclick = resetGame;
  document.getElementById('mySideSelect').onchange = (e) => { mySide = e.target.value; document.getElementById('board').style.transform = (mySide==='G')?'rotate(180deg)':'rotate(0deg)'; render(); };
  initRoom(); // 略
</script>
</body>
</html>
