<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>遠タメ将棋 Online</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
  <style>
    :root { 
      --board-color: #edc9af; 
      --primary-btn: #2196f3; 
      --danger-btn: #d32f2f; 
      --select-color: #ff9800; /* 選択色を統一 */
    }
    body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #eee; margin: 0; padding: 2px; overflow-x: hidden; touch-action: manipulation; }
    h1 { font-size: 0.9rem; margin: 2px 0; }
    
    #game-main { display: flex; flex-direction: row; justify-content: center; align-items: flex-start; width: 100vw; max-width: 600px; gap: 2px; }

    #board-container { position: relative; width: 78vw; max-width: 400px; aspect-ratio: 1 / 1; }
    #board { display: grid; grid-template-columns: repeat(9, 11.1111%); grid-template-rows: repeat(9, 11.1111%); border: 1px solid #222; width: 100%; height: 100%; background: var(--board-color); box-sizing: border-box; }
    
    .cell { display: flex; align-items: center; justify-content: center; border: 0.5px solid rgba(0,0,0,0.2); box-sizing: border-box; width: 100%; height: 100%; }
    /* 盤上の選択色を更新 */
    .selected { background: var(--select-color) !important; box-shadow: inset 0 0 5px rgba(0,0,0,0.3); }
    
    .piece-font { font-weight: bold; font-size: 6.5vw; line-height: 1; }
    @media (min-width: 500px) { .piece-font { font-size: 32px; } }
    .piece { z-index: 10; pointer-events: none; }
    .piece.opposite { transform: rotate(180deg); }
    .piece.promoted { color: var(--danger-btn); }

    #review-panel { display: none; width: 21vw; max-width: 90px; height: 78vw; max-height: 400px; background: #fff; border: 1px solid #999; border-radius: 2px; flex-direction: column; box-sizing: border-box; }
    .kifu-list { flex-grow: 1; overflow-y: scroll; background: #fafafa; font-size: 9px; padding: 0; margin: 0; -webkit-overflow-scrolling: touch; }
    .kifu-item { padding: 5px 1px; cursor: pointer; border-bottom: 1px solid #eee; text-align: center; white-space: nowrap; }
    .kifu-item.active { background: var(--primary-btn); color: white; }
    
    .nav-controls { display: grid; grid-template-columns: 1fr 1fr; background: #ddd; gap: 1px; padding: 1px; }
    .nav-btn { font-size: 9px; padding: 7px 0; border: 1px solid #bbb; background: #fff; cursor: pointer; font-weight: bold; letter-spacing: -0.5px; }
    #nav-pos { grid-column: span 2; font-size: 9px; text-align: center; background: #eee; padding: 2px 0; font-family: monospace; border-bottom: 1px solid #ccc; }

    .controls { display: flex; gap: 2px; margin-bottom: 4px; flex-wrap: wrap; justify-content: center; background: #ddd; padding: 4px; border-radius: 4px; width: 98%; box-sizing: border-box; }
    button { cursor: pointer; border: none; border-radius: 3px; font-weight: bold; padding: 5px 6px; font-size: 11px; }
    button:disabled { background: #bbb !important; opacity: 0.6; cursor: not-allowed; }
    #btnReset { background: var(--danger-btn); color: white; }
    #btnToggleReview { background: var(--primary-btn); color: white; }
    
    .status-area { display: flex; gap: 4px; margin-bottom: 4px; width: 100%; justify-content: center; }
    .timer { font-family: monospace; font-size: 14px; font-weight: bold; background: #fff; padding: 2px 4px; border: 1px solid #555; border-radius: 3px; min-width: 70px; text-align: center; }
    .your-turn { border-color: var(--danger-btn); background: #ffebee; }

    #hands-container { display: flex; width: 100vw; max-width: 500px; gap: 4px; margin-top: 6px; align-items: flex-start; }
    .hand { flex: 1; border: 1px solid #999; background: #fff; display: flex; flex-wrap: wrap; padding: 16px 2px 4px 2px; gap: 4px; border-radius: 3px; position: relative; min-height: 8vw; box-sizing: border-box; }
    .hand::before { content: attr(data-label); position: absolute; top: 1px; left: 3px; font-size: 10px; color: #333; font-weight: bold; }
    /* 持ち駒の選択スタイルを更新 */
    .hand span { border: 1px solid #777; padding: 2px 4px; background: #f0f0f0; border-radius: 3px; display: inline-flex; align-items: center; justify-content: center; transition: background 0.2s; }
    .hand span.selected-piece { background: var(--select-color) !important; color: white; border-color: #e68a00; }

    #promote-dialog { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 10px; border: 3px solid #5d4037; z-index: 2000; text-align: center; border-radius: 8px; }
  </style>
</head>
<body>

<h1>遠タメ将棋 Online</h1>

<div class="controls">
  <div style="font-size:10px; margin-bottom:2px; width:100%; text-align:center;">
    <input type="number" id="cfgMain" value="10" style="width:35px">分/<input type="number" id="cfgByo" value="30" style="width:35px">秒
    <button id="btnReset">初期化</button>
    <button id="btnFlip">反転</button>
    <button id="btnToggleReview" disabled>感想戦</button>
    <button id="btnResign">投了</button>
    <button id="btnKif" style="background:#4caf50; color:white;">KIF</button>
  </div>
  <select id="mySideSelect" style="font-size:10px;"><option value="S">先手▲</option><option value="G">後手△</option></select>
  <div id="status-txt" style="font-size:11px; font-weight:bold; margin-left:10px;">接続待ち...</div>
</div>

<div class="status-area">
  <div id="timer-S" class="timer">▲ --:--</div>
  <div id="timer-G" class="timer">△ --:--</div>
</div>

<div id="game-main">
  <div id="board-container">
    <div id="board"></div>
    <div id="promote-dialog">
      <div style="margin-bottom:8px; font-weight:bold; font-size:12px;">成りますか？</div>
      <button id="btn-prom-yes" style="background:var(--danger-btn); color:white;">成</button>
      <button id="btn-prom-no" style="background:#757575; color:white;">不</button>
    </div>
  </div>

  <div id="review-panel">
    <div id="nav-pos">0/0</div>
    <div id="kifu-container" class="kifu-list"></div>
    <div class="nav-controls">
      <button id="nav-prev" class="nav-btn">＜ 前</button>
      <button id="nav-next" class="nav-btn">次 ＞</button>
      <button id="nav-first" class="nav-btn">《 最初</button>
      <button id="nav-last" class="nav-btn">最後 》</button>
    </div>
  </div>
</div>

<div id="hands-container">
  <div class="hand" id="handS" data-label="▲先手"></div>
  <div class="hand" id="handG" data-label="△後手"></div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

  const firebaseConfig = {
      apiKey: "AIzaSyCx5anv3WWOQyke9kqhhZ9Zx-RjynLuxzE",
      authDomain: "calendar-chousei.firebaseapp.com",
      databaseURL: "https://calendar-chousei-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "calendar-chousei",
      storageBucket: "calendar-chousei.firebasestorage.app",
      messagingSenderId: "368704703397",
      appId: "1:368704703397:web:86ae24d920aaf7c5a0f64c"
  };
  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const roomName = location.pathname.split('/').pop().replace('.html', '') || "shogi_room";
  const gameRef = ref(db, `${roomName}/shogiData`);

  const SYMBOLS = {FU:'歩',KY:'香',KE:'桂',GI:'銀',KI:'金',KA:'角',HI:'飛',OU:'玉',TO:'と',NY:'杏',NK:'圭',NG:'全',UM:'馬',RY:'龍'};
  const KIF_SYMBOLS = {FU:'歩',KY:'香',KE:'桂',GI:'銀',KI:'金',KA:'角',HI:'飛',OU:'玉',TO:'と',NY:'成香',NK:'成桂',NG:'成銀',UM:'馬',RY:'龍'};
  const PROMOTE_MAP = {FU:'TO',KY:'NY',KE:'NK',GI:'NG',KA:'UM',HI:'RY'};
  const UNPROMOTE_MAP = {TO:'FU',NY:'KY',NK:'KE',NG:'GI',UM:'KA',RY:'HI'};
  const KANJI_NUM = ["","一","二","三","四","五","六","七","八","九"];

  let state = { board: "[]", handS: [], handG: [], turn: 'S', timers: {S: 600, G: 600}, config: {main: 600, byo: 30}, lastTick: 0, history: [], winner: null };
  let mySide = 'S', sel = null, selH = null, possibleMoves = [], pendingProm = null;
  let isReviewMode = false, viewIdx = -1;
  // 感想戦用のローカル盤面保持
  let reviewBoard = null, reviewHandS = [], reviewHandG = [], reviewTurn = 'S';

  const boardEl = document.getElementById('board');
  const cells = [];
  for (let y = 0; y < 9; y++) {
    cells[y] = [];
    for (let x = 0; x < 9; x++) {
      const c = document.createElement('div');
      c.className = 'cell';
      c.onclick = () => handleCellClick(x, y);
      boardEl.appendChild(c);
      cells[y][x] = c;
    }
  }

  const isChecked = (board, owner) => {
    let kx = -1, ky = -1;
    for(let y=0; y<9; y++) for(let x=0; x<9; x++) if(board[y][x]?.type==='OU' && board[y][x]?.owner===owner) { kx=x; ky=y; break; }
    if (kx === -1) return false;
    const enemy = (owner === 'S' ? 'G' : 'S');
    for(let y=0; y<9; y++) for(let x=0; x<9; x++) if(board[y][x]?.owner === enemy) if(getRawMoves(x, y, board, enemy).some(m => m.x===kx && m.y===ky)) return true;
    return false;
  };

  const isCheckmate = (board, turn, handS, handG) => {
    for (let y = 0; y < 9; y++) for (let x = 0; x < 9; x++) {
        if (board[y][x]?.owner === turn) {
          const moves = getRawMoves(x, y, board, turn);
          for (let m of moves) {
            const tempBoard = JSON.parse(JSON.stringify(board));
            tempBoard[m.y][m.x] = tempBoard[y][x]; tempBoard[y][x] = null;
            if (!isChecked(tempBoard, turn)) return false;
          }
        }
      }
    const hand = (turn === 'S' ? handS : handG) || [];
    for (let type of [...new Set(hand)]) for (let y = 0; y < 9; y++) for (let x = 0; x < 9; x++) {
          if (!board[y][x]) {
            const tempBoard = JSON.parse(JSON.stringify(board));
            tempBoard[y][x] = { type, owner: turn };
            if (!isChecked(tempBoard, turn)) return false;
          }
        }
    return true;
  };

  function showGameOverPopup(winner) {
    const winnerName = winner === 'S' ? '先手' : '後手';
    setTimeout(() => {
      alert(`${winnerName}の勝ちです！`);
      isReviewMode = true;
      document.getElementById('btnToggleReview').textContent = "戻る";
      document.getElementById('review-panel').style.display = 'flex';
      viewIdx = state.history.length - 1;
      syncReviewState();
      render();
      updateKifuList();
    }, 100);
  }

  function finish(moveData) {
    if (state.lastTick !== 0) {
      const diff = Math.floor((Date.now() - state.lastTick) / 1000);
      state.timers[state.turn] = Math.max(0, state.timers[state.turn] - diff);
    }
    state.lastTick = Date.now();
    const nextTurn = (state.turn === 'S' ? 'G' : 'S');
    if (isCheckmate(state.board, nextTurn, state.handS, state.handG)) { state.winner = state.turn; showGameOverPopup(state.winner); }
    state.turn = nextTurn;
    sel = null; selH = null; possibleMoves = [];
    if (!state.history) state.history = [{ board: JSON.stringify(state.board), handS: [], handG: [], type: '開始' }];
    state.history.push({ ...moveData, board: JSON.stringify(state.board), handS: [...(state.handS || [])], handG: [...(state.handG || [])] });
    set(gameRef, { ...state, board: JSON.stringify(state.board) });
  }

  // 感想戦用の状態同期
  function syncReviewState() {
    if (viewIdx < 0 || !state.history[viewIdx]) return;
    const h = state.history[viewIdx];
    reviewBoard = JSON.parse(h.board);
    reviewHandS = [...(h.handS || [])];
    reviewHandG = [...(h.handG || [])];
    reviewTurn = h.side === 'S' ? 'G' : 'S'; 
  }

  document.getElementById('btnReset').onclick = () => {
    if(!confirm("初期化しますか？")) return;
    isReviewMode = false;
    document.getElementById('btnToggleReview').textContent = "感想戦";
    document.getElementById('review-panel').style.display = 'none';
    const m = (parseInt(document.getElementById('cfgMain').value) || 10) * 60, b = (parseInt(document.getElementById('cfgByo').value) || 30);
    const board = Array(9).fill(null).map(() => Array(9).fill(null));
    const setup = (y, o, ps) => ps.forEach((p, x) => { if (p) board[y][x] = { type: p, owner: o } });
    setup(0,'G',['KY','KE','GI','KI','OU','KI','GI','KE','KY']); board[1][1]={type:'HI',owner:'G'}; board[1][7]={type:'KA',owner:'G'}; setup(2,'G',Array(9).fill('FU'));
    setup(6,'S',Array(9).fill('FU')); board[7][1]={type:'KA',owner:'S'}; board[7][7]={type:'HI',owner:'S'}; setup(8,'S',['KY','KE','GI','KI','OU','KI','GI','KE','KY']);
    const bStr = JSON.stringify(board);
    set(gameRef, { board: bStr, handS: [], handG: [], turn: 'S', timers: {S: m, G: m}, config: {main: m, byo: b}, lastTick: 0, winner: null, history: [{ board: bStr, handS: [], handG: [], type: '開始' }] });
  };

  document.getElementById('btnResign').onclick = () => {
    if (state.winner || state.turn !== mySide) return;
    if (confirm("投了しますか？")) { 
      state.winner = (mySide === 'S' ? 'G' : 'S'); 
      set(gameRef, { ...state, board: JSON.stringify(state.board) });
      showGameOverPopup(state.winner);
    }
  };

  onValue(gameRef, (snap) => {
    const data = snap.val();
    if (data) {
      const oldWinner = state.winner;
      state = data; state.board = JSON.parse(data.board); state.history = data.history || [];
      document.getElementById('btnToggleReview').disabled = !state.winner;
      if (!oldWinner && state.winner) { showGameOverPopup(state.winner); }
      if (!isReviewMode) { 
        viewIdx = state.history.length - 1; 
      }
      render(); updateKifuList();
    }
  });

  function handleCellClick(x, y) {
    if (pendingProm) return;
    // 感想戦と通常対局の分岐
    const curBoard = isReviewMode ? reviewBoard : state.board;
    const curHandS = isReviewMode ? reviewHandS : state.handS;
    const curHandG = isReviewMode ? reviewHandG : state.handG;
    const curTurn = isReviewMode ? reviewTurn : state.turn;

    if (!isReviewMode && (state.winner || curTurn !== mySide)) return;

    const target = curBoard[y][x];

    if (sel && sel.x === x && sel.y === y) {
      sel = null; possibleMoves = []; render(); return;
    }

    if (sel && possibleMoves.some(m => m.x === x && m.y === y)) {
      const fromP = curBoard[sel.y][sel.x];
      const moveOwner = isReviewMode ? fromP.owner : mySide;
      
      if (target && target.owner !== moveOwner) {
        const h = (moveOwner === 'S' ? curHandS : curHandG);
        h.push(UNPROMOTE_MAP[target.type] || target.type);
      }
      
      const moveData = { side: moveOwner, fromX: sel.x, fromY: sel.y, toX: x, toY: y, type: fromP.type, isDrop: false, isPromoted: false };
      curBoard[y][x] = { type: fromP.type, owner: moveOwner }; curBoard[sel.y][sel.x] = null;
      
      const promLine = (moveOwner === 'S') ? [0,1,2] : [6,7,8];
      if (PROMOTE_MAP[fromP.type] && (promLine.includes(y) || promLine.includes(sel.y))) {
        const deadLine = (moveOwner === 'S') ? 0 : 8;
        if (((fromP.type === 'FU' || fromP.type === 'KY') && y === deadLine) || (fromP.type === 'KE' && (moveOwner==='S' ? y<=1 : y>=7))) {
          curBoard[y][x].type = PROMOTE_MAP[fromP.type]; moveData.type = PROMOTE_MAP[fromP.type]; moveData.isPromoted = true; 
          isReviewMode ? finishReview(moveOwner) : finish(moveData);
        } else { 
          pendingProm = { x, y, moveData, owner: moveOwner }; 
          document.getElementById('promote-dialog').style.display = 'block'; 
          render(); 
        }
      } else { 
        isReviewMode ? finishReview(moveOwner) : finish(moveData);
      }
      return;
    }
    if (selH) {
      if (!target) {
        const moveOwner = isReviewMode ? selH.owner : mySide;
        if (selH.type === 'FU' && curBoard.some(r => r[x]?.type === 'FU' && r[x]?.owner === moveOwner)) return;
        curBoard[y][x] = { type: selH.type, owner: moveOwner }; 
        (moveOwner === 'S' ? curHandS : curHandG).splice(selH.idx, 1);
        isReviewMode ? finishReview(moveOwner) : finish({ side: mySide, toX: x, toY: y, type: selH.type, isDrop: true });
      } else { selH = null; render(); }
      return;
    }
    if (target && (isReviewMode || target.owner === mySide)) {
      sel = { x, y }; selH = null;
      possibleMoves = getRawMoves(x, y, curBoard, target.owner).filter(m => {
          const tb = JSON.parse(JSON.stringify(curBoard)); tb[m.y][m.x] = tb[y][x]; tb[y][x] = null;
          return !isChecked(tb, target.owner);
      });
      render();
    }
  }

  function finishReview(lastMoveOwner) {
    reviewTurn = lastMoveOwner === 'S' ? 'G' : 'S';
    sel = null; selH = null; possibleMoves = [];
    render();
  }

  function render() {
    const isReviewing = isReviewMode;
    const b = isReviewing ? reviewBoard : state.board;
    const hS = isReviewing ? reviewHandS : state.handS;
    const hG = isReviewing ? reviewHandG : state.handG;

    for (let y = 0; y < 9; y++) for (let x = 0; x < 9; x++) {
        const c = cells[y][x]; const p = b[y][x];
        c.className = `cell ${sel?.x===x && sel?.y===y ? 'selected' : ''}`;
        c.innerHTML = p ? `<div class="piece piece-font ${p.owner!=='S'?'opposite':''} ${UNPROMOTE_MAP[p.type]?'promoted':''}">${SYMBOLS[p.type]}</div>` : '';
    }
    const drawH = (id, list, owner) => {
      const el = document.getElementById(id); el.innerHTML = '';
      (list || []).forEach((t, i) => {
        const s = document.createElement('span'); s.className = "piece-font"; s.textContent = SYMBOLS[t];
        if (selH?.idx === i && selH?.owner === owner) s.classList.add('selected-piece');
        s.onclick = (e) => {
          e.stopPropagation(); 
          if (!isReviewing && (state.winner || state.turn !== mySide || owner !== mySide)) return;
          if (selH?.idx === i) { selH = null; } 
          else { selH = { type: t, owner, idx: i }; sel = null; possibleMoves = []; }
          render();
        };
        el.appendChild(s);
      });
    };
    drawH('handS', hS, 'S'); drawH('handG', hG, 'G');
    const st = document.getElementById('status-txt');
    if (!isReviewing && state.winner) { st.textContent = `${state.winner === 'S' ? '先手' : '後手'}勝`; st.style.color = "red"; }
    else if (isReviewing) { st.textContent = "感想戦(自由移動可)"; st.style.color = "orange"; }
    else { st.textContent = state.turn === mySide ? "手番" : "待機"; st.style.color = "black"; }
    document.getElementById('nav-pos').textContent = `${isReviewing ? viewIdx : state.history.length-1}/${state.history.length-1}`;
    document.getElementById('timer-S').className = `timer ${!isReviewing && state.turn==='S'?'your-turn':''}`;
    document.getElementById('timer-G').className = `timer ${!isReviewing && state.turn==='G'?'your-turn':''}`;
    updateTimerDisplay();
  }

  function updateKifuList() {
    const container = document.getElementById('kifu-container'); container.innerHTML = '';
    state.history.forEach((h, i) => {
      const div = document.createElement('div'); div.className = `kifu-item ${isReviewMode && viewIdx === i ? 'active' : ''}`;
      div.textContent = formatKifuText(h, i);
      div.onclick = () => { isReviewMode = true; viewIdx = i; document.getElementById('review-panel').style.display='flex'; document.getElementById('btnToggleReview').textContent = "戻る"; syncReviewState(); render(); updateKifuList(); };
      container.appendChild(div);
      if (isReviewMode && viewIdx === i) div.scrollIntoView({ block: 'nearest' });
    });
  }

  function formatKifuText(move, idx) {
    if (idx === 0) return "開始";
    const side = move.side === 'S' ? "▲" : "△", x = 9 - move.toX, y = KANJI_NUM[move.toY + 1];
    const isSame = (idx > 1 && move.toX === state.history[idx-1].toX && move.toY === state.history[idx-1].toY);
    let type = SYMBOLS[move.type]; if (move.isPromoted) type += "成"; else if (move.isDrop) type += "打";
    return `${idx}.${side}${isSame ? "同" : x+y}${type}`;
  }

  // KIFコピー機能
  document.getElementById('btnKif').onclick = () => {
    if (!state.history || state.history.length <= 1) return;
    let k = "# KIF generated by 遠タメ将棋\n手合割：平手\n先手：先手\n後手：後手\n手数----指手----消費時間--\n";
    state.history.forEach((h, i) => {
      if (i === 0) return;
      const x = 9 - h.toX, y = h.toY + 1;
      const isSame = (i > 1 && h.toX === state.history[i-1].toX && h.toY === state.history[i-1].toY);
      let type = KIF_SYMBOLS[h.type] || SYMBOLS[h.type];
      if (h.isDrop) type += "打";
      const from = h.isDrop ? "" : `(${9-h.fromX}${h.fromY+1})`;
      k += `${String(i).padStart(4, " ")} ${isSame ? "同　" : x + KANJI_NUM[y]}${type}${from} ( 0:00/00:00:00)\n`;
    });
    navigator.clipboard.writeText(k).then(() => alert("KIF形式棋譜をコピーしました"));
  };

  document.getElementById('btnToggleReview').onclick = function() {
    isReviewMode = !isReviewMode; this.textContent = isReviewMode ? "戻る" : "感想戦";
    document.getElementById('review-panel').style.display = isReviewMode ? 'flex' : 'none';
    viewIdx = state.history.length - 1; 
    syncReviewState();
    render(); updateKifuList();
  };
  
  document.getElementById('nav-prev').onclick = () => { if (viewIdx > 0) { viewIdx--; syncReviewState(); render(); updateKifuList(); } };
  document.getElementById('nav-next').onclick = () => { if (viewIdx < state.history.length - 1) { viewIdx++; syncReviewState(); render(); updateKifuList(); } };
  document.getElementById('nav-first').onclick = () => { if (isReviewMode) { viewIdx = 0; syncReviewState(); render(); updateKifuList(); } };
  document.getElementById('nav-last').onclick = () => { if (isReviewMode) { viewIdx = state.history.length - 1; syncReviewState(); render(); updateKifuList(); } };
  
  document.getElementById('btn-prom-yes').onclick = () => { 
    const curBoard = isReviewMode ? reviewBoard : state.board;
    pendingProm.moveData.type = PROMOTE_MAP[pendingProm.moveData.type]; 
    pendingProm.moveData.isPromoted = true; 
    curBoard[pendingProm.y][pendingProm.x].type = pendingProm.moveData.type; 
    endProm(); 
  };
  document.getElementById('btn-prom-no').onclick = () => endProm();
  function endProm() { 
    const d = pendingProm.moveData; 
    const owner = pendingProm.owner;
    pendingProm = null; 
    document.getElementById('promote-dialog').style.display = 'none'; 
    isReviewMode ? finishReview(owner) : finish(d); 
  }

  const getRawMoves = (x, y, board, owner) => {
    const moves = []; const p = board[y][x]; if (!p) return moves;
    const f = (owner === 'S') ? -1 : 1;
    const add = (tx, ty) => { if (tx>=0 && tx<9 && ty>=0 && ty<9 && board[ty][tx]?.owner !== owner) moves.push({x:tx, y:ty}); };
    const slide = (vx, vy) => {
      let tx = x + vx, ty = y + vy;
      while (tx>=0 && tx<9 && ty>=0 && ty<9) {
        if (board[ty][tx]) { if (board[ty][tx].owner !== owner) moves.push({x:tx, y:ty}); break; }
        moves.push({x:tx, y:ty}); tx += vx; ty += vy;
      }
    };
    const t = p.type;
    if (['KI','TO','NY','NK','NG'].includes(t)) [[-1,f],[0,f],[1,f],[-1,0],[1,0],[0,-f]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='FU') add(x, y+f);
    else if (t==='KY') slide(0, f);
    else if (t==='KE') { add(x-1,y+f*2); add(x+1,y+f*2); }
    else if (t==='GI') [[-1,f],[0,f],[1,f],[-1,-f],[1,-f]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='KA') [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>slide(vx,vy));
    else if (t==='HI') [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>slide(vx,vy));
    else if (t==='OU') [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='UM') { [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>slide(vx,vy)); [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>add(x+vx,y+vy)); }
    else if (t==='RY') { [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>slide(vx,vy)); [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>add(x+vx,y+vy)); }
    return moves;
  };

  document.getElementById('mySideSelect').onchange = (e) => { mySide = e.target.value; boardEl.style.transform = (mySide === 'G') ? 'rotate(180deg)' : 'rotate(0deg)'; };
  document.getElementById('btnFlip').onclick = () => { boardEl.style.transform = boardEl.style.transform === 'rotate(180deg)' ? 'rotate(0deg)' : 'rotate(180deg)'; };

  function updateTimerDisplay() {
    const elapsed = (state.lastTick === 0 || isReviewMode) ? 0 : Math.floor((Date.now() - state.lastTick) / 1000);
    ['S','G'].forEach(s => {
      let rem = state.timers[s];
      if (state.turn === s && !state.winner && !isReviewMode && state.lastTick !== 0) {
        if (rem > 0) rem = Math.max(0, rem - elapsed); else rem = Math.max(0, (state.config ? state.config.byo : 30) - elapsed);
      }
      const min = Math.floor(rem/60), sec = rem%60;
      document.getElementById(`timer-${s}`).textContent = `${s==='S'?'▲':'△'} ${min}:${sec.toString().padStart(2,'0')}`;
    });
  }
  setInterval(updateTimerDisplay, 1000);
</script>
</body>
</html>
