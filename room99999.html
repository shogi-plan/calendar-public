<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>遠タメ将棋 Online</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
  <style>
    :root { 
      --board-color: #edc9af; 
      --primary-btn: #2196f3; 
      --danger-btn: #d32f2f; 
      --select-color: #ff9800;
      --call-btn: #4caf50;
    }
    body { 
  font-family: sans-serif; 
  display: flex; 
  flex-direction: column; 
  align-items: center; 
  background: #eee; 
  margin: 0; 
  padding: 2px; 
  /* overflow-x: hidden; を削除し、必要に応じてスクロール可能にする */
  touch-action: manipulation; 
}

#game-main { 
  display: flex; 
  flex-direction: row; 
  justify-content: center;     /* 中央寄せ */
  align-items: flex-start; 
  width: 100%;
  max-width: 100vw;            /* 画面幅を絶対超えない */
  gap: 2px;                    /* 隙間を最小限に */
  margin: 0 auto;
  overflow: hidden;            /* スクロールを禁止 */
  padding: 5px 2px;
  box-sizing: border-box;
}

    #board-container { position: relative; width: 58vw; max-width: 380px; aspect-ratio: 1 / 1; flex-shrink: 1; }
    #board { display: grid; grid-template-columns: repeat(9, 11.1111%); grid-template-rows: repeat(9, 11.1111%); border: 1px solid #222; width: 100%; height: 100%; background: var(--board-color); box-sizing: border-box; }
    
        /* --- 左右に配置する駒台（1列×7行） --- */
        .hand { 
      width: 10vw;               /* 少し幅を狭めて余裕を持たせる */
      max-width: 40px;
      height: 58vw;              /* 盤面の高さに合わせる */
      max-height: 380px; 
      border: 1px solid #999; 
      background: #fff; 
      display: grid; 
      grid-template-rows: repeat(7, 1fr); /* 7種類固定 */
      grid-template-columns: 1fr;
      padding: 14px 1px 1px 1px; 
      gap: 1px; 
      border-radius: 3px; 
      position: relative; 
      box-sizing: border-box;
      flex-shrink: 0;
    }
    .hand::before { 
      content: attr(data-label); 
      position: absolute; 
      top: 1px; left: 0; 
      width: 100%; 
      text-align: center; 
      font-size: 8px; 
      font-weight: bold; 
      color: #333; 
      white-space: nowrap;
    }

    /* 駒台の中の各駒スロット */
    .hand-slot {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .hand span { 
      width: 85%;                /* 駒のサイズを少し小さく */
      height: 85%;               /* 駒のサイズを少し小さく */
      border: 1px solid #777; 
      background: #f0f0f0; 
      display: inline-flex; 
      align-items: center; 
      justify-content: center; 
      box-sizing: border-box;
      cursor: pointer;
      border-radius: 2px;        /* 角を少し丸くして隙間を強調 */
    }

    /* 枚数ラベル（×2など） */
    .hand-count {
      position: absolute;
      bottom: 2px;               /* 駒の縮小に合わせて位置調整 */
      right: 2px;                /* 駒の縮小に合わせて位置調整 */
      background: rgba(255,255,255,0.9);
      border: 1px solid #999;
      border-radius: 2px;
      font-size: 8px;
      font-weight: bold;
      padding: 0 1px;
      line-height: 1;
      pointer-events: none;
      color: #000;
      z-index: 5;
    }

    .hand span.selected-piece { background: var(--select-color) !important; color: white; border-color: #e68a00; }

    /* 棋譜パネル：幅をスリムにして持ち駒エリアの欠けを防止 */
    #review-panel { display: none; width: 65px; height: 58vw; max-height: 380px; background: #fff; border: 1px solid #999; border-radius: 2px; flex-direction: column; box-sizing: border-box; flex-shrink: 0; }

    /* その他パーツのスタイル（以前のものを維持） */
    .cell { display: flex; align-items: center; justify-content: center; border: 0.5px solid rgba(0,0,0,0.2); box-sizing: border-box; width: 100%; height: 100%; }
    .selected { background: var(--select-color) !important; box-shadow: inset 0 0 5px rgba(0,0,0,0.3); }
    .piece-font { font-weight: bold; font-size: 4.5vw; line-height: 1; }
    @media (min-width: 500px) { .piece-font { font-size: 22px; } }
    .piece { 
  z-index: 10; 
  pointer-events: none; 
  display: flex;             /* 中央揃えを確実にする */
  align-items: center; 
  justify-content: center; 
}
    .piece.opposite { transform: rotate(180deg); }
    .piece.promoted { color: var(--danger-btn); }
    .kifu-list { flex-grow: 1; overflow-y: scroll; background: #fafafa; font-size: 9px; padding: 0; margin: 0; }
    .kifu-item { padding: 5px 1px; cursor: pointer; border-bottom: 1px solid #eee; text-align: center; white-space: nowrap; }
    .kifu-item.active { background: var(--primary-btn); color: white; }
        .nav-controls { display: grid; grid-template-columns: 1fr 1fr; background: #ddd; gap: 1px; padding: 1px; }
    /* フォントサイズを8pxに下げ、パディングを調整して1行に収める */
    .nav-btn { font-size: 8px; padding: 6px 0; border: 1px solid #bbb; background: #fff; cursor: pointer; font-weight: bold; letter-spacing: -0.5px; }
    #nav-pos { grid-column: span 2; font-size: 9px; text-align: center; background: #eee; padding: 2px 0; border-bottom: solid 1px #ccc; }
    .controls { display: flex; gap: 2px; margin-bottom: 4px; flex-wrap: wrap; justify-content: center; background: #ddd; padding: 4px; border-radius: 4px; width: 98%; box-sizing: border-box; }
    button { cursor: pointer; border: none; border-radius: 3px; font-weight: bold; padding: 5px 6px; font-size: 11px; }
    button:disabled { background: #bbb !important; opacity: 0.6; cursor: not-allowed; }
    #btnReset { background: var(--danger-btn); color: white; }
    #btnToggleReview { background: var(--primary-btn); color: white; }
    .status-area { display: flex; gap: 4px; margin-bottom: 4px; width: 100%; justify-content: center; }
    .timer { font-family: monospace; font-size: 14px; font-weight: bold; background: #fff; padding: 2px 4px; border: 1px solid #555; border-radius: 3px; min-width: 70px; text-align: center; }
    .your-turn { border-color: var(--danger-btn); background: #ffebee; }
    .timer-alert { color: var(--danger-btn) !important; }
    #promote-dialog { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border: 4px solid #5d4037; z-index: 2000; text-align: center; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); min-width: 160px; }
    .call-area { display: flex; flex-wrap: wrap; gap: 4px; margin: 4px 0; background: #fff; padding: 5px; border-radius: 5px; border: 1px solid #ccc; align-items: center; justify-content: center; width: 98%; box-sizing: border-box; }
    #btnCallStart { background: var(--call-btn); color: white; }
    #btnMute { background: #757575; color: white; }
    #btnCallEnd { background: var(--danger-btn); color: white; }
    #callStatusDisplay { font-size: 10px; color: #333; font-weight: bold; }
    .vol-ctrl { font-size: 10px; display: flex; align-items: center; gap: 2px; }
        .chat-message { margin-bottom: 4px; line-height: 1.4; border-bottom: 1px dotted #eee; padding-bottom: 2px; font-size: 12px;}
    /* 自分のメッセージ用（青系） */
    .chat-msg-self { color: #0d47a1; background: #e3f2fd; border-radius: 3px; padding: 2px 4px; }
    /* 他人のメッセージ用（緑系） */
    .chat-msg-other { color: #1b5e20; background: #e8f5e9; border-radius: 3px; padding: 2px 4px; }
    .chat-name { font-weight: bold; margin-right: 5px; display: none; } /* 名前の表示を非表示に設定 */
    
    /* 左側の持ち駒エリアを上下反転させる */
.hand.left-rotated {
  transform: rotate(180deg);
}

    /* 追加：設定ボタンとダイアログのスタイル */
    :root { --setting-btn: #607d8b; }
    #btnSetting { background: var(--setting-btn); color: white; }
    #setting-dialog { 
      display: none; 
      position: fixed; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%, -50%); 
      background: white; 
      padding: 20px; 
      border-radius: 8px; 
      box-shadow: 0 0 20px rgba(0,0,0,0.5); 
      z-index: 3000; 
      width: 280px; 
    }
    .setting-row { margin-bottom: 15px; }
    .setting-row label { display: block; font-size: 12px; font-weight: bold; margin-bottom: 5px; }
    .setting-row select { width: 100%; padding: 5px; border: 1px solid #ccc; border-radius: 3px; }
    
        /* カウントダウンモーダル */
    #countdown-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8);
      z-index: 9999;
      justify-content: center;
      align-items: center;
      color: white;
      font-weight: bold;
      pointer-events: none;
    }
        #countdown-text {
      font-size: 15vw; /* 画面幅に合わせる */
      white-space: nowrap; /* 絶対に折り返さない */
      text-shadow: 0 0 20px rgba(255,255,255,0.5);
      transition: all 0.2s;
      text-align: center;
      width: 100%;
    }
    /* 準備完了ランプ */
    .ready-area { display: flex; gap: 8px; align-items: center; justify-content: center; margin: 4px 0; }
    .ready-lamp { width: 12px; height: 12px; border-radius: 50%; background: #ccc; border: 1px solid #999; }
    .ready-lamp.on { background: #4caf50; box-shadow: 0 0 8px #4caf50; border-color: #fff; }
  </style>
</head>
<body>
<div id="countdown-overlay"><div id="countdown-text">5</div></div>
<h1>遠タメ将棋 Online</h1>

<div class="controls">
  <div style="font-size:10px; margin-bottom:2px; width:100%; text-align:center;">
      <div style="font-size:10px; margin-bottom:2px; width:100%; text-align:center;">
    <button id="btnSetting">設定</button>
    <button id="btnFlip">反転</button>
    <button id="btnToggleReview" disabled>感想戦</button>
    <button id="btnResign">投了</button>
  </div>

  <div id="setting-dialog">
    <h3 style="margin-top:0; border-bottom:1px solid #eee; padding-bottom:10px;">対局設定</h3>
    
    <div class="setting-row">
      <label>持ち時間</label>
      <select id="cfgMain">
        <option value="0">0分（即秒読み）</option>
        <option value="10" selected>10分</option>
        <option value="15">15分</option>
        <option value="30">30分</option>
        <option value="999999">無制限</option>
      </select>
    </div>

    <div class="setting-row">
      <label>秒読み</label>
      <select id="cfgByo">
        <option value="30" selected>30秒</option>
        <option value="60">60秒</option>
        <option value="999999">無制限</option>
      </select>
    </div>

    <div class="setting-row">
      <label>手合割（駒落ち）</label>
      <select id="cfgHandicap">
        <option value="平手">平手</option>
        <option value="香落ち">香落ち (上手：左香)</option>
        <option value="角落ち">角落ち</option>
        <option value="飛車落ち">飛車落ち</option>
        <option value="飛香落ち">飛香落ち</option>
        <option value="二枚落ち">二枚落ち (飛角)</option>
        <option value="四枚落ち">四枚落ち (飛角香香)</option>
        <option value="六枚落ち">六枚落ち (＋桂桂)</option>
        <option value="八枚落ち">八枚落ち (＋銀銀)</option>
      </select>
    </div>
    <div class="setting-row">
      <label>上手（駒を落とす側）</label>
      <select id="cfgUwateSide">
        <option value="G">後手△が上手</option>
        <option value="S">先手▲が上手</option>
      </select>
    </div>
    <div style="display:flex; gap:10px;">
      <button id="btnSettingSave" style="flex:1; background:var(--call-btn); color:white; padding:10px;">適用して初期化</button>
      <button id="btnSettingCancel" style="flex:1; background:#ccc; padding:10px;">閉じる</button>
    </div>
  </div>
  </div>
    <div class="ready-area">
    <select id="mySideSelect" style="font-size:10px;">
      <option value="" selected>未選択</option>
      <option value="S">先手▲</option>
      <option value="G">後手△</option>
    </select>
    <button id="btnReady" style="background: #ff9800; color: white; padding: 4px 8px;">対局準備完了</button>
    <div style="display: flex; gap: 4px; font-size: 10px; align-items: center; margin-left:5px;">
      ▲<div id="lamp-S" class="ready-lamp"></div>
      △<div id="lamp-G" class="ready-lamp"></div>
    </div>
  </div>
  <div id="status-txt" style="font-size:11px; font-weight:bold; margin-left:10px;">接続待ち...</div>
</div>

<div class="call-area">
  <button id="btnCallStart">通話開始</button>
  <button id="btnMute" disabled>ミュート</button>
  <button id="btnCallEnd" disabled>通話終了</button>
  <div class="vol-ctrl">
    音量:<input type="range" id="volume-control" min="0" max="1" step="0.1" value="1" style="width:50px;">
  </div>
  <span id="callStatusDisplay">オフライン</span>
</div>

<div class="status-area">
  <div id="timer-S" class="timer">▲ --:--</div>
  <div id="timer-G" class="timer">△ --:--</div>
</div>

<div id="game-main">
  <div id="game-main-inner" style="display: flex; flex-direction: row; align-items: flex-start; gap: 2px;">
    <div class="hand" id="handG" data-label="△後手"></div>
    <div id="board-container">
      <div id="board"></div>
      <div id="promote-dialog">
        <div style="margin-bottom:15px; font-weight:bold; font-size:16px;">成りますか？</div>
        <div style="display: flex; gap: 15px; justify-content: center;">
          <button id="btn-prom-yes" style="background:var(--danger-btn); color:white; padding: 12px 20px; font-size: 16px;">成る</button>
          <button id="btn-prom-no" style="background:#757575; color:white; padding: 12px 20px; font-size: 16px;">不成</button>
        </div>
      </div>
    </div>
    <div class="hand" id="handS" data-label="▲先手"></div>
  </div>

  <div id="review-panel">
    <div id="nav-pos">0/0</div>
    <div id="kifu-container" class="kifu-list"></div>
        <div class="nav-controls">
      <button id="nav-prev" class="nav-btn">＜前</button>
      <button id="nav-next" class="nav-btn">次＞</button>
      <button id="nav-first" class="nav-btn">最初</button>
      <button id="nav-last" class="nav-btn">最後</button>
      <button id="btnKif" class="nav-btn" style="grid-column: span 2; background: #4caf50; color: white;">KIFコピー</button>
    </div>
  </div>
</div>

<div id="chat-container" style="width: 95%; max-width: 500px; margin: 10px auto; background: #fff; border: 1px solid #ccc; border-radius: 5px; box-sizing: border-box;">
  <div id="chatLog" style="height: 120px; overflow-y: auto; padding: 5px; background: #fafafa;"></div>
  <div style="display: flex; padding: 5px; gap: 5px;">
    <input type="text" id="chatInput" placeholder="メッセージを入力..." style="flex: 1; padding: 5px;">
    <button id="btnSend" style="background: var(--primary-btn); color: white;">送信</button>
    <button id="btnClearChat" style="background: var(--danger-btn); color: white;">削除</button>
  </div>
</div>

<audio id="remote-audio" autoplay></audio>
<audio id="localAudio" autoplay muted style="display:none;"></audio>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import { getDatabase, ref, set, onValue, push, remove, update, get, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

  const firebaseConfig = {
      apiKey: "AIzaSyCx5anv3WWOQyke9kqhhZ9Zx-RjynLuxzE",
      authDomain: "calendar-chousei.firebaseapp.com",
      databaseURL: "https://calendar-chousei-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "calendar-chousei",
      storageBucket: "calendar-chousei.firebasestorage.app",
      messagingSenderId: "368704703397",
      appId: "1:368704703397:web:86ae24d920aaf7c5a0f64c"
  };
   // --- Firebase 初期化 ---
  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  // --- 追加：サーバー時刻との時差を補正する ---
  let serverOffset = 0;
  const offsetRef = ref(db, ".info/serverTimeOffset");
  onValue(offsetRef, (snap) => {
    serverOffset = snap.val() || 0;
  });

  /** 端末の時計をサーバー基準に補正した現在時刻(ms)を返す **/
  function getServerNow() {
    return Date.now() + serverOffset;
  }
  
  // --- ルーム管理：ファイル名から部屋名を取得 ---
  const params = new URLSearchParams(window.location.search);
  
  // URLからファイル名を取得（例: /Room999.html -> Room999）
  const fileName = window.location.pathname.split("/").pop().split(".")[0];
  
  let roomName = params.get('room') || fileName || "default_room";

   // URLの書き換え処理を無効化
  /* if (!params.get('room')) {
      const newUrl = window.location.protocol + "//" + window.location.host + window.location.pathname + `?room=${roomName}`;
      window.history.pushState({ path: newUrl }, '', newUrl);
  }
  */

  // --- 各データへの参照定義 ---
  const gameRef = ref(db, `${roomName}/shogiData`);
  const reviewRef = ref(db, `${roomName}/reviewData`);
  const callStatusRef = ref(db, `${roomName}/callStatus`);
  const signalingRef = ref(db, `${roomName}/signaling`);
  const readyRef = ref(db, `${roomName}/readyStatus`); // 追加

  let isCountingDown = false; // 追加：カウントダウン中フラグ

  const SYMBOLS = {FU:'歩',KY:'香',KE:'桂',GI:'銀',KI:'金',KA:'角',HI:'飛',OU:'玉',TO:'と',NY:'杏',NK:'圭',NG:'全',UM:'馬',RY:'龍'};

  const PROMOTE_MAP = {FU:'TO',KY:'NY',KE:'NK',GI:'NG',KA:'UM',HI:'RY'};
  const UNPROMOTE_MAP = {TO:'FU',NY:'KY',NK:'KE',NG:'GI',UM:'KA',RY:'HI'};
  const KANJI_NUM = ["","一","二","三","四","五","六","七","八","九"];
  const ZEN_NUM = ["","１","２","３","４","５","６","７","８","９"];

  let state = { board: "[]", handS: [], handG: [], turn: 'S', timers: {S: 600, G: 600}, config: {main: 600, byo: 30}, lastTick: 0, history: [], winner: null, winReason: "" };
  let sel = null, selH = null, possibleMoves = [], pendingProm = null;
  let isReviewMode = sessionStorage.getItem(`isReview_${roomName}`) === "true";
  let viewIdx = -1, rvState = null;
  const boardEl = document.getElementById('board'); 

    // 初期値を空（未選択）にする
  let mySide = sessionStorage.getItem(`mySide_${roomName}`) || '';
  const mySideSelect = document.getElementById('mySideSelect');
  mySideSelect.value = mySide;

  // --- 盤面と駒台の配置をまるごと入れ替える関数 ---
  function updateDisplayRotation(isFlipped) {
  const container = document.getElementById('game-main-inner');
  const board = document.getElementById('board');
  const handS = document.getElementById('handS');
  const handG = document.getElementById('handG');

  // いったん左右の回転状態をリセット
  handS.classList.remove('left-rotated');
  handG.classList.remove('left-rotated');

  if (isFlipped) {
    // 後手視点
    container.insertBefore(handS, container.firstChild); // 左
    container.appendChild(handG);                         // 右
    board.style.transform = 'rotate(180deg)';

    // ★左側（handS）を上下反転
    handS.classList.add('left-rotated');
  } else {
    // 先手視点
    container.insertBefore(handG, container.firstChild); // 左
    container.appendChild(handS);                         // 右
    board.style.transform = 'rotate(0deg)';

    // ★左側（handG）を上下反転
    handG.classList.add('left-rotated');
  }
}

    // 初回表示の適用（未選択時は先手視点とする）
  let currentFlip = (mySide === 'G');
  updateDisplayRotation(currentFlip);

  mySideSelect.onchange = (e) => { 
    mySide = e.target.value; 
    if (mySide) {
      sessionStorage.setItem(`mySide_${roomName}`, mySide);
    } else {
      sessionStorage.removeItem(`mySide_${roomName}`);
    }
    // 未選択時はとりあえず先手視点（false）
    currentFlip = (mySide === 'G');
    updateDisplayRotation(currentFlip);
    render(); 
  };

  // 反転ボタン
  document.getElementById('btnFlip').onclick = () => {
    currentFlip = !currentFlip;
    updateDisplayRotation(currentFlip);
  };

    // --- 通話維持用（バックグラウンド・タイムアウト対策 決定版） ---
  let wakeLock = null;
  let silenceAudio = null;
  let audioCtx = null;
  let keepAliveInterval = null; 
  const silenceData = "data:audio/wav;base64,UklGRigAAABXQVZFRm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==";

  async function startKeepAlive() {
    try {
      // 1. 画面スリープ防止
      if ('wakeLock' in navigator) {
        try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e){}
      }
      
      // 2. 無音ファイル再生（iOS等のバックグラウンド維持）
      if (!silenceAudio) { 
        silenceAudio = new Audio(silenceData); 
        silenceAudio.loop = true; 
        silenceAudio.volume = 0.01; 
      }
      await silenceAudio.play().catch(e => console.warn("Audio play failed", e));

      // 3. Web Audio API によるプロセス維持
      if (!audioCtx) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
        const buffer = audioCtx.createBuffer(1, 1, 22050);
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        source.connect(audioCtx.destination);
        source.start();
        audioCtx.onstatechange = () => {
          if (audioCtx.state === 'suspended' && localCallStartPressed) audioCtx.resume();
        };
      }
      if (audioCtx.state === 'suspended') await audioCtx.resume();

      // 4. Firebase接続維持（30秒間隔でサーバー時刻を書き込み、通信を継続させる）
      if (!keepAliveInterval) {
        keepAliveInterval = setInterval(async () => {
          if (localCallStartPressed && mySide) {
            const updateObj = {};
            updateObj[`lastActive/${mySide}`] = serverTimestamp();
            await update(callStatusRef, updateObj);
            console.log("Ping sent to Firebase (30s interval)");
          }
        }, 30000); 
      }

    } catch (err) { console.warn("Keep-alive Error:", err); }
  }

  function stopKeepAlive() {
    if (wakeLock) { try { wakeLock.release(); } catch(e){} wakeLock = null; }
    if (silenceAudio) { silenceAudio.pause(); }
    if (audioCtx) { try { audioCtx.close(); } catch(e){} audioCtx = null; }
    
    if (keepAliveInterval) {
      clearInterval(keepAliveInterval);
      keepAliveInterval = null;
    }
  }

  // 画面復帰（タブ切り替えやスリープ解除）時の自動再接続処理
  document.addEventListener('visibilitychange', async () => {
    if (document.visibilityState === 'visible' && localCallStartPressed) {
      if ('wakeLock' in navigator && !wakeLock) {
        try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e){}
      }
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      
      // 画面に戻ってきた際に接続状態を確認し、先手側ならOfferを再送して経路を復旧
      const snap = await get(callStatusRef);
      const data = snap.val();
      if (data && data.status === 'started' && mySide === 'S') {
        console.log("Recovery: Resending Offer...");
        sendOffer();
      }
    }
  });

  // --- WebRTC / 通話機能（ICE Restart統合） ---
  let localStream = null, peerConnection = null, localCallStartPressed = false, isMuted = false;
  const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
  const btnCallStart = document.getElementById('btnCallStart'), btnCallEnd = document.getElementById('btnCallEnd'), btnMute = document.getElementById('btnMute'), callStatusDisplay = document.getElementById('callStatusDisplay'), volumeControl = document.getElementById('volume-control');

  volumeControl.addEventListener('input', () => { const ra = document.getElementById('remote-audio'); if (ra) ra.volume = parseFloat(volumeControl.value); });
  btnMute.onclick = () => { if (!localStream) return; isMuted = !isMuted; localStream.getAudioTracks().forEach(t => t.enabled = !isMuted); btnMute.textContent = isMuted ? '解除' : 'ミュート'; btnMute.style.background = isMuted ? "var(--danger-btn)" : "#757575"; };

  async function startLocalStream() { 
    if (localStream) localStream.getTracks().forEach(t => t.stop()); 
    localStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }, video: false }); 
    return localStream; 
  }

  function createPeerConnection() {
    if (peerConnection && peerConnection.signalingState !== 'closed') return;
    peerConnection = new RTCPeerConnection(configuration);
    
    // ICE接続状態の監視（自動再接続用）
    peerConnection.oniceconnectionstatechange = () => {
      const state = peerConnection.iceConnectionState;
      console.log("ICE Connection:", state);
      if (state === "failed" || state === "disconnected") handleIceRestart();
    };

    peerConnection.ontrack = e => { const ra = document.getElementById('remote-audio'); if (ra) ra.srcObject = e.streams[0]; };
    if (localStream) localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
    peerConnection.onicecandidate = e => { if (e.candidate) push(ref(db, `${roomName}/signaling/candidates/${mySide}`), { candidate: e.candidate.toJSON() }); };
  }

  async function sendOffer() { 
    createPeerConnection(); 
    const offer = await peerConnection.createOffer(); 
    await peerConnection.setLocalDescription(offer); 
    await set(ref(db, `${roomName}/signaling/offer`), { sdp: offer.sdp, type: offer.type, from: mySide }); 
  }

  async function sendAnswer() { 
    const snap = await get(ref(db, `${roomName}/signaling/offer`)); 
    if (!snap.exists()) return; 
    const offer = snap.val(); 
    createPeerConnection(); 
    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer)); 
    const answer = await peerConnection.createAnswer(); 
    await peerConnection.setLocalDescription(answer); 
    await set(ref(db, `${roomName}/signaling/answer`), { sdp: answer.sdp, type: answer.type, from: mySide }); 
  }

  async function handleIceRestart() {
    if (!peerConnection || peerConnection.signalingState === 'closed') return;
    try {
      const offer = await peerConnection.createOffer({ iceRestart: true });
      await peerConnection.setLocalDescription(offer);
      await set(ref(db, `${roomName}/signaling/offer`), { sdp: offer.sdp, type: offer.type, from: mySide, isRestart: true });
    } catch (e) { console.error("Restart ICE failed:", e); }
  }

  // 修正後
btnCallStart.onclick = async () => { 
  if (localCallStartPressed) return; // 二重押し防止
  try { 
    await startKeepAlive(); 
    await startLocalStream(); 
    
    // 1. まず「自分が押した」という状態を確定させる
    localCallStartPressed = true; 
    updateCallUI(); 

    const snap = await get(callStatusRef); 
    let callData = snap.exists() ? snap.val() : { status: 'none', users: { S: false, G: false } }; 
    if (!callData.users) callData.users = { S: false, G: false }; 
    
    // 2. 自分のサイドのフラグだけを立ててFirebaseを更新
    callData.users[mySide] = true; 
    let newStatus = (callData.users.S && callData.users.G) ? 'started' : 'waiting'; 
    if (newStatus === 'started') await sendOffer(); 

    await update(callStatusRef, { status: newStatus, users: callData.users, timestamp: new Date().toISOString() }); 
  } catch (e) { 
    // エラー時はボタンを再度押せるように戻す
    localCallStartPressed = false; 
    updateCallUI(); 
    stopKeepAlive(); 
  } 
};

    // --- 通話終了ボタンの処理 ---
  btnCallEnd.onclick = async () => { 
    // 手動終了フラグを立てる（これでリロードが実行されるようになる）
    sessionStorage.setItem(`isManualEnd_${roomName}`, 'true');

    const snap = await get(callStatusRef);
    if (snap.exists()) {
      let data = snap.val();
      if (data.users) {
        data.users[mySide] = false;
        // 両方のフラグが落ちたら完全に終了（ended）にする
        if (!data.users.S && !data.users.G) {
          await update(callStatusRef, { status: 'ended', users: { S: false, G: false } });
          remove(signalingRef);
        } else {
          // 片方が残っているなら待機状態(waiting)に更新
          await update(callStatusRef, { status: 'waiting', users: data.users });
        }
      }
    }
    handleCallEndInternal(); 
  };

  function handleCallEndInternal() { 
    localCallStartPressed = false; 
    stopKeepAlive(); 
    if (peerConnection) { peerConnection.close(); peerConnection = null; } 
    if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; } 
    updateCallUI(); 

    // 手動終了ボタンが押されていた場合のみ、ページをリロードして初期化する
    if (sessionStorage.getItem(`isManualEnd_${roomName}`) === 'true') {
      sessionStorage.removeItem(`isManualEnd_${roomName}`);
      // reloaded_フラグは以前の仕様に合わせて一応残すか、不要なら削除
      sessionStorage.setItem(`reloaded_${roomName}`, '1'); 
      window.location.reload(); 
    }
  }

  // --- 通話ステータス監視 (リロード対策版) ---
    // ★1. ボタンの見た目を更新する関数を新しく追加します
  function updateCallUI() {
    // localCallStartPressed(通話中フラグ)がtrueなら、開始ボタンを押せなくする
    btnCallStart.disabled = localCallStartPressed;
    // 逆に終了ボタンとミュートボタンは押せるようにする
    btnCallEnd.disabled = !localCallStartPressed;
    btnMute.disabled = !localCallStartPressed;

    // 見た目の透明度も調整
    btnCallStart.style.opacity = localCallStartPressed ? "0.5" : "1";
    btnCallEnd.style.opacity = !localCallStartPressed ? "0.5" : "1";
  }

  // --- 通話ステータス監視 (リロード対策版) ---
  onValue(callStatusRef, async (snap) => { 
    const data = snap.val(); 
    if (!data) {
      updateCallUI();
      return;
    }
    
    if (data.status === 'ended') { 
      if (localCallStartPressed) {
        handleCallEndInternal();
      }
      updateCallUI(); // 終了時も見た目を更新
      return; 
    } 
    
    const iAmRegisteredOnFirebase = !!(data.users && data.users[mySide]);
    
    if (iAmRegisteredOnFirebase && !localCallStartPressed) {
      localCallStartPressed = true;
      
      // ★2. ここで見た目を即座に「通話中」の状態に切り替えます
      updateCallUI(); 

      try {
        await startKeepAlive();
        await startLocalStream();
        if (data.status === 'started' || (data.users.S && data.users.G)) {
          await sendOffer();
        }
      } catch (e) {
        console.error("Auto-resume call failed:", e);
        localCallStartPressed = false;
        updateCallUI(); // 失敗したら元に戻す
      }
    }

    // テキスト表示の更新
    if (data.status === 'started') {
      callStatusDisplay.textContent = "通話中"; 
    } else if (data.status === 'waiting') { 
      callStatusDisplay.textContent = localCallStartPressed ? "相手の応答待ち..." : "相手が通話を呼んでいます"; 
    } else { 
      callStatusDisplay.textContent = "オフライン"; 
    }

    // ★3. 念のため最後にもう一度見た目を確定させます
    updateCallUI(); 
  });

  onValue(ref(db, `${roomName}/signaling/offer`), snap => { const offer = snap.val(); if (offer && offer.from !== mySide) sendAnswer(); });
  onValue(ref(db, `${roomName}/signaling/answer`), async snap => { const answer = snap.val(); if (answer && answer.from !== mySide && peerConnection) await peerConnection.setRemoteDescription(new RTCSessionDescription(answer)); });
  onValue(ref(db, `${roomName}/signaling/candidates/S`), snap => { if (mySide === 'G' && peerConnection && snap.exists()) Object.values(snap.val()).forEach(d => peerConnection.addIceCandidate(new RTCIceCandidate(d.candidate))); });
  onValue(ref(db, `${roomName}/signaling/candidates/G`), snap => { if (mySide === 'S' && peerConnection && snap.exists()) Object.values(snap.val()).forEach(d => peerConnection.addIceCandidate(new RTCIceCandidate(d.candidate))); });

      // --- Firebase 将棋データ監視 ---
  onValue(gameRef, (snap) => {
    const data = snap.val();
    if (!data) return;

    // ★追加：初期化フラグ(lastTick=0)かつ対局未終了なら、感想戦モードを強制解除
    if (data.lastTick === 0 && !data.winner) {
      isReviewMode = false;
      sessionStorage.removeItem(`isReview_${roomName}`);
      Object.keys(sessionStorage).forEach(k => { if(k.startsWith("shown_")) sessionStorage.removeItem(k); });
      rvState = null; // 感想戦の盤面キャッシュを破棄
    }

    // 感想戦ボタンの活性状態を制御（勝者が決まっていない＝対局中なら無効。ただし準備中(lastTick=0)も無効）
    if (!data.winner || data.lastTick === 0) {
      document.getElementById('btnToggleReview').disabled = true;
    } else {
      document.getElementById('btnToggleReview').disabled = false;
    }

    state.board = JSON.parse(data.board);
    state.handS = data.handS || [];
    state.handG = data.handG || [];
    state.turn = data.turn || 'S';
    state.timers = data.timers || {S:600, G:600};
    state.config = data.config || {main:600, byo:30};

    if (typeof data.lastTick === 'number') {
      state.lastTick = data.lastTick;
    }
    state.winner = data.winner || null;    
    state.winReason = data.winReason || "";
    state.history = data.history || [];

    if (state.winner) showGameOverPopup(state.winner, state.winReason || "");

    // モード判定の同期
    const storedReview = sessionStorage.getItem(`isReview_${roomName}`) === "true";
    if (storedReview && data.winner) { // 勝者がいる場合のみ感想戦モードを許可
      isReviewMode = true;
      document.getElementById('btnToggleReview').textContent = "戻る";
      document.getElementById('review-panel').style.display = 'flex';
      if (!rvState) syncReviewStateLocally(); 
    } else {
      // 初期化された場合や対局中の場合
      isReviewMode = false;
      document.getElementById('btnToggleReview').textContent = "感想戦";
      document.getElementById('review-panel').style.display = 'none';
      viewIdx = state.history.length - 1; 
      syncReviewStateLocally(); 
    }

    render(); 
    updateKifuList();
    updateTimerDisplay();
    // 【追加修正】データ更新に伴い、準備ボタンの状態を再評価する
    get(readyRef).then(rsnap => {
      const rData = rsnap.val() || { S: false, G: false };
      const isDuringGame = (state.lastTick !== 0 && !state.winner);
      if (isDuringGame) {
        btnReady.disabled = true;
        btnReady.textContent = "対局中";
        btnReady.style.background = "#607d8b";
      } else {
        btnReady.disabled = false;
        btnReady.textContent = rData[mySide] ? "準備解除" : "対局準備完了";
        btnReady.style.background = rData[mySide] ? "#757575" : "#ff9800";
      }
    });
  });
  
    // --- 準備完了ステータスの監視 ---
  const btnReady = document.getElementById('btnReady');
  btnReady.onclick = async () => {
    const snap = await get(readyRef);
    let readyData = snap.exists() ? snap.val() : { S: false, G: false };
    readyData[mySide] = !readyData[mySide];
    await set(readyRef, readyData);
  };

    onValue(readyRef, (snap) => {
    const data = snap.val() || { S: false, G: false };
    document.getElementById('lamp-S').className = `ready-lamp ${data.S ? 'on' : ''}`;
    document.getElementById('lamp-G').className = `ready-lamp ${data.G ? 'on' : ''}`;

    // 対局中かどうかの判定を最新のstateに基づいて行う
    // lastTickが0、または勝敗が決まっている場合は「準備受付中」状態とする
    const isDuringGame = (state.lastTick !== 0 && !state.winner);

    if (isDuringGame) {
      btnReady.disabled = true;
      btnReady.textContent = "対局中";
      btnReady.style.background = "#607d8b";
    } else {
      btnReady.disabled = false;
      btnReady.textContent = data[mySide] ? "準備解除" : "対局準備完了";
      btnReady.style.background = data[mySide] ? "#757575" : "#ff9800";
    }

    // 両者が準備完了し、まだ対局が始まっていない場合にカウントダウン開始
    if (data.S && data.G && state.lastTick === 0 && !state.winner && !isCountingDown) {
      startCountdown();
    }
  });

    async function startCountdown() {
    if (isCountingDown) return; // 二重起動防止
    isCountingDown = true;
    const overlay = document.getElementById('countdown-overlay');
    const text = document.getElementById('countdown-text');
    overlay.style.display = 'flex';
    
    for (let i = 5; i >= 0; i--) {
      text.textContent = i === 0 ? "対局開始！" : i;
      text.style.transform = "scale(1.1)";
      await new Promise(r => setTimeout(r, 1000));
      text.style.transform = "scale(1.0)";
    }
    
    overlay.style.display = 'none';

        // ★修正：対局開始処理
    const snap = await get(gameRef);
    const cur = snap.exists() ? snap.val() : null;
    if (cur && (cur.lastTick === 0 || !cur.lastTick)) {
      // サーバー時刻を書き込む
      await update(gameRef, { 
        lastTick: serverTimestamp(),
        // 念のため、初期化時のタイマーも再セットしてズレを防止
        timers: state.config.main ? {S: state.config.main, G: state.config.main} : {S: 600, G: 600},
        updatedAt: serverTimestamp() 
      });
      await set(readyRef, { S: false, G: false });
    }
    
    // フラグのリセットを少し遅らせて連打を防止
    setTimeout(() => { isCountingDown = false; }, 2000);
  }

  onValue(reviewRef, (snap) => {
    if (!isReviewMode) return;
    const data = snap.val();
    if (data) {
        viewIdx = data.viewIdx;
        rvState = { board: JSON.parse(data.board), handS: data.handS || [], handG: data.handG || [] };
        render();
        updateKifuList();
    }
  });
  
  // --- チャット機能の追加 ---
  const chatLog = document.getElementById('chatLog');
  const chatInput = document.getElementById('chatInput');
  const btnSend = document.getElementById('btnSend');
  const btnClearChat = document.getElementById('btnClearChat'); // 消去ボタンを取得

  // 送信処理
  btnSend.onclick = async () => {
    const text = chatInput.value.trim();
    if (!text) return;
    const snap = await get(ref(db, `${roomName}/chatLog`));
    const logs = snap.val() || [];
    const senderName = (mySide === 'S') ? "先手" : "後手";
    logs.push({ 
      user: mySide, 
      name: senderName, 
      text: text, 
      time: new Date().toISOString() 
    });
    await set(ref(db, `${roomName}/chatLog`), logs);
    chatInput.value = '';
  };

  // チャット履歴の全削除（Firebase上のデータを消去）
  btnClearChat.onclick = async () => {
    if (confirm("チャットの履歴をすべて削除してもよろしいですか？")) {
      await remove(ref(db, `${roomName}/chatLog`));
    }
  };

  // エンターキー送信対応
  chatInput.onkeydown = (e) => { if(e.key === 'Enter') btnSend.click(); };

    // ログの監視と表示
  onValue(ref(db, `${roomName}/chatLog`), (snap) => {
    const logs = snap.val() || [];
    chatLog.innerHTML = '';
    // 最新50件を取得してループ
    logs.slice(-50).forEach(msg => {
      const div = document.createElement('div');
      div.className = 'chat-message';

      // 自分が書いた内容か他人が書いた内容かでクラスを分岐
      // (mySideが空の状態でも動作するように比較)
      const isMyMsg = (mySide !== '' && msg.user === mySide);
      const msgClass = isMyMsg ? 'chat-msg-self' : 'chat-msg-other';
      
      // HTMLを組み立て（名前の表示は無くし、色分け用のspanで囲む）
      div.innerHTML = `<span class="${msgClass}">${msg.text}</span>`;
      
      chatLog.appendChild(div);
    });
    // スクロール位置を一番下に調整
    chatLog.scrollTop = chatLog.scrollHeight;
  });

  // --- 将棋 UI / ロジック ---
  function setReviewMode(bool) {
    isReviewMode = bool;
    sessionStorage.setItem(`isReview_${roomName}`, bool.toString());
    document.getElementById('btnToggleReview').textContent = bool ? "戻る" : "感想戦";
    document.getElementById('review-panel').style.display = bool ? 'flex' : 'none';
    if (bool) pushReviewUpdate();
  }

  const cells = [];
  for (let y = 0; y < 9; y++) {
    cells[y] = [];
    for (let x = 0; x < 9; x++) {
      const c = document.createElement('div');
      c.className = 'cell';
      c.onclick = () => handleCellClick(x, y);
      boardEl.appendChild(c);
      cells[y][x] = c;
    }
  }

    function pushReviewUpdate() {
    if (!isReviewMode) return;
    set(reviewRef, { viewIdx: viewIdx, board: JSON.stringify(rvState.board), handS: rvState.handS || [], handG: rvState.handG || [], timestamp: getServerNow() });
  }

function finish(moveData) {
  // 消費時間の計算も補正後の現在時刻を使用
  const now = getServerNow(); 
  let newTimers = { ...state.timers };
  
  // 1. 持ち時間と秒読みの厳密な計算
  if (state.lastTick !== 0 && !state.winner) {
    // 指すまでにかかった秒数を計算
    const elapsedTotal = Math.floor((now - state.lastTick) / 1000);
    const currentMain = state.timers[state.turn];
    
    // 持ち時間が無制限（900000以上）でない場合
    if (currentMain < 900000) {
      // 持ち時間を減らす。消費が持ち時間を上回った場合は 0 になり、次手から秒読みが適用される
      newTimers[state.turn] = Math.max(0, currentMain - elapsedTotal);
    }
  }
  
  // 2. 反則判定
  let foulReason = "";
  if (isChecked(state.board, state.turn)) { 
    foulReason = "王手放置"; 
  } else if (moveData.isDrop && moveData.type === 'FU') {
    let count = 0;
    for (let y = 0; y < 9; y++) {
      if (state.board[y][moveData.toX]?.type === 'FU' && state.board[y][moveData.toX]?.owner === state.turn) count++;
    }
    if (count > 1) foulReason = "二歩";
  }

  const nextTurn = (state.turn === 'S' ? 'G' : 'S');

  if (foulReason) {
    state.winner = nextTurn;
    state.winReason = foulReason;
    state.history.push({ ...moveData, board: JSON.stringify(state.board), handS: [...(state.handS || [])], handG: [...(state.handG || [])], type: moveData.type + "(反則)" });
  } else {
    if (state.history.length > 2 && isCheckmate(state.board, nextTurn, state.handS, state.handG)) { 
      state.winner = state.turn; 
      state.winReason = "詰み"; 
    }
    state.history.push({ ...moveData, board: JSON.stringify(state.board), handS: [...(state.handS || [])], handG: [...(state.handG || [])] });
  }

  if (!state.winner) {
    state.turn = nextTurn;
  }

  sel = null; 
  selH = null; 
  possibleMoves = [];

    // ※ scriptの最初の方の import に serverTimestamp を追加してください
  // import { ..., serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

    // 3. Firebaseへ一括更新
  // lastTick を serverTimestamp() にすることで、
  // 通信ラグがある環境でも「サーバーが受信した正確な時刻」を起点にできます
  set(gameRef, { 
    board: JSON.stringify(state.board), 
    handS: state.handS || [], 
    handG: state.handG || [], 
    turn: state.turn, 
    timers: newTimers, 
    config: state.config, 
    lastTick: serverTimestamp(), 
    winner: state.winner || null, 
    winReason: state.winReason || "", 
    history: state.history,
    updatedAt: serverTimestamp() 
  });
}

  const isChecked = (board, owner) => {
    let kx = -1, ky = -1;
    for(let y=0; y<9; y++) for(let x=0; x<9; x++) if(board[y][x]?.type==='OU' && board[y][x]?.owner===owner) { kx=x; ky=y; break; }
    if (kx === -1) return false;
    const enemy = (owner === 'S' ? 'G' : 'S');
    for(let y=0; y<9; y++) for(let x=0; x<9; x++) if(board[y][x]?.owner === enemy) if(getRawMoves(x, y, board, enemy).some(m => m.x===kx && m.y===ky)) return true;
    return false;
  };

  function showGameOverPopup(winner, reason = "") {
    const key = `shown_${roomName}_${state.history.length}`;
    if (sessionStorage.getItem(key)) return;
    sessionStorage.setItem(key, "true");
    setReviewMode(true);
    syncReviewStateLocally(); 
    pushReviewUpdate();
    setTimeout(() => { alert((reason ? `${reason}により、` : "") + (winner === 'S' ? '先手▲' : '後手△') + "の勝ちです！"); }, 200);
  }

    // --- 駒落ち用初期配置生成関数 ---
  function generateInitialBoard(handicapType, uwateSide) {
    const board = Array(9).fill(null).map(() => Array(9).fill(null));
    const setup = (y, o, ps) => ps.forEach((p, x) => { if (p) board[y][x] = { type: p, owner: o } });
    // 平手配置
    setup(0, 'G', ['KY','KE','GI','KI','OU','KI','GI','KE','KY']);
    board[1][1] = { type: 'HI', owner: 'G' }; board[1][7] = { type: 'KA', owner: 'G' };
    setup(2, 'G', Array(9).fill('FU'));
    setup(6, 'S', Array(9).fill('FU'));
    board[7][1] = { type: 'KA', owner: 'S' }; board[7][7] = { type: 'HI', owner: 'S' };
    setup(8, 'S', ['KY','KE','GI','KI','OU','KI','GI','KE','KY']);

    // 駒落ち適用
    const isUwateG = (uwateSide === 'G');
    const uY0 = isUwateG ? 0 : 8; const uY1 = isUwateG ? 1 : 7;
    const del = (y, x) => { board[y][x] = null; };
    
    if(handicapType === "香落ち") del(uY0, isUwateG ? 0 : 8);
    else if(handicapType === "角落ち") del(uY1, isUwateG ? 7 : 1);
    else if(handicapType === "飛車落ち") del(uY1, isUwateG ? 1 : 7);
    else if(handicapType === "飛香落ち") { del(uY1, isUwateG ? 1 : 7); del(uY0, isUwateG ? 0 : 8); }
    else if(handicapType === "二枚落ち") { del(uY1, 1); del(uY1, 7); }
    else if(handicapType === "四枚落ち") { del(uY1, 1); del(uY1, 7); del(uY0, 0); del(uY0, 8); }
    else if(handicapType === "六枚落ち") { del(uY1, 1); del(uY1, 7); del(uY0, 0); del(uY0, 8); del(uY0, 1); del(uY0, 7); }
    else if(handicapType === "八枚落ち") { del(uY1, 1); del(uY1, 7); del(uY0, 0); del(uY0, 8); del(uY0, 1); del(uY0, 7); del(uY0, 2); del(uY0, 6); }
    return board;
  }

  // 設定ダイアログの開閉
  document.getElementById('btnSetting').onclick = () => { document.getElementById('setting-dialog').style.display = 'block'; };
  document.getElementById('btnSettingCancel').onclick = () => { document.getElementById('setting-dialog').style.display = 'none'; };

          // 設定適用ボタン
  document.getElementById('btnSettingSave').onclick = async () => {
    if(!confirm("設定を適用して初期化しますか？")) return;
    
    const hType = document.getElementById('cfgHandicap').value;
    const uSide = document.getElementById('cfgUwateSide').value;
    const mainMin = parseInt(document.getElementById('cfgMain').value) || 0;
    const byoSec = parseInt(document.getElementById('cfgByo').value) || 30;
    
    const m = mainMin * 60;
    const b = byoSec;
    const bStr = JSON.stringify(generateInitialBoard(hType, uSide));

    // 1. 将棋データの初期化（initAtを追加し、初期化が行われたことを他方に通知）
    await set(gameRef, { 
      board: bStr, 
      handS: [], 
      handG: [], 
      turn: 'S', 
      timers: {S: m, G: m}, 
      config: {main: m, byo: b, handicap: hType}, 
      lastTick: 0, 
      winner: null, 
      winReason: "", 
      initAt: serverTimestamp(), // ★初期化実行時刻を記録
      history: [{ board: bStr, handS: [], handG: [], type: `${hType} (${mainMin}分/${byoSec}秒)` }] 
    });

    // 2. 準備状態の完全リセット
    await set(readyRef, { S: false, G: false });

        // 3. ローカルの感想戦セッションをクリア
    sessionStorage.removeItem(`isReview_${roomName}`);
    Object.keys(sessionStorage).forEach(k => { if(k.startsWith("shown_")) sessionStorage.removeItem(k); });
    
    // 4. 自サイドの選択をリセット（未選択に戻す）
    mySide = '';
    sessionStorage.removeItem(`mySide_${roomName}`);
    mySideSelect.value = '';
    
    document.getElementById('setting-dialog').style.display = 'none';
    render(); // 再描画して反映
  };  
  
  function syncReviewStateLocally() { 
    if (viewIdx < 0 || viewIdx >= state.history.length) viewIdx = state.history.length - 1; 
    const hist = state.history[viewIdx]; 
    rvState = { board: JSON.parse(hist.board), handS: [...(hist.handS || [])], handG: [...(hist.handG || [])] }; 
    sel = null; selH = null; possibleMoves = []; 
  }

    function handleCellClick(x, y) {
  if (isReviewMode) {
    const target = rvState.board[y][x];
    if (sel && sel.x === x && sel.y === y) {
      sel = null;
      possibleMoves = [];
      render();
      return;
    }

    // 移動先をクリック
    if (sel && possibleMoves.some(m => m.x === x && m.y === y)) {
      const fromP = rvState.board[sel.y][sel.x];
      if (!fromP) return;

      const moveData = {
        side: fromP.owner,
        fromX: sel.x,
        fromY: sel.y,
        toX: x,
        toY: y,
        type: fromP.type,
        isDrop: false,
        isPromoted: false
      };
      const promLine = (fromP.owner === 'S') ? [0, 1, 2] : [6, 7, 8];

      // 駒取り処理
      if (target && target.owner !== fromP.owner) {
        (fromP.owner === 'S' ? rvState.handS : rvState.handG).push(UNPROMOTE_MAP[target.type] || target.type);
      }

      if (PROMOTE_MAP[fromP.type] && (promLine.includes(y) || promLine.includes(sel.y))) {
        pendingProm = { x, y, moveData };
        document.getElementById('promote-dialog').style.display = 'block';
      } else {
        // 先に移動元を消去してから移動先に配置（消失防止）
        const movingPiece = { type: fromP.type, owner: fromP.owner };
        rvState.board[sel.y][sel.x] = null;
        rvState.board[y][x] = movingPiece;
        sel = null;
        possibleMoves = [];
        pushReviewUpdate();
      }
      render();
      return;
    }

    // 持ち駒を打つ
    if (selH) {
      if (!target) {
        const targetHand = (selH.owner === 'S' ? rvState.handS : rvState.handG);
        if (targetHand && targetHand[selH.idx] === selH.type) {
          rvState.board[y][x] = { type: selH.type, owner: selH.owner };
          targetHand.splice(selH.idx, 1);
          selH = null;
          pushReviewUpdate();
          render();
        } else {
          selH = null;
          render();
        }
      } else {
        selH = null;
        render();
      }
      return;
    }

    // 駒を選択
    if (target) {
      sel = { x, y };
      possibleMoves = getRawMoves(x, y, rvState.board, target.owner);
      render();
    }
    return;
  }

  // --- 以下、対局モード ---
  if (state.lastTick === 0) return;
  if (state.winner || state.turn !== mySide || pendingProm) return;

  const target = state.board[y][x];
  if (sel && sel.x === x && sel.y === y) {
    sel = null;
    possibleMoves = [];
    render();
    return;
  }

  // 移動先をクリック
  if (sel && possibleMoves.some(m => m.x === x && m.y === y)) {
    const fromP = state.board[sel.y][sel.x];
    if (!fromP) return;

    const moveData = {
      side: mySide,
      fromX: sel.x,
      fromY: sel.y,
      toX: x,
      toY: y,
      type: fromP.type,
      isDrop: false,
      isPromoted: false
    };
    const promLine = (mySide === 'S') ? [0, 1, 2] : [6, 7, 8];

    // 駒取り
    if (target && target.owner !== mySide) {
      const h = (mySide === 'S' ? state.handS : state.handG) || [];
      h.push(UNPROMOTE_MAP[target.type] || target.type);
      if (mySide === 'S') state.handS = h;
      else state.handG = h;
    }

    if (PROMOTE_MAP[fromP.type] && (promLine.includes(y) || promLine.includes(sel.y))) {
      const deadLine = (mySide === 'S') ? 0 : 8;
      if (((fromP.type === 'FU' || fromP.type === 'KY') && y === deadLine) || (fromP.type === 'KE' && (mySide === 'S' ? y <= 1 : y >= 7))) {
        state.board[sel.y][sel.x] = null;
        state.board[y][x] = { type: PROMOTE_MAP[fromP.type], owner: mySide };
        moveData.type = PROMOTE_MAP[fromP.type];
        moveData.isPromoted = true;
        finish(moveData);
      } else {
        pendingProm = { x, y, moveData };
        document.getElementById('promote-dialog').style.display = 'block';
        render();
      }
    } else {
      state.board[sel.y][sel.x] = null;
      state.board[y][x] = { type: fromP.type, owner: mySide };
      finish(moveData);
    }
    return;
  }

  // 持ち駒を打つ
  if (selH) {
    if (!target) {
      const targetHand = (mySide === 'S' ? state.handS : state.handG);
      if (targetHand && targetHand[selH.idx] === selH.type) {
        state.board[y][x] = { type: selH.type, owner: mySide };
        targetHand.splice(selH.idx, 1);
        finish({ side: mySide, toX: x, toY: y, type: selH.type, isDrop: true });
      } else {
        selH = null;
        render();
      }
    } else {
      selH = null;
      render();
    }
    return;
  }

  // 駒を選択
  if (target && target.owner === mySide) {
    sel = { x, y };
    possibleMoves = getRawMoves(x, y, state.board, mySide);
    render();
  }
} // handleCellClick 終了

function render() {
  if (isReviewMode && !rvState) {
    if (state.history && state.history.length > 0) {
      syncReviewStateLocally();
    } else {
      return;
    }
  }

  let b, hs, hg;
  if (isReviewMode) {
    b = rvState.board;
    hs = rvState.handS;
    hg = rvState.handG;
  } else {
    b = state.board;
    hs = state.handS;
    hg = state.handG;
  }

  // 盤面の描画
  for (let y = 0; y < 9; y++) {
    for (let x = 0; x < 9; x++) {
      const c = cells[y][x];
      const p = b[y][x];
      c.className = `cell ${sel?.x===x && sel?.y===y ? 'selected' : ''}`;

      if (p) {
        const isOpposite = (p.owner === 'G');
        const promotedClass = UNPROMOTE_MAP[p.type] ? 'promoted' : '';
        const rotClass = isOpposite ? 'opposite' : '';
        c.innerHTML = `<div class="piece piece-font ${rotClass} ${promotedClass}">${SYMBOLS[p.type]}</div>`;
      } else {
        c.innerHTML = '';
      }
    }
  }

        const drawH = (id, list, owner) => {
    const el = document.getElementById(id);
    el.innerHTML = '';
    // 駒の種類と表示順序を定義
    const HAND_ORDER = ['HI', 'KA', 'KI', 'GI', 'KE', 'KY', 'FU'];
    
    // 現在持っている駒を枚数集計
    const counts = {};
    (list || []).forEach(type => { counts[type] = (counts[type] || 0) + 1; });

    // 持っている駒の種類だけを、定義した順序で抽出
    const existingTypes = HAND_ORDER.filter(type => counts[type] > 0);

    // 常に7つのスロットを作成し、持っている駒を上から順に詰めて表示
    for (let i = 0; i < 7; i++) {
      const slot = document.createElement('div');
      slot.className = 'hand-slot';
      
      const type = existingTypes[i]; // 上から順に駒を割り当て

      if (type) {
        const s = document.createElement('span');
        s.className = 'piece-font';
        s.textContent = SYMBOLS[type];
        
        // 枚数ラベル
        if (counts[type] > 1) {
          const c = document.createElement('div');
          c.className = 'hand-count';
          c.textContent = `×${counts[type]}`;
          slot.appendChild(c);
        }

        // 選択処理
        const firstIdx = list.indexOf(type);
        if (selH && selH.type === type && selH.owner === owner) {
          s.classList.add('selected-piece');
        }

        s.onclick = (e) => {
          e.stopPropagation();
          if (!isReviewMode) {
            if (state.lastTick === 0 || state.winner || state.turn !== mySide || owner !== mySide) return;
          }
          if (selH && selH.type === type && selH.owner === owner) {
            selH = null;
          } else {
            selH = { type: type, owner, idx: firstIdx };
            sel = null;
            possibleMoves = [];
          }
          render();
        };
        slot.appendChild(s);
      }
      el.appendChild(slot);
    }
  };

  drawH('handS', hs, 'S');
  drawH('handG', hg, 'G');

  const st = document.getElementById('status-txt');
  if (state.winner && !isReviewMode) {
    st.textContent = `${state.winner === 'S' ? '先手' : '後手'}勝`;
    st.style.color = "red";
  } else if (isReviewMode) {
    st.textContent = "感想戦";
    st.style.color = "orange";
  } else {
    st.textContent = state.turn === mySide ? "手番" : "待機";
    st.style.color = "black";
  }

  document.getElementById('nav-pos').textContent = `${viewIdx}/${state.history.length-1}`;
  document.getElementById('timer-S').className = `timer ${!isReviewMode && state.turn==='S'?'your-turn':''}`;
  document.getElementById('timer-G').className = `timer ${!isReviewMode && state.turn==='G'?'your-turn':''}`;
} // render 終了

  // 棋譜リストの更新
  function updateKifuList() {
    const container = document.getElementById('kifu-container'); 
    container.innerHTML = '';
    state.history.forEach((h, i) => {
      const div = document.createElement('div'); 
      div.className = `kifu-item ${isReviewMode && viewIdx === i ? 'active' : ''}`;
      div.textContent = formatKifuText(h, i);
      div.onclick = () => { 
        if (!isReviewMode) setReviewMode(true); 
        viewIdx = i; syncReviewStateLocally(); pushReviewUpdate(); render(); updateKifuList(); 
      };
      container.appendChild(div); 
      if (isReviewMode && viewIdx === i) div.scrollIntoView({ block: 'nearest' });
    });
  }

        // 棋譜リストの表示テキストを生成
    function formatKifuText(move, idx) {
    if (idx === 0) return "開始";
    if (!move) return `${idx}.不明`;
    const side = move.side === 'S' ? "▲" : "△";

    // 短縮表示：特殊な終了理由は最優先
    if (move.type.includes("投了")) return `${idx}.${side}投了`;
    if (move.type.includes("時間切れ")) return `${idx}.${side}切れ負`;
    if (move.type.includes("反則")) return `${idx}.${side}反則`;
    if (typeof move.toX !== 'number' || typeof move.toY !== 'number') return `${idx}.${side}中断`;

    const x = 9 - move.toX, y = KANJI_NUM[move.toY + 1];
    const isSame = (idx > 1 && move.toX === state.history[idx-1].toX && move.toY === state.history[idx-1].toY);
    
    let typeName = move.type.replace("(反則)","").replace("投了","").replace("時間切れ","");
    let type = SYMBOLS[typeName] || "？";
    if (move.isPromoted) type += "成"; 
    else if (move.isDrop) type += "打";
    
    return `${idx}.${side}${isSame ? "同" : x+y}${type}`;
  }

function updateTimerDisplay() {
  // Date.now() ではなく補正後の時刻を使用
  const now = getServerNow(); 
  
    // 経過秒の計算
  // 0.5秒程度の余裕(500ms引く)を持たせることで、通信ラグによる「10:01」跳ねを物理的に防ぎます
  const diff = now - state.lastTick;
  const elapsed = (state.lastTick === 0 || isReviewMode || state.winner) ? 0 : Math.floor(Math.max(0, diff - 200) / 1000);

  ['S', 'G'].forEach(s => {
    let remMain = state.timers[s]; 
    let displayStr = ""; 
    let isByoAlert = false; 
    const el = document.getElementById(`timer-${s}`);
    if (!el) return;
    const mark = (s === 'S' ? '▲' : '△');

    const isMainInf = (remMain >= 900000);
    const isByoInf = (state.config.byo >= 900000);

    if (state.turn === s && !state.winner && !isReviewMode && state.lastTick !== 0) {
      // 手番側の計算
      if (isMainInf) {
        displayStr = `${mark} 無制限`;
      } else if (remMain > elapsed) {
        // 持ち時間がある
        const currentRem = remMain - elapsed;
        displayStr = `${mark} ${Math.floor(currentRem/60)}:${(currentRem%60).toString().padStart(2,'0')}`;
      } else {
        // 秒読みフェーズ
        if (isByoInf) {
          displayStr = `${mark} 秒:無制限`;
        } else {
          // 秒読み計算：(elapsed - remMain) は「持ち時間を使い切ってから何秒経過したか」を示す
          const overTime = Math.max(0, elapsed - remMain);
          const byoRem = Math.max(0, (state.config.byo || 30) - overTime);
          
          displayStr = `${mark} 秒:${byoRem}`;
          if (byoRem <= 5) isByoAlert = true;
          
          // タイムアップ判定
          if (byoRem <= 0 && s === mySide && !state.winner) {
            state.winner = (mySide === 'S' ? 'G' : 'S'); 
            state.winReason = "時間切れ"; 
            finish({ side: s, type: "時間切れ", toX: null, toY: null }); 
          }
        }
      }
    } else {
      // 待機側または停止中
      if (isMainInf) {
        displayStr = `${mark} 無制限`;
      } else if (remMain > 0) {
        displayStr = `${mark} ${Math.floor(remMain/60)}:${(remMain%60).toString().padStart(2,'0')}`;
      } else {
        displayStr = `${mark} 秒:${isByoInf ? '無制限' : (state.config.byo || 30)}`;
      }
    }
    
    el.textContent = displayStr; 
    if (isByoAlert) el.classList.add('timer-alert'); 
    else el.classList.remove('timer-alert');
  });
}

  setInterval(updateTimerDisplay, 1000);

  document.getElementById('btnToggleReview').onclick = () => { setReviewMode(!isReviewMode); if(isReviewMode) { syncReviewStateLocally(); pushReviewUpdate(); } render(); updateKifuList(); };
  document.getElementById('nav-prev').onclick = () => { if (viewIdx > 0) { viewIdx--; syncReviewStateLocally(); pushReviewUpdate(); render(); updateKifuList(); } };
  document.getElementById('nav-next').onclick = () => { if (viewIdx < state.history.length - 1) { viewIdx++; syncReviewStateLocally(); pushReviewUpdate(); render(); updateKifuList(); } };
  document.getElementById('nav-first').onclick = () => { if (isReviewMode) { viewIdx = 0; syncReviewStateLocally(); pushReviewUpdate(); render(); updateKifuList(); } };
  document.getElementById('nav-last').onclick = () => { if (isReviewMode) { viewIdx = state.history.length - 1; syncReviewStateLocally(); pushReviewUpdate(); render(); updateKifuList(); } };
        document.getElementById('btn-prom-yes').onclick = () => { 
    pendingProm.moveData.type = PROMOTE_MAP[pendingProm.moveData.type]; 
    pendingProm.moveData.isPromoted = true; 
    // ※ state.board への直接代入を削除（endProm内でモード別に処理するため）
    endProm(); 
  };
  document.getElementById('btn-prom-no').onclick = () => endProm();
      function endProm() { 
    const d = pendingProm.moveData; 
    const tx = pendingProm.x;
    const ty = pendingProm.y;

    if (isReviewMode) {
      // 感想戦：移動元を消し、移動先に駒を置く（成る場合はd.typeが既に書き換わっている）
      rvState.board[ty][tx] = { type: d.type, owner: d.side };
      rvState.board[d.fromY][d.fromX] = null;
      sel = null; 
      possibleMoves = [];
      pushReviewUpdate();
    } else {
      // 対局モード
      state.board[ty][tx] = { type: d.type, owner: d.side };
      state.board[d.fromY][d.fromX] = null;
      finish(d); 
    }

    pendingProm = null; 
    document.getElementById('promote-dialog').style.display = 'none'; 
    render(); 
  }

  const getRawMoves = (x, y, board, owner) => {
    const moves = []; const p = board[y][x]; if (!p) return moves; const f = (owner === 'S' ? -1 : 1);
    const add = (tx, ty) => { if (tx>=0 && tx<9 && ty>=0 && ty<9 && board[ty][tx]?.owner !== owner) moves.push({x:tx, y:ty}); };
    const slide = (vx, vy) => { let tx = x + vx, ty = y + vy; while (tx>=0 && tx<9 && ty>=0 && ty<9) { if (board[ty][tx]) { if (board[ty][tx].owner !== owner) moves.push({x:tx, y:ty}); break; } moves.push({x:tx, y:ty}); tx += vx; ty += vy; } };
    const t = p.type;
    if (['KI','TO','NY','NK','NG'].includes(t)) [[-1,f],[0,f],[1,f],[-1,0],[1,0],[0,-f]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='FU') add(x, y+f); else if (t==='KY') slide(0, f); else if (t==='KE') { add(x-1,y+f*2); add(x+1,y+f*2); }
    else if (t==='GI') [[-1,f],[0,f],[1,f],[-1,-f],[1,-f]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='KA') [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>slide(vx,vy));
    else if (t==='HI') [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>slide(vx,vy));
    else if (t==='OU') [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='UM') { [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>slide(vx,vy)); [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>add(x+vx,y+vy)); }
    else if (t==='RY') { [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>slide(vx,vy)); [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>add(x+vx,y+vy)); }
    return moves;
  };
  document.getElementById('btnResign').onclick = () => { if (state.winner || state.turn !== mySide) return; if (confirm("投了しますか？")) { state.winner = (mySide === 'S' ? 'G' : 'S'); state.winReason = "投了"; finish({ side: mySide, type: "投了" }); } };
        document.getElementById('btnKif').onclick = () => {
    const hType = state.config.handicap || "平手";
    const isHirate = (hType === "平手");

    let kif = "# ----  ぴよ将棋 棋譜ファイル  ----\n";
    kif += "棋戦：\n戦型：\n開始日時：\n終了日時：\n";
    
    // 手合割の出力
    if (isHirate) {
      kif += "手合割：平手\n先手：先手\n後手：後手\n";
    } else {
      kif += "手合割：その他\n";
      // 駒落ち盤面の生成 (history[0]のboardを使用)
      const startBoard = JSON.parse(state.history[0].board);
      const startHandS = state.history[0].handS || [];
      const startHandG = state.history[0].handG || [];

      const getHandStr = (h) => (h.length === 0 ? "なし" : h.map(t => SYMBOLS[t]).join(" "));
      kif += `上手の持駒：${getHandStr(startHandG)}\n`;
      kif += "  ９ ８ ７ ６ ５ ４ ３ ２ １\n+---------------------------+\n";
      for (let y = 0; y < 9; y++) {
        let row = "|";
        for (let x = 0; x < 9; x++) {
          const p = startBoard[y][x];
          if (!p) row += " ・";
          else {
            const sym = SYMBOLS[p.type];
            row += (p.owner === 'G' ? "v" : " ") + sym;
          }
        }
        row += "|" + KANJI_NUM[y + 1] + "\n";
        kif += row;
      }
      kif += "+---------------------------+\n";
      kif += `下手の持駒：${getHandStr(startHandS)}\n\n`;
      kif += "下手番\n下手：\n上手：\n";
    }

    kif += "手数----指手---------消費時間--\n";

    state.history.forEach((h, i) => {
      if (i === 0) return;
      let moveText = "";

      if (h.type.includes("投了") || h.type.includes("時間切れ") || h.type.includes("反則")) {
        moveText = "投了       ";
      } else if (typeof h.toX !== 'number') {
        moveText = "中断       ";
      } else {
        const isSame = (i > 1 && h.toX === state.history[i-1].toX && h.toY === state.history[i-1].toY);
        const pos = isSame ? "同　" : ZEN_NUM[9 - h.toX] + KANJI_NUM[h.toY + 1];
        
        let pieceName = h.isPromoted ? (SYMBOLS[UNPROMOTE_MAP[h.type] || h.type] + "成") : SYMBOLS[h.type.replace("(反則)", "")];
        // 駒名が1文字の場合は、後ろにスペースを入れずに座標を繋げる
        const from = h.isDrop ? "打" : `(${9 - h.fromX}${h.fromY + 1})`;
        moveText = (pos + pieceName + from).padEnd(11, " ");
      }

      const lineNum = String(i).padStart(4, " ");
      kif += `${lineNum} ${moveText}( 0:00/00:00:00)\n`;
    });

    const area = document.createElement("textarea");
    area.value = kif;
    document.body.appendChild(area);
    area.select();
    try {
      document.execCommand("copy");
      alert("ぴよ将棋形式(KIF)でコピーしました。");
    } catch (err) {
      alert("コピー失敗");
    }
    document.body.removeChild(area);
  };  

  function isCheckmate(board, turn, handS, handG) {
    for (let y = 0; y < 9; y++) for (let x = 0; x < 9; x++) if (board[y][x]?.owner === turn) { const moves = getRawMoves(x, y, board, turn); for (let m of moves) { const tb = JSON.parse(JSON.stringify(board)); tb[m.y][m.x] = tb[y][x]; tb[y][x] = null; if (!isChecked(tb, turn)) return false; } }
    const h = (turn === 'S' ? handS : handG) || []; for (let type of [...new Set(h)]) for (let y = 0; y < 9; y++) for (let x = 0; x < 9; x++) if (!board[y][x]) { const tb = JSON.parse(JSON.stringify(board)); tb[y][x] = { type, owner: turn }; if (!isChecked(tb, turn)) return false; }
    return true;
  }
</script>
</body>
</html>
