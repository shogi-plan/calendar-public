<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>遠タメ将棋 Online</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
  <style>
    :root { --board-color: #edc9af; --primary-btn: #2196f3; --danger-btn: #d32f2f; }
    body { font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", sans-serif; display: flex; flex-direction: column; align-items: center; background: #eee; margin: 0; padding: 5px; touch-action: manipulation; }
    h1 { font-size: 1.1rem; margin: 4px 0; }
    
    /* ステータス・タイマー */
    .status-area { display: flex; gap: 10px; margin-bottom: 5px; width: 100%; max-width: 500px; justify-content: center; }
    .timer { font-family: monospace; font-size: 18px; font-weight: bold; background: #fff; padding: 4px 8px; border: 2px solid #555; border-radius: 4px; flex: 1; text-align: center; max-width: 120px; }
    .your-turn { border-color: var(--danger-btn) !important; background: #ffebee; box-shadow: 0 0 5px var(--danger-btn); }

    /* 盤面 */
    #board-container { position: relative; width: 95vmin; height: 95vmin; max-width: 500px; max-height: 500px; }
    #board { display: grid; grid-template-columns: repeat(9, 1fr); grid-template-rows: repeat(9, 1fr); border: 2px solid #222; width: 100%; height: 100%; background: var(--board-color); }
    .cell { display: flex; align-items: center; justify-content: center; border: 0.5px solid rgba(0,0,0,0.2); cursor: pointer; }
    .selected { background: rgba(255, 215, 0, 0.6) !important; }
    .piece { font-weight: bold; font-size: clamp(18px, 7vmin, 32px); z-index: 10; pointer-events: none; }
    .piece.opposite { transform: rotate(180deg); }
    .piece.promoted { color: var(--danger-btn); }

    /* コントロールパネル */
    .controls { display: flex; gap: 4px; margin: 8px 0; flex-wrap: wrap; justify-content: center; background: #ddd; padding: 8px; border-radius: 8px; width: 100%; max-width: 500px; box-sizing: border-box; }
    .controls select, .controls input { padding: 4px; font-size: 14px; }
    button { cursor: pointer; border: none; border-radius: 4px; font-weight: bold; padding: 8px 12px; font-size: 14px; }
    #btnReset { background: var(--danger-btn); color: white; }
    #btnToggleReview { background: var(--primary-btn); color: white; }
    #btnResign { background: #555; color: white; }
    #btnFlip { background: #6d4c41; color: white; }

    /* 持ち駒エリア（左右分割） */
    #hands-container { display: flex; width: 100%; max-width: 500px; gap: 5px; margin-top: 5px; }
    .hand { flex: 1; min-height: 50px; border: 1px solid #999; background: #fff; display: flex; flex-wrap: wrap; padding: 20px 4px 4px 4px; gap: 4px; border-radius: 4px; position: relative; box-sizing: border-box; }
    .hand::before { content: attr(data-label); position: absolute; top: 2px; left: 4px; font-size: 11px; color: #333; font-weight: bold; }
    .hand span { border: 1px solid #777; padding: 2px 6px; background: #f0f0f0; cursor: pointer; font-size: 18px; border-radius: 3px; font-weight: bold; }

    /* 感想戦パネル */
    #review-panel { display: none; width: 100%; max-width: 500px; background: #fff; border: 1px solid #999; border-radius: 5px; margin-top: 10px; padding: 8px; box-sizing: border-box; }
    .kifu-list { height: 100px; overflow-y: scroll; border: 1px solid #ccc; margin-bottom: 8px; background: #fafafa; font-size: 13px; }
    .kifu-item { padding: 4px 8px; cursor: pointer; border-bottom: 1px solid #eee; }
    .kifu-item.active { background: var(--primary-btn); color: white; }
    .nav-controls { display: flex; justify-content: center; gap: 15px; align-items: center; }
    .nav-btn { font-size: 20px; padding: 5px 20px; background: #eee; border: 1px solid #999; }

    /* ダイアログ */
    #promote-dialog { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border: 4px solid #5d4037; z-index: 2000; text-align: center; border-radius: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
  </style>
</head>
<body>

<h1>遠タメ将棋 Online</h1>

<div class="controls">
  <div style="font-size:12px; margin-bottom:5px; width:100%; text-align:center;">
    持時間:<input type="number" id="cfgMain" value="10" style="width:35px">分 / 
    秒読:<input type="number" id="cfgByo" value="30" style="width:35px">秒
    <button id="btnReset">初期化</button>
  </div>
  <select id="mySideSelect"><option value="S">先手(▲)</option><option value="G">後手(△)</option></select>
  <button id="btnFlip">盤反転</button>
  <button id="btnToggleReview">感想戦開始</button>
  <button id="btnResign">投了</button>
  <div id="status-txt" style="font-size:13px; font-weight:bold; width:100%; text-align:center; margin-top:5px;">接続待ち...</div>
</div>

<div class="status-area">
  <div id="timer-S" class="timer">▲ --:--</div>
  <div id="timer-G" class="timer">△ --:--</div>
</div>

<div id="board-container">
  <div id="board"></div>
  <div id="promote-dialog">
    <div style="margin-bottom:10px; font-weight:bold;">成りますか？</div>
    <button id="btn-prom-yes" style="background:var(--danger-btn); color:white; margin:5px;">成る</button>
    <button id="btn-prom-no" style="background:#757575; color:white; margin:5px;">成らず</button>
  </div>
</div>

<div id="hands-container">
  <div class="hand" id="handS" data-label="▲先手"></div>
  <div class="hand" id="handG" data-label="△後手"></div>
</div>

<div id="review-panel">
  <div id="kifu-container" class="kifu-list"></div>
  <div class="nav-controls">
    <button id="nav-prev" class="nav-btn">＜</button>
    <span id="nav-pos" style="font-weight:bold;">0 / 0</span>
    <button id="nav-next" class="nav-btn">＞</button>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

  const firebaseConfig = {
      apiKey: "AIzaSyCx5anv3WWOQyke9kqhhZ9Zx-RjynLuxzE",
      authDomain: "calendar-chousei.firebaseapp.com",
      databaseURL: "https://calendar-chousei-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "calendar-chousei",
      storageBucket: "calendar-chousei.firebasestorage.app",
      messagingSenderId: "368704703397",
      appId: "1:368704703397:web:86ae24d920aaf7c5a0f64c"
  };
  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const roomName = location.pathname.split('/').pop().replace('.html', '') || "shogi_room";
  const gameRef = ref(db, `${roomName}/shogiData`);

  // 表示用シンボル（一文字に統一）
  const SYMBOLS = {FU:'歩',KY:'香',KE:'桂',GI:'銀',KI:'金',KA:'角',HI:'飛',OU:'玉',TO:'と',NY:'杏',NK:'圭',NG:'全',UM:'馬',RY:'龍'};
  const PROMOTE_MAP = {FU:'TO',KY:'NY',KE:'NK',GI:'NG',KA:'UM',HI:'RY'};
  const UNPROMOTE_MAP = {TO:'FU',NY:'KY',NK:'KE',NG:'GI',UM:'KA',RY:'HI'};
  const KANJI_NUM = ["","一","二","三","四","五","六","七","八","九"];

  let state = { board: "[]", handS: [], handG: [], turn: 'S', timers: {S: 600, G: 600}, config: {main: 600, byo: 30}, lastTick: 0, history: [], winner: null };
  let mySide = 'S', sel = null, selH = null, possibleMoves = [], pendingProm = null;
  let isReviewMode = false, viewIdx = -1;

  const boardEl = document.getElementById('board');
  const cells = [];
  for (let y = 0; y < 9; y++) {
    cells[y] = [];
    for (let x = 0; x < 9; x++) {
      const c = document.createElement('div');
      c.className = 'cell';
      c.onclick = () => handleCellClick(x, y);
      boardEl.appendChild(c);
      cells[y][x] = c;
    }
  }

  // --- 王手・詰み判定 (ロジック固定) ---
  const isChecked = (board, owner) => {
    let kx = -1, ky = -1;
    for(let y=0; y<9; y++) for(let x=0; x<9; x++) if(board[y][x]?.type==='OU' && board[y][x]?.owner===owner) { kx=x; ky=y; break; }
    if (kx === -1) return false;
    const enemy = (owner === 'S' ? 'G' : 'S');
    for(let y=0; y<9; y++) for(let x=0; x<9; x++) if(board[y][x]?.owner === enemy) if(getRawMoves(x, y, board, enemy).some(m => m.x===kx && m.y===ky)) return true;
    return false;
  };

  const isCheckmate = (board, turn, handS, handG) => {
    for (let y = 0; y < 9; y++) {
      for (let x = 0; x < 9; x++) {
        if (board[y][x]?.owner === turn) {
          const moves = getRawMoves(x, y, board, turn);
          for (let m of moves) {
            const tempBoard = JSON.parse(JSON.stringify(board));
            tempBoard[m.y][m.x] = tempBoard[y][x]; tempBoard[y][x] = null;
            if (!isChecked(tempBoard, turn)) return false;
          }
        }
      }
    }
    const hand = (turn === 'S' ? handS : handG) || [];
    for (let type of [...new Set(hand)]) {
      for (let y = 0; y < 9; y++) {
        for (let x = 0; x < 9; x++) {
          if (!board[y][x]) {
            const tempBoard = JSON.parse(JSON.stringify(board));
            tempBoard[y][x] = { type, owner: turn };
            if (!isChecked(tempBoard, turn)) return false;
          }
        }
      }
    }
    return true;
  };

  function finish(moveData) {
    if (state.lastTick !== 0) {
      const diff = Math.floor((Date.now() - state.lastTick) / 1000);
      state.timers[state.turn] = Math.max(0, state.timers[state.turn] - diff);
    }
    state.lastTick = Date.now();
    const nextTurn = (state.turn === 'S' ? 'G' : 'S');
    if (isCheckmate(state.board, nextTurn, state.handS, state.handG)) { state.winner = state.turn; }
    state.turn = nextTurn;
    sel = null; selH = null; possibleMoves = [];
    if (!state.history) state.history = [{ board: JSON.stringify(state.board), handS: [], handG: [], type: '開始' }];
    state.history.push({ ...moveData, board: JSON.stringify(state.board), handS: [...(state.handS || [])], handG: [...(state.handG || [])] });
    set(gameRef, { ...state, board: JSON.stringify(state.board) });
    if (state.winner) setTimeout(() => alert(`${state.winner === 'S' ? '先手' : '後手'}の勝ちです！`), 100);
  }

  document.getElementById('btnReset').onclick = () => {
    if(!confirm("設定を反映し盤面を初期化しますか？")) return;
    const m = (parseInt(document.getElementById('cfgMain').value) || 10) * 60;
    const b = (parseInt(document.getElementById('cfgByo').value) || 30);
    const board = Array(9).fill(null).map(() => Array(9).fill(null));
    const setup = (y, o, ps) => ps.forEach((p, x) => { if (p) board[y][x] = { type: p, owner: o } });
    setup(0, 'G', ['KY','KE','GI','KI','OU','KI','GI','KE','KY']); board[1][1]={type:'HI',owner:'G'}; board[1][7]={type:'KA',owner:'G'}; setup(2,'G',Array(9).fill('FU'));
    setup(6, 'S', Array(9).fill('FU')); board[7][1]={type:'KA',owner:'S'}; board[7][7]={type:'HI',owner:'S'}; setup(8,'S',['KY','KE','GI','KI','OU','KI','GI','KE','KY']);
    const bStr = JSON.stringify(board);
    const newState = { board: bStr, handS: [], handG: [], turn: 'S', timers: {S: m, G: m}, config: {main: m, byo: b}, lastTick: 0, winner: null, history: [{ board: bStr, handS: [], handG: [], type: '開始' }] };
    set(gameRef, newState);
  };

  document.getElementById('btnResign').onclick = () => {
    if (state.winner || state.turn !== mySide) return;
    if (!confirm("投了しますか？")) return;
    state.winner = (mySide === 'S' ? 'G' : 'S');
    set(gameRef, { ...state, board: JSON.stringify(state.board) });
    alert(`${state.winner === 'S' ? '先手' : '後手'}の勝ちです！`);
  };

  onValue(gameRef, (snap) => {
    const data = snap.val();
    if (data) {
      state = data;
      state.board = JSON.parse(data.board);
      state.history = data.history || [];
      document.getElementById('cfgMain').value = state.config.main / 60;
      document.getElementById('cfgByo').value = state.config.byo;
      if (!isReviewMode) viewIdx = state.history.length - 1;
      render();
      updateKifuList();
    }
  });

  function handleCellClick(x, y) {
    if (isReviewMode || state.winner || state.turn !== mySide || pendingProm) return;
    const target = state.board[y][x];
    if (sel && possibleMoves.some(m => m.x === x && m.y === y)) {
      const fromP = state.board[sel.y][sel.x];
      if (target && target.owner !== mySide) {
        const h = (mySide === 'S' ? state.handS : state.handG) || [];
        h.push(UNPROMOTE_MAP[target.type] || target.type);
        if (mySide === 'S') state.handS = h; else state.handG = h;
      }
      const moveData = { side: mySide, fromX: sel.x, fromY: sel.y, toX: x, toY: y, type: fromP.type, isDrop: false, isPromoted: false };
      state.board[y][x] = { type: fromP.type, owner: mySide };
      state.board[sel.y][sel.x] = null;
      const isSente = (mySide === 'S'), promLine = isSente ? [0,1,2] : [6,7,8];
      if (PROMOTE_MAP[fromP.type] && (promLine.includes(y) || promLine.includes(sel.y))) {
        const deadLine = isSente ? 0 : 8;
        if (((fromP.type === 'FU' || fromP.type === 'KY') && y === deadLine) || (fromP.type === 'KE' && (isSente ? y <= 1 : y >= 7))) {
          state.board[y][x].type = PROMOTE_MAP[fromP.type];
          moveData.type = PROMOTE_MAP[fromP.type]; moveData.isPromoted = true;
          finish(moveData);
        } else {
          pendingProm = { x, y, moveData };
          document.getElementById('promote-dialog').style.display = 'block';
          render();
        }
      } else { finish(moveData); }
      return;
    }
    if (selH) {
      if (!target) {
        if (selH.type === 'FU' && state.board.some(r => r[x]?.type === 'FU' && r[x]?.owner === mySide)) return;
        state.board[y][x] = { type: selH.type, owner: mySide };
        (mySide === 'S' ? state.handS : state.handG).splice(selH.idx, 1);
        finish({ side: mySide, toX: x, toY: y, type: selH.type, isDrop: true });
      } else { selH = null; render(); }
      return;
    }
    if (target && target.owner === mySide) {
      sel = { x, y }; selH = null; 
      possibleMoves = getRawMoves(x, y, state.board, mySide).filter(m => {
          const tempBoard = JSON.parse(JSON.stringify(state.board));
          tempBoard[m.y][m.x] = tempBoard[y][x]; tempBoard[y][x] = null;
          return !isChecked(tempBoard, mySide);
      });
      render();
    }
  }

  function render() {
    const viewData = (isReviewMode && viewIdx >= 0 && state.history[viewIdx]) ? state.history[viewIdx] : state;
    const b = (typeof viewData.board === 'string') ? JSON.parse(viewData.board) : viewData.board;
    
    for (let y = 0; y < 9; y++) {
      for (let x = 0; x < 9; x++) {
        const c = cells[y][x]; const p = b[y][x];
        c.className = `cell ${!isReviewMode && sel?.x===x && sel?.y===y ? 'selected' : ''}`;
        c.innerHTML = p ? `<div class="piece ${p.owner!=='S'?'opposite':''} ${UNPROMOTE_MAP[p.type]?'promoted':''}">${SYMBOLS[p.type]}</div>` : '';
      }
    }
    const drawH = (id, list, owner) => {
      const el = document.getElementById(id); el.innerHTML = '';
      (list || []).forEach((t, i) => {
        const s = document.createElement('span'); s.textContent = SYMBOLS[t];
        if (!isReviewMode && selH?.idx === i && selH?.owner === owner) s.style.background = 'orange';
        s.onclick = (e) => {
          e.stopPropagation(); if (isReviewMode || state.winner || state.turn !== mySide || owner !== mySide) return;
          if (selH?.idx === i) selH = null; else { selH = { type: t, owner, idx: i }; sel = null; possibleMoves = []; }
          render();
        };
        el.appendChild(s);
      });
    };
    drawH('handS', viewData.handS, 'S'); drawH('handG', viewData.handG, 'G');
    const status = document.getElementById('status-txt');
    if (state.winner) { status.textContent = `${state.winner === 'S' ? '先手' : '後手'}の勝ち！`; status.style.color = "red"; }
    else if (isReviewMode) { status.textContent = "感想戦モード"; status.style.color = "orange"; }
    else { status.textContent = state.turn === mySide ? "あなたの番です" : "相手の番です"; status.style.color = "black"; }
    
    document.getElementById('nav-pos').textContent = `${isReviewMode ? viewIdx : state.history.length-1} / ${state.history.length - 1}`;
    document.getElementById('timer-S').className = `timer ${state.turn==='S'?'your-turn':''}`;
    document.getElementById('timer-G').className = `timer ${state.turn==='G'?'your-turn':''}`;
    updateTimerDisplay();
  }

  function updateKifuList() {
    const container = document.getElementById('kifu-container'); container.innerHTML = '';
    state.history.forEach((h, i) => {
      const div = document.createElement('div');
      div.className = `kifu-item ${isReviewMode && viewIdx === i ? 'active' : ''}`;
      div.textContent = formatKifuText(h, i);
      div.onclick = () => { isReviewMode = true; viewIdx = i; document.getElementById('review-panel').style.display='block'; render(); updateKifuList(); };
      container.appendChild(div);
      if (isReviewMode && viewIdx === i) div.scrollIntoView({ block: 'nearest' });
    });
  }

  function formatKifuText(move, idx) {
    if (idx === 0) return "開始局面";
    const side = move.side === 'S' ? "▲" : "△";
    const x = 9 - move.toX, y = KANJI_NUM[move.toY + 1];
    const isSameAsPrev = (idx > 1 && move.toX === state.history[idx-1].toX && move.toY === state.history[idx-1].toY);
    const pos = isSameAsPrev ? "同　" : `${x}${y}`;
    let type = SYMBOLS[move.type];
    if (move.isPromoted) type += "成"; else if (move.isDrop) type += "打";
    return `${idx}. ${side}${pos}${type}`;
  }

  document.getElementById('btnToggleReview').onclick = function() {
    isReviewMode = !isReviewMode;
    this.textContent = isReviewMode ? "対局に戻る" : "感想戦開始";
    document.getElementById('review-panel').style.display = isReviewMode ? 'block' : 'none';
    viewIdx = state.history.length - 1;
    render();
    updateKifuList();
  };

  document.getElementById('nav-prev').onclick = () => { if (viewIdx > 0) { viewIdx--; render(); updateKifuList(); } };
  document.getElementById('nav-next').onclick = () => { if (viewIdx < state.history.length - 1) { viewIdx++; render(); updateKifuList(); } };
  
  document.getElementById('btn-prom-yes').onclick = () => { 
    pendingProm.moveData.type = PROMOTE_MAP[pendingProm.moveData.type];
    pendingProm.moveData.isPromoted = true;
    state.board[pendingProm.y][pendingProm.x].type = pendingProm.moveData.type;
    endProm(); 
  };
  document.getElementById('btn-prom-no').onclick = () => endProm();
  function endProm() { const d = pendingProm.moveData; pendingProm = null; document.getElementById('promote-dialog').style.display = 'none'; finish(d); }

  const getRawMoves = (x, y, board, owner) => {
    const moves = []; const p = board[y][x]; if (!p) return moves;
    const f = (owner === 'S') ? -1 : 1;
    const add = (tx, ty) => { if (tx>=0 && tx<9 && ty>=0 && ty<9 && board[ty][tx]?.owner !== owner) moves.push({x:tx, y:ty}); };
    const slide = (vx, vy) => {
      let tx = x + vx, ty = y + vy;
      while (tx>=0 && tx<9 && ty>=0 && ty<9) {
        if (board[ty][tx]) { if (board[ty][tx].owner !== owner) moves.push({x:tx, y:ty}); break; }
        moves.push({x:tx, y:ty}); tx += vx; ty += vy;
      }
    };
    const t = p.type;
    if (['KI','TO','NY','NK','NG'].includes(t)) [[-1,f],[0,f],[1,f],[-1,0],[1,0],[0,-f]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='FU') add(x, y+f);
    else if (t==='KY') slide(0, f);
    else if (t==='KE') { add(x-1,y+f*2); add(x+1,y+f*2); }
    else if (t==='GI') [[-1,f],[0,f],[1,f],[-1,-f],[1,-f]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='KA') [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>slide(vx,vy));
    else if (t==='HI') [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>slide(vx,vy));
    else if (t==='OU') [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([vx,vy])=>add(x+vx,y+vy));
    else if (t==='UM') { [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>slide(vx,vy)); [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>add(x+vx,y+vy)); }
    else if (t==='RY') { [[0,1],[0,-1],[1,0],[-1,0]].forEach(([vx,vy])=>slide(vx,vy)); [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([vx,vy])=>add(x+vx,y+vy)); }
    return moves;
  };

  document.getElementById('mySideSelect').onchange = (e) => { mySide = e.target.value; boardEl.style.transform = (mySide === 'G') ? 'rotate(180deg)' : 'rotate(0deg)'; };
  document.getElementById('btnFlip').onclick = () => { boardEl.style.transform = boardEl.style.transform === 'rotate(180deg)' ? 'rotate(0deg)' : 'rotate(180deg)'; };

  function updateTimerDisplay() {
    if (state.lastTick === 0 && !state.winner) {
        ['S','G'].forEach(s => {
            const rem = state.timers[s];
            const min = Math.floor(rem/60), sec = rem%60;
            document.getElementById(`timer-${s}`).textContent = `${s==='S'?'▲':'△'} ${min}:${sec.toString().padStart(2,'0')}`;
        });
        return;
    }
    const elapsed = state.lastTick === 0 ? 0 : Math.floor((Date.now() - state.lastTick) / 1000);
    ['S','G'].forEach(s => {
      let rem = state.timers[s];
      if (state.turn === s && !state.winner && !isReviewMode) {
        if (rem > 0) rem = Math.max(0, rem - elapsed);
        else rem = Math.max(0, (state.config ? state.config.byo : 30) - elapsed);
      }
      const min = Math.floor(rem/60), sec = rem%60;
      document.getElementById(`timer-${s}`).textContent = `${s==='S'?'▲':'△'} ${min}:${sec.toString().padStart(2,'0')}`;
    });
  }

  setInterval(updateTimerDisplay, 1000);
</script>
</body>
</html>
